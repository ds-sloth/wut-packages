From f36cf7c86f7fe8733096f2e6de35f821335dad29 Mon Sep 17 00:00:00 2001
From: GaryOderNichts <12049776+GaryOderNichts@users.noreply.github.com>
Date: Sat, 13 Aug 2022 09:58:06 +0200
Subject: [PATCH 01/28] Wii U support

commit 54e4e2d678dc6ff816996716925c00fe92d68371
Author: GaryOderNichts <12049776+GaryOderNichts@users.noreply.github.com>
Date:   Mon Feb 1 00:00:11 2021 +0100

    audio/wiiu: don't wait if device is not enabled

commit a407599d6da07faab912878fe8a76e02f5303933
Author: GaryOderNichts <12049776+GaryOderNichts@users.noreply.github.com>
Date:   Sun Jan 31 23:59:28 2021 +0100

    audio/wiiu: deregister framecallback before freeing sources

commit 6815956b2b4e8b317e0cc691a05815cea9d323db
Author: GaryOderNichts <12049776+GaryOderNichts@users.noreply.github.com>
Date:   Sun Aug 30 22:21:17 2020 +0200

    render/wiiu: change origin to the upper left (#63)

commit 87ed1223be7747e077c451b0e0ff8949a552aadb
Author: Sergio Padrino <sergio.padrino@gmail.com>
Date:   Sun Jun 21 10:53:45 2020 +0200

    Add GameController support for the Wii U Gamepad (#59)

commit eb05b491c1b19451a8712efbc887d4b5d2349220
Author: Ash Logan <ash@heyquark.com>
Date:   Thu Apr 23 21:20:23 2020 +1000

    video/wiiu: Don't replace an already running ProcUI

commit e3d21918895e5f2c7c916edf8f0c9f206dac57b5
Author: Ash Logan <ash@heyquark.com>
Date:   Sun Jan 5 12:49:02 2020 +1100

    render/wiiu: respect SDL_RENDERER_PRESENTVSYNC

commit a9be38d3a1c21ebf6b2d4f27d32cbbca834aa78e
Author: Ash Logan <ash@heyquark.com>
Date:   Thu Nov 21 13:52:07 2019 +1100

    cmake: Don't link against stub libraries

commit 71e63524fcdd7bd44f7291e58d381eaa6e0ed958
Author: Ash Logan <ash@heyquark.com>
Date:   Thu Nov 21 13:38:45 2019 +1100

    audio/wiiu: Add maps for mono and stereo audio

commit f7568b7d97b51acb3671b6990161d9cac75b9fc4
Author: Ash Logan <ash@heyquark.com>
Date:   Thu Nov 21 13:01:12 2019 +1100

    joystick/wiiu: Add player index support

commit 26290a65a64efefd3a2842143592e6f7497a6232
Author: rw-r-r-0644 <r.r.qwertyuiop.r.r@gmail.com>
Date:   Thu Oct 17 18:48:51 2019 +0200

    audio/wiiu: FIx right audio channel
    The deinterleaving algorithm ended up overwriting the first half of the right channel buffer

commit 7c235083d0f7a0ec6acab3a215e559a471cddf73
Author: Ash Logan <ash@heyquark.com>
Date:   Thu Oct 17 18:39:15 2019 +1100

    audio/wiiu: Attempt to make stereo become n-channel (broken)

    This does something odd with the right channel and it sounds wrong

commit d929c75f0b3237218a7ee8f7f691b68ca304cdff
Author: Ash Logan <ash@heyquark.com>
Date:   Sat Sep 21 22:47:38 2019 +1000

    audio/wiiu: (very) early stereo implementation

    -Remove calculations relying on buffer size instead of sample count
    - Add some temp code to deinterleave on the CPU
    - Add a crap solution - voice_r. Really should be an array of voices,
    gimme some time for that

commit fa6d0c47b8b57e7e4f0b263ef033205a6e3ca993
Author: Ash Logan <ash@heyquark.com>
Date:   Fri Sep 20 23:07:36 2019 +1000

    audio/wiiu: Properly initialise AXVoiceDeviceMixData

    (fixes odd behaviour when surround sound is enabled, hopefully)

commit 0c51093c689af695bd13ad0aef0691086b5c5f1a
Author: rw-r-r-0644 <r.r.qwertyuiop.r.r@gmail.com>
Date:   Sun May 26 15:46:07 2019 +0200

    Update build instructions

commit 0eaa9070a2764fe3ea5b9ce86be9234717a76bb7
Author: Ash Logan <ash@heyquark.com>
Date:   Sun Mar 24 21:07:14 2019 +1100

    joystick/wiiu: Add support for WPAD/KPAD controllers

commit 776380a70fa3c36f4de245ab7478883086783293
Author: Ash Logan <ash@heyquark.com>
Date:   Sun Mar 24 19:04:18 2019 +1100

    joystick/wiiu bugfix: Don't hardcode Gamepad device_index to 0

commit 564c25b52f18c84e2c6954c651a9e0a734fa9b8e
Author: Ash Logan <ash@heyquark.com>
Date:   Sun Mar 24 19:01:21 2019 +1100

    joystick/wiiu: Hotplug support (gamepad only)

commit d3c3ee1e9851816690451d44cbf130ec4c6dd1ce
Author: Ash Logan <ash@heyquark.com>
Date:   Sat May 4 20:35:42 2019 +1000

    big oops: missed a merge conflict on 2.0.9

commit f2e83587ad857ab213caf0229fcd948bf4e48b2a
Author: Ash Logan <ash@heyquark.com>
Date:   Sun Mar 24 14:55:39 2019 +1100

    cmake: Update SDL_LIBS so pkg-config pulls in needed Cafe libs

commit bf5e9a1cd58edeec9c89503e414be9890f10e478
Author: rw-r-r-0644 <r.r.qwertyuiop.r.r@gmail.com>
Date:   Tue Mar 19 00:34:06 2019 +0100

    render/wiiu: Fix scaling mode for windowTex

    Previously the driver would always end up using point scaling as the final windows texture scaling mode and thus the screen output

commit 6ba2f62f389db561faa6680304ef2ea3a9df0342
Author: rw-r-r-0644 <r.r.qwertyuiop.r.r@gmail.com>
Date:   Mon Mar 18 23:11:18 2019 +0100

    render/wiiu: Allocate normal textures from MEM2

    MEM1 fills up very quickly and soon runs out of space for apps with many textures

commit 14bbb4a0f195c69aaedb79505ebd21f361629a37
Author: rw-r-r-0644 <r.r.qwertyuiop.r.r@gmail.com>
Date:   Mon Mar 18 22:46:17 2019 +0100

    render/wiiu: DestroyRenderer: Wait for the rendering to finish and free texture draw data

commit c349a796968f60779bfe6fc031eb5ddfdf427152
Author: rw-r-r-0644 <r.r.qwertyuiop.r.r@gmail.com>
Date:   Mon Mar 18 22:45:06 2019 +0100

    render/wiiu: Free render data after calling GX2DrawDone

commit fb9cda3712a6fb620b54c0abea27127440d3d447
Author: rw-r-r-0644 <r.r.qwertyuiop.r.r@gmail.com>
Date:   Mon Mar 18 22:43:01 2019 +0100

    render/wiiu: Reintroduce check removed with fd92b81 to fix crashes

commit 4388bea3adf3962d66449f10b4f8c8d96c3e2cdb
Author: rw-r-r-0644 <r.r.qwertyuiop.r.r@gmail.com>
Date:   Mon Mar 18 15:18:29 2019 +0100

    render/wiiu: Fix the remaining graphical glitches!

commit d4f823db4701c632f6ef9dc6730ce66b3fd9cfda
Author: rw-r-r-0644 <r.r.qwertyuiop.r.r@gmail.com>
Date:   Sun Mar 10 01:58:34 2019 +0100

    render/wiiu: Code cleanup

    * Remove unused functions
    * Remove unneeded checks
    * Uniform coding style with the rest of SDL

commit 74a42de67b2d298449f6ef24ad24a4d258094663
Author: rw-r-r-0644 <r.r.qwertyuiop.r.r@gmail.com>
Date:   Sun Mar 10 01:06:15 2019 +0100

    render/wiiu: Use WIIU_FreeRenderData in DestroyRenderer

commit 87fbbbec7e3fd4a1a74c0975e9bca32c508013eb
Author: rw-r-r-0644 <r.r.qwertyuiop.r.r@gmail.com>
Date:   Sun Mar 10 01:05:18 2019 +0100

    render/wiiu: Update RenderReadPixels to lock the surface and use the correct texture format

commit ceb9f1c09626d2500d7fec6229228c8e9338ffc7
Author: rw-r-r-0644 <r.r.qwertyuiop.r.r@gmail.com>
Date:   Sun Mar 10 00:53:02 2019 +0100

    render/wiiu: Fix compiler warnings

commit 7a02c03542b74f893a90a915272c5359a66cf9e8
Author: rw-r-r-0644 <r.r.qwertyuiop.r.r@gmail.com>
Date:   Sun Mar 10 00:46:05 2019 +0100

    render/wiiu: Reduce GX2SetContextState calls

    The function takes a fairly long time to complete

commit 7507d2b9a2ef3ddfc481620f9c5c6c0e0d8b1b8c
Author: rw-r-r-0644 <r.r.qwertyuiop.r.r@gmail.com>
Date:   Sun Mar 10 00:40:22 2019 +0100

    render/wiiu: Disable blending for render_scene

commit 7446bdc731fe438452ca2c281363066bebf879c2
Author: rw-r-r-0644 <r.r.qwertyuiop.r.r@gmail.com>
Date:   Sun Mar 10 00:36:38 2019 +0100

    render/wiiu: Implement SetTextureColorMod/SetTextureAlphaMod

commit fcb1d216834de237db57fdf94189ad844cc18afd
Author: rw-r-r-0644 <r.r.qwertyuiop.r.r@gmail.com>
Date:   Sun Mar 10 00:25:10 2019 +0100

    render/wiiu: Use vec* for u_texSize and u_viewSize

commit eba4263f0078a97cf9bfdc7047b11b410d852877
Author: Ash Logan <ash@heyquark.com>
Date:   Fri Mar 8 11:41:31 2019 +1100

    render/wiiu: Re-set context state after a clear

    whb does this, so y'know

commit dcb58351f0540c06b9399049cf8b603773ddacb4
Author: Ash Logan <ash@heyquark.com>
Date:   Fri Mar 8 11:23:03 2019 +1100

    render/wiiu: Textures keep their own colour buffers

commit 8c4b5c066eb65b6ba3c6844c507f04da36adf59b
Author: Ash Logan <ash@heyquark.com>
Date:   Thu Mar 7 22:10:27 2019 +1100

    render/wiiu: Use point scaling by default

    see https://wiki.libsdl.org/SDL_HINT_RENDER_SCALE_QUALITY

commit da762c2f051c05b6185272ad798d34ea97b3dff4
Author: Ash Logan <ash@heyquark.com>
Date:   Thu Mar 7 21:59:49 2019 +1100

    video/wiiu: Add support for DRC/TV only windows (#1)

commit f814e40fcfc8b5deb92bccc27036390ae82a465b
Author: Kuruyia <Arc13@users.noreply.github.com>
Date:   Sun Mar 3 13:19:55 2019 +0100

    video/wiiu: Add flags to only draw on TV or Gamepad (#1)

commit b6873f94f4ea0394fcfd9dc289ca043595578c7c
Author: rw-r-r-0644 <r.r.qwertyuiop.r.r@gmail.com>
Date:   Fri Feb 1 19:17:33 2019 +0100

    Edit README for the wiiu port

commit d58f563d65e1b5ca48a91dba6cb7f8e37e90c85e
Author: rw-r-r-0644 <r.r.qwertyuiop.r.r@gmail.com>
Date:   Thu Jan 24 08:44:37 2019 +0100

    input/wiiu: Clear last_touched after sending touch release event

commit 73ba9417333ff0b7954de3e4dec57d307b34964f
Author: Ash Logan <ash@heyquark.com>
Date:   Wed Mar 6 19:53:43 2019 +1100

    render/wiiu: Use vec* for FillRects (fixes no-draw bug)

commit 482fa506074535559179e3cbb6c48f18426d0760
Author: Ash Logan <ash@heyquark.com>
Date:   Wed Mar 6 19:05:58 2019 +1100

    render/wiiu: Fix present position/texcoord confusion

commit 2b640b8e7b1cde5ef573b07e0ca32d237ef0b9fa
Author: Ash Logan <ash@heyquark.com>
Date:   Wed Mar 6 17:52:57 2019 +1100

    render/wiiu: Respect window sizes

commit b17164d5f6fde26711148b6d2d269adfbe440693
Author: Ash Logan <ash@heyquark.com>
Date:   Wed Mar 6 15:43:40 2019 +1100

    render/wiiu: Handle window size changes

commit 89013edb6cd71d5e6234f1f24901f70a6c260c59
Author: Ash Logan <ash@heyquark.com>
Date:   Wed Mar 6 09:17:45 2019 +1100

    render/wiiu: readability - introduce vec* structs for drawing

commit e147fbab725cdccca003d8be050e01db936a6e72
Author: Ash Logan <ash@heyquark.com>
Date:   Tue Mar 5 22:27:45 2019 +1100

    render/wiiu: Fix resource flags on texture creation

commit 72d34778d6a5bf3871ac1710e11dbae76438c386
Author: Ash Logan <ash@heyquark.com>
Date:   Tue Mar 5 22:27:13 2019 +1100

    render/wiiu: Convert RenderData to use GX2RBuffers

commit ca33399a70de086d4331a33593266570fefad7fb
Author: Ash Logan <ash@heyquark.com>
Date:   Tue Mar 5 13:07:53 2019 +1100

    render/wiiu: Use GX2R for texture surfaces
    Untested at time of commit, hopefully it works hehe

commit fa157dbcaaeb3596de5a6b6c4566c5b902b81364
Author: Ash Logan <ash@heyquark.com>
Date:   Tue Mar 5 12:00:41 2019 +1100

    video/wiiu: Remove the last of the emulated framebuffer

commit e713fb41d13dc58f8d2a48286ec86eb6b604522a
Author: Ash Logan <ash@heyquark.com>
Date:   Wed Feb 20 22:37:39 2019 +1100

    render/wiiu: FLUSH THE CACHE. FLUSH THE CACHE.

commit aebe08cf45261221f431bd59fd1124ae46cbc9b6
Author: Ash Logan <ash@heyquark.com>
Date:   Wed Feb 20 21:44:15 2019 +1100

    video/wiiu: Call SDL_SetKeyboardFocus on window creation

commit fab05b51795f0b4dd142ad57a8f87cab43ac6eb0
Author: Ash Logan <ash@heyquark.com>
Date:   Thu Jan 24 17:03:08 2019 +1100

    wiiu: first attempt at using the render driver instead of WindowFramebuffer

commit 5137bdb29f2bce2d8bd570fb195f8467073ed710
Author: rw-r-r-0644 <r.r.qwertyuiop.r.r@gmail.com>
Date:   Sat Jan 12 19:20:13 2019 +0100

    render/wiiu: Fixup color blending

commit 6824fb428499fa13c60ee2df50fb4a78b39fed0e
Author: rw-r-r-0644 <r.r.qwertyuiop.r.r@gmail.com>
Date:   Sat Jan 12 16:30:01 2019 +0100

    render/wiiu: Correct direction of rotation for RenderCopyEx

commit d3ad23e0cdab3c388de0d6a252e3fde836c5a401
Author: rw-r-r-0644 <r.r.qwertyuiop.r.r@gmail.com>
Date:   Sat Jan 12 16:28:03 2019 +0100

    render/wiiu: Drawing is synchronized with refresh rate

commit e88463592dbd86734ddde81b05e8fb54c1365f96
Author: rw-r-r-0644 <r.r.qwertyuiop.r.r@gmail.com>
Date:   Sat Jan 12 13:08:15 2019 +0100

    Add README.md for the WiiU port

commit 2022692d60604989bc23e6f6884eef60cdbfa42d
Author: Ash Logan <ash@heyquark.com>
Date:   Sat Jan 12 20:59:50 2019 +1100

    render/wiiu: Add support for color/alpha mod values/some blend modes

commit b0defceb9b7088f108cb16573ac4ff69470ec55e
Author: Ash Logan <ash@heyquark.com>
Date:   Sat Jan 12 20:57:21 2019 +1100

    add gitignore (sorry)

commit 4134be1cb8e570d60da74b25d240acb83f1739ea
Author: Ash Logan <ash@heyquark.com>
Date:   Thu Jan 3 20:13:22 2019 +1100

    render/wiiu: don't put debug messages in the released code

commit cbc64b5f3ebaab670ab03da40330fba1cc939414
Author: Ash Logan <ash@heyquark.com>
Date:   Thu Jan 3 17:04:26 2019 +1100

    render: Add loads of GX2 texture formats

commit dd77800d1c6792eeaae3c1b80616d2efc5ad0b7c
Author: Ash Logan <ash@heyquark.com>
Date:   Thu Jan 3 13:41:40 2019 +1100

    include: Add extra checks for endian on devkitPPC

commit 3e20fffb497457e308549f4335f5e00d9278e128
Author: Ash <ash@heyquark.com>
Date:   Tue Nov 6 21:12:17 2018 +1100

    render/wiiu: Safety checks on SDL_DestroyTexture

commit 6b2e8b91137c5b1cff6d6dbfe1edcea851ef4378
Author: rw-r-r-0644 <r.r.qwertyuiop.r.r@gmail.com>
Date:   Tue Nov 6 17:55:40 2018 +0100

    wiiu/shaders: Add shader source code + basic regenerate script

commit 94a46ebb358dd8a68c3d32e42cad98862c99bf0b
Author: rw-r-r-0644 <r.r.qwertyuiop.r.r@gmail.com>
Date:   Tue Oct 30 22:04:29 2018 +0100

    wiiu: Switch to cmake

commit 9bee9180c22301df2303696d0733d0eb151e3d3b
Author: rw-r-r-0644 <r.r.qwertyuiop.r.r@gmail.com>
Date:   Tue Oct 30 21:58:51 2018 +0100

    wiiu/joystick: Updates for the new joystick interfaces

commit 463b9e07e44071ef44ce4973bba5347030c8c171
Author: rw-r-r-0644 <r.r.qwertyuiop.r.r@gmail.com>
Date:   Sun Oct 28 19:41:37 2018 +0100

    wiiu: Updates for newer SDL

commit 37f2ef8682737ea1c275d5729d7284c38229d71b
Author: rw-r-r-0644 <r.r.qwertyuiop.r.r@gmail.com>
Date:   Sun Oct 28 14:34:06 2018 +0100

    wiiu: Edit config comment to prevent gcc warning

commit b3e82ffb3f0656eda5f6da5688b97f5c52367986
Author: rw-r-r-0644 <r.r.qwertyuiop.r.r@gmail.com>
Date:   Sun Oct 28 14:04:02 2018 +0100

    wiiu/render: Temporaneously disable formats other than RGBA8888 until the cause of bad colors is found

commit ef7d10e54ea6eb71b28bb2a5067765d4fe599a06
Author: rw-r-r-0644 <r.r.qwertyuiop.r.r@gmail.com>
Date:   Sun Oct 28 01:05:06 2018 +0200

    wiiu/render: Enable alpha merge/other settings

commit b413dafb06ec7439998040a35546b6ae8c2120ee
Author: rw-r-r-0644 <r.r.qwertyuiop.r.r@gmail.com>
Date:   Sun Oct 28 00:49:10 2018 +0200

    wiiu: Move coordinates math to shader

commit a7ee3dd5329e89d3bb1e187ac2a3140a90c591f7
Author: rw-r-r-0644 <r.r.qwertyuiop.r.r@gmail.com>
Date:   Sat Oct 27 21:55:00 2018 +0200

    wiiu/render: Fix final bugs; it partially works now \o/

commit aa08e434c988c9e5f2c6709bf92b28b8851b186e
Author: rw-r-r-0644 <r.r.qwertyuiop.r.r@gmail.com>
Date:   Sat Oct 27 17:48:35 2018 +0200

    wiiu/render: Fix GX2ContextState alignment

commit 0ea992080b0ee965be5127cc6533a7ac2013cb25
Author: rw-r-r-0644 <r.r.qwertyuiop.r.r@gmail.com>
Date:   Sat Oct 27 17:47:37 2018 +0200

    wiiu/video: Add more attributes for texture

commit 769a4dd0869b5703f8baea14972ee37c71b616c2
Author: rw-r-r-0644 <r.r.qwertyuiop.r.r@gmail.com>
Date:   Sat Oct 27 13:14:18 2018 +0200

    wiiu/render: SDL_GetWindowSurface is needed to create the framebuffer

commit 3798398c514a58e0ab92c7578695aa2cdd631b43
Author: rw-r-r-0644 <r.r.qwertyuiop.r.r@gmail.com>
Date:   Thu Oct 25 17:16:23 2018 +0200

    wiiu: Linking fixes

commit 888d0c5dcada9a9d6aa71a886f5695020fd29688
Author: rw-r-r-0644 <r.r.qwertyuiop.r.r@gmail.com>
Date:   Wed Oct 24 21:59:02 2018 +0200

    render/wiiu: Fix compiling, implement RenderCopyEx, make some render vars unique for objects, add missing shaders

commit 3cb1ed94bd528d594b20818dc5da43bd6b35d388
Author: Ash <ash@heyquark.com>
Date:   Sun Oct 21 19:45:53 2018 +1100

    render/wiiu: Start fixing up missing headers

commit 57639657dbd6fe7fa4c8c1d5d755d03b6c3fc702
Author: Ash <ash@heyquark.com>
Date:   Sun Oct 21 19:35:09 2018 +1100

    render: Start compiling the wiiu renderer (lotsa errors)

commit a1fe555cad8eda802fedc0971cf85b04f786ccfc
Author: rw-r-r-0644 <r.r.qwertyuiop.r.r@gmail.com>
Date:   Wed Oct 17 23:05:52 2018 +0200

    wiiu: Add more renderer function, make functions non-static, start adding new shaders

commit d120ddd096029d24889a124ec54726eb4d7fb4bf
Author: Ash <ash@heyquark.com>
Date:   Wed Oct 17 18:59:58 2018 +1100

    wiiu/render: move drawing functions to own file

commit 273e19c2ce9e699a460a5c3bc479382687b24d85
Author: rw-r-r-0644 <r.r.qwertyuiop.r.r@gmail.com>
Date:   Wed Oct 17 00:05:10 2018 +0200

    wiiu/render: Implement UpdateTexture/RenderClear

commit 4fa755d52f32f5f56ca2784af92e45fbe3f5ed81
Author: Ash <ash@heyquark.com>
Date:   Tue Oct 16 15:59:44 2018 +1100

    wiiu/render: Stub UpdateViewport / UpdateClipRect

commit 084e2b9efbf8fb394bdea8b121fdeb1c73b0283c
Author: Ash <ash@heyquark.com>
Date:   Tue Oct 16 15:44:19 2018 +1100

    wiiu/render: Implement SDL_LockTexture and SDL_UnlockTexture

commit a01adf4e00d049e73fafc15e22eec9d107ba864c
Author: Ash <ash@heyquark.com>
Date:   Tue Oct 16 15:33:37 2018 +1100

    wiiu/render: Remove optional SetTextureMod functions

commit e5fae70caf34291dea73a03415bec9454edc45a0
Author: Ash <ash@heyquark.com>
Date:   Tue Oct 16 15:33:06 2018 +1100

    wiiu/render: Move texture-related functions to own file

commit 0949442d7a27c869b7e7ad754eb115f5c9bd6913
Author: Ash <ash@heyquark.com>
Date:   Tue Oct 16 15:14:07 2018 +1100

    wiiu/render: Implement GetOutputSize

commit 03826edb25442ee1e0744d0891d2f2f5ff98f6dd
Author: Ash <ash@heyquark.com>
Date:   Tue Oct 16 15:07:29 2018 +1100

    wiiu/render: move window-related functions to own file

commit cea1907155cfaed4203db3921e1f0611097ec29e
Author: Ash <ash@heyquark.com>
Date:   Tue Oct 16 15:00:43 2018 +1100

    wiiu/render: consolidate calls to SetRenderTarget, minor tweaks

commit c337fd57f50696d04639474bb059f3a44291e4ed
Author: Ash <ash@heyquark.com>
Date:   Tue Oct 16 14:42:37 2018 +1100

    wiiu/render: Move function sigs and definitions to dedicated header

commit 036b864413a108fed1b0e93458a75f1f143f5cae
Author: Ash <ash@heyquark.com>
Date:   Tue Oct 16 14:31:24 2018 +1100

    wiiu/render: Minor formatting, move windowdata to header

commit 72a32e7ed49d7ab2e0266e43ca65e2f048b95a0d
Author: Ash <ash@heyquark.com>
Date:   Tue Oct 16 14:18:31 2018 +1100

    wiiu/video: move window data to header

commit 162447e20b136ba1524f70ba3d1254d9ce17c27c
Author: Ash <ash@heyquark.com>
Date:   Tue Oct 16 14:10:17 2018 +1100

    wiiu: render: Be consistent about tabs/spaces

commit 53fd78a2fbe424001ffa5b07b5019b950d49f493
Author: rw-r-r-0644 <r.r.qwertyuiop.r.r@gmail.com>
Date:   Sun Oct 14 22:32:43 2018 +0200

    wiiu: Implement more renderer functions (1)

commit 7850c3e0541060c39d824808c77584b2b8c206e6
Author: rw-r-r-0644 <r.r.qwertyuiop.r.r@gmail.com>
Date:   Sat Oct 13 22:37:22 2018 +0200

    wiiu: Start implementing SDL_Renderer

commit 5ab6c7a9d788547520aa6e6d0d98fef3c03e9683
Author: rw-r-r-0644 <r.r.qwertyuiop.r.r@gmail.com>
Date:   Sat Oct 13 00:04:03 2018 +0200

    wiiu: switch to tpNormal, tpFiltered1 casues scrolling issues

commit 541c794cd278ce3a4743fb8e25d2ca1fc2497ef2
Author: rw-r-r-0644 <r.r.qwertyuiop.r.r@gmail.com>
Date:   Tue Oct 9 20:26:55 2018 +0200

    wiiu: Disable DRC surround mode as it causes distortion

commit 9b21f4847ea88cd4d780918c84bfeec6ef6b82e8
Author: Ash <ash@heyquark.com>
Date:   Mon Oct 1 21:23:51 2018 +1000

    video: Respect application's requested window size/position

commit 4846a24b0c410ff57a233de49b2e61d22bff433d
Author: Ash <ash@heyquark.com>
Date:   Mon Oct 1 20:33:24 2018 +1000

    video: move position buffer filling to UpdateWindowFramebuffer

commit c6ab8408cb11faa0de2d94074374c609df8edf44
Author: Ash <ash@heyquark.com>
Date:   Mon Oct 1 20:08:53 2018 +1000

    video: oops

commit 60d802857d5d8abca2f1cc3a105bfb3319514500
Author: Ash <ash@heyquark.com>
Date:   Mon Oct 1 20:07:32 2018 +1000

    video: Style nits

commit a7da7f77b1bb48b66b25e88fb4fc215292cdb60e
Author: Ash <ash@heyquark.com>
Date:   Mon Oct 1 20:04:42 2018 +1000

    video: start refactoring - move rendering to own function

commit 9b7b41d901b8611c29e390f1ad05f81b185c3373
Author: rw-r-r-0644 <r.r.qwertyuiop.r.r@gmail.com>
Date:   Sun Sep 30 16:29:14 2018 +0200

    wiiu: switch to wut.mk

commit ec7653a805073b1c27f99031e3ac8a1b9b74ae34
Author: Ash <ash@heyquark.com>
Date:   Sat Sep 29 20:55:44 2018 +1000

    audio: DCFlushRange -> DCStoreRange

commit fb5bfa0a579c9494ddb945544849ed1b9156c1b8
Author: Ash <ash@heyquark.com>
Date:   Sat Sep 29 20:54:17 2018 +1000

    audio: Send voice to TV

commit bfb51a0f006a650ff93f3143348ad2a84b4e050e
Author: Ash <ash@heyquark.com>
Date:   Sat Sep 29 20:07:22 2018 +1000

    audio: Add *very* early wiiu audio support

commit a910c0765a0703b7c3d3299d07b3b0e4a553e776
Author: rw-r-r-0644 <r.r.qwertyuiop.r.r@gmail.com>
Date:   Sun Sep 23 10:48:00 2018 +0200

    wiiu: explicitly set endianess in config (thanks @quarktheawesome) [needed for missing defines in toolchain]

commit 70f923cc9121d6c7415f342b51bf339a23ccf29e
Author: rw-r-r-0644 <r.r.qwertyuiop.r.r@gmail.com>
Date:   Fri Sep 21 22:47:56 2018 +0200

    input/wiiu: switch back to VPADGetTPCalibratedPoint

commit 30a8901587aaf5160f8aed3072858ee7e946c266
Author: rw-r-r-0644 <r.r.qwertyuiop.r.r@gmail.com>
Date:   Fri Sep 21 20:24:40 2018 +0200

    threads/wiiu: fix crash on SDL_SYS_CreateThread: pass stack top and not stack bottom

commit 89a16883a7f4238eb122d8f0b2f0d0fc072386d1
Author: rw-r-r-0644 <r.r.qwertyuiop.r.r@gmail.com>
Date:   Fri Sep 21 20:23:23 2018 +0200

    wiiu: enable thread support and stop building generic thread impl

commit 6ea16de7c69cf0654c9de062d4fd02eee1015728
Author: rw-r-r-0644 <r.r.qwertyuiop.r.r@gmail.com>
Date:   Fri Sep 21 20:22:25 2018 +0200

    threads/wiiu: remove unused SDL_mutex structure definition and only build when requested

commit 189846753c63e12c1fd5bdf1e56fb2afcf414a45
Author: rw-r-r-0644 <r.r.qwertyuiop.r.r@gmail.com>
Date:   Fri Sep 21 20:21:33 2018 +0200

    threads/wiiu: implement SDL_CondWaitTimeout

commit 30b0133f834f9a5180a43b112ee6e8fcf01c33e0
Author: rw-r-r-0644 <r.r.qwertyuiop.r.r@gmail.com>
Date:   Fri Sep 21 20:18:10 2018 +0200

    threads/wiiu: add sysmutex_c.h header

commit 5554ca04a8e219e6947dc520934f01979bd860ad
Author: rw-r-r-0644 <r.r.qwertyuiop.r.r@gmail.com>
Date:   Fri Sep 21 20:17:39 2018 +0200

    threads/wiiu: add generic thread storage

commit 494e81f4a9202b85f1de6c5009edc9ab2ac7a061
Author: rw-r-r-0644 <r.r.qwertyuiop.r.r@gmail.com>
Date:   Fri Sep 21 20:17:15 2018 +0200

    threads/wiiu: add semaphores

commit bbb8f558ccc16317809dce928f7f87c71afbc4dd
Author: rw-r-r-0644 <r.r.qwertyuiop.r.r@gmail.com>
Date:   Tue Sep 18 21:12:43 2018 +0200

    wiiu/input: Use raw for touchscreen and check for VPADRead errors

commit cbefaaa74afe5f44a9b3ab51a958ad4b8f39cd0d
Author: rw-r-r-0644 <r.r.qwertyuiop.r.r@gmail.com>
Date:   Sun Sep 16 15:01:48 2018 +0200

    Rewrite wiiu joystick driver to better match switch's and add touchscreen support

commit 856e271d2a68eb7005169e5c7f1b2b2fe02fc410
Author: rw-r-r-0644 <r.r.qwertyuiop.r.r@gmail.com>
Date:   Sun Sep 16 14:58:17 2018 +0200

    Do not send SDL_QUIT from WIIU_PumpEvents: it causes crashes and isn't the right way to do it

commit 5d221e72f1e0053da19751efe16e3ef0e299cb50
Author: rw-r-r-0644 <r.r.qwertyuiop.r.r@gmail.com>
Date:   Sun Sep 16 14:55:37 2018 +0200

    Change shader include guard to match SDL

commit 9b777c083d80159bf533f25f29f9ec5b2619f1d5
Author: rw-r-r-0644 <r.r.qwertyuiop.r.r@gmail.com>
Date:   Sat Sep 15 23:43:02 2018 +0200

    Switch to GX2!! (thanks to exjam for his help and toolchain and aliaspider for his shader!)

commit 572c0e4021d17ed671c53793fde4fe729b830c5d
Author: rw-r-r-0644 <r.r.qwertyuiop.r.r@gmail.com>
Date:   Sun Oct 28 19:14:23 2018 +0100

    Initial support for Nintendo WiiU

Co-authored-by: rw-r-r-0644 <r.r.qwertyuiop.r.r@gmail.com>
Co-authored-by: Ash Logan <ash@heyquark.com>
Co-authored-by: Kuruyia <Arc13@users.noreply.github.com>
Co-authored-by: Sergio Padrino <sergio.padrino@gmail.com>
---
 Makefile.wiiu                             |  72 +++
 README.md                                 |  34 +-
 include/SDL_config.h.cmake                |   6 +
 include/SDL_config_wiiu.h                 | 167 +++++++
 include/SDL_endian.h                      |   2 +-
 include/SDL_platform.h                    |   4 +
 include/SDL_test_common.h                 |   3 +
 src/SDL.c                                 |   2 +
 src/SDL_log.c                             |   8 +
 src/atomic/SDL_spinlock.c                 |   8 +
 src/audio/SDL_audio.c                     |   3 +
 src/audio/SDL_sysaudio.h                  |   1 +
 src/audio/wiiu/SDL_wiiuaudio.c            | 390 ++++++++++++++++
 src/audio/wiiu/SDL_wiiuaudio.h            |  51 +++
 src/audio/wiiu/SDL_wiiuaudio_mix.h        |  65 +++
 src/dynapi/SDL_dynapi.h                   |   2 +
 src/joystick/SDL_gamecontrollerdb.h       |   3 +
 src/joystick/SDL_joystick.c               |   5 +-
 src/joystick/SDL_sysjoystick.h            |   1 +
 src/joystick/wiiu/SDL_wiiujoystick.c      | 531 ++++++++++++++++++++++
 src/joystick/wiiu/SDL_wiiujoystick.h      | 112 +++++
 src/libm/math_private.h                   |   2 +-
 src/render/SDL_render.c                   |   3 +
 src/render/SDL_sysrender.h                |   1 +
 src/render/wiiu/SDL_rdraw_wiiu.c          | 444 ++++++++++++++++++
 src/render/wiiu/SDL_render_wiiu.c         | 275 +++++++++++
 src/render/wiiu/SDL_render_wiiu.h         | 322 +++++++++++++
 src/render/wiiu/SDL_rpresent_wiiu.c       | 157 +++++++
 src/render/wiiu/SDL_rtexture_wiiu.c       | 229 ++++++++++
 src/render/wiiu/SDL_rwindow_wiiu.c        |  63 +++
 src/stdlib/SDL_malloc.c                   |   6 +
 src/thread/SDL_thread_c.h                 |   2 +
 src/thread/wiiu/SDL_syscond.c             | 146 ++++++
 src/thread/wiiu/SDL_sysmutex.c            |  72 +++
 src/thread/wiiu/SDL_sysmutex_c.h          |  22 +
 src/thread/wiiu/SDL_syssem.c              | 145 ++++++
 src/thread/wiiu/SDL_systhread.c           | 121 +++++
 src/thread/wiiu/SDL_systhread_c.h         |  27 ++
 src/thread/wiiu/SDL_systls.c              |  38 ++
 src/timer/wiiu/SDL_systimer.c             |  86 ++++
 src/video/SDL_sysvideo.h                  |   1 +
 src/video/SDL_video.c                     |   3 +
 src/video/wiiu/SDL_wiiuvideo.c            | 147 ++++++
 src/video/wiiu/SDL_wiiuvideo.h            |  45 ++
 src/video/wiiu/shaders/build_shaders.sh   |  14 +
 src/video/wiiu/shaders/colorShader.frag   |  10 +
 src/video/wiiu/shaders/colorShader.psh    |  14 +
 src/video/wiiu/shaders/colorShader.vert   |  16 +
 src/video/wiiu/shaders/colorShader.vsh    |  27 ++
 src/video/wiiu/shaders/textureShader.frag |  13 +
 src/video/wiiu/shaders/textureShader.psh  |  22 +
 src/video/wiiu/shaders/textureShader.vert |  27 ++
 src/video/wiiu/shaders/textureShader.vsh  |  44 ++
 src/video/wiiu/shaders/wiiu_shaders.c.in  |   8 +
 src/video/wiiu/wiiu_shaders.c             | 293 ++++++++++++
 src/video/wiiu/wiiu_shaders.h             |  83 ++++
 56 files changed, 4378 insertions(+), 20 deletions(-)
 create mode 100644 Makefile.wiiu
 create mode 100644 include/SDL_config_wiiu.h
 create mode 100644 src/audio/wiiu/SDL_wiiuaudio.c
 create mode 100644 src/audio/wiiu/SDL_wiiuaudio.h
 create mode 100644 src/audio/wiiu/SDL_wiiuaudio_mix.h
 create mode 100644 src/joystick/wiiu/SDL_wiiujoystick.c
 create mode 100644 src/joystick/wiiu/SDL_wiiujoystick.h
 create mode 100644 src/render/wiiu/SDL_rdraw_wiiu.c
 create mode 100644 src/render/wiiu/SDL_render_wiiu.c
 create mode 100644 src/render/wiiu/SDL_render_wiiu.h
 create mode 100644 src/render/wiiu/SDL_rpresent_wiiu.c
 create mode 100644 src/render/wiiu/SDL_rtexture_wiiu.c
 create mode 100644 src/render/wiiu/SDL_rwindow_wiiu.c
 create mode 100644 src/thread/wiiu/SDL_syscond.c
 create mode 100644 src/thread/wiiu/SDL_sysmutex.c
 create mode 100644 src/thread/wiiu/SDL_sysmutex_c.h
 create mode 100644 src/thread/wiiu/SDL_syssem.c
 create mode 100644 src/thread/wiiu/SDL_systhread.c
 create mode 100644 src/thread/wiiu/SDL_systhread_c.h
 create mode 100644 src/thread/wiiu/SDL_systls.c
 create mode 100644 src/timer/wiiu/SDL_systimer.c
 create mode 100644 src/video/wiiu/SDL_wiiuvideo.c
 create mode 100644 src/video/wiiu/SDL_wiiuvideo.h
 create mode 100755 src/video/wiiu/shaders/build_shaders.sh
 create mode 100644 src/video/wiiu/shaders/colorShader.frag
 create mode 100644 src/video/wiiu/shaders/colorShader.psh
 create mode 100644 src/video/wiiu/shaders/colorShader.vert
 create mode 100644 src/video/wiiu/shaders/colorShader.vsh
 create mode 100644 src/video/wiiu/shaders/textureShader.frag
 create mode 100644 src/video/wiiu/shaders/textureShader.psh
 create mode 100644 src/video/wiiu/shaders/textureShader.vert
 create mode 100644 src/video/wiiu/shaders/textureShader.vsh
 create mode 100644 src/video/wiiu/shaders/wiiu_shaders.c.in
 create mode 100644 src/video/wiiu/wiiu_shaders.c
 create mode 100644 src/video/wiiu/wiiu_shaders.h

diff --git a/Makefile.wiiu b/Makefile.wiiu
new file mode 100644
index 000000000..7574f36fd
--- /dev/null
+++ b/Makefile.wiiu
@@ -0,0 +1,72 @@
+BASEDIR	:= $(dir $(firstword $(MAKEFILE_LIST)))
+VPATH	:= $(BASEDIR)
+
+#---------------------------------------------------------------------------------
+# Build options
+#---------------------------------------------------------------------------------
+TARGET  = libSDL2.a
+SOURCES = \
+	src/*.c \
+	src/atomic/*.c \
+	src/audio/*.c \
+	src/audio/wiiu/*.c \
+	src/cpuinfo/*.c \
+	src/events/*.c \
+	src/file/*.c \
+	src/haptic/*.c \
+	src/haptic/dummy/*.c \
+	src/joystick/*.c \
+	src/joystick/wiiu/*.c \
+	src/joystick/dummy/*.c \
+	src/loadso/dummy/*.c \
+	src/power/*.c \
+	src/filesystem/dummy/*.c \
+	src/render/*.c \
+	src/render/wiiu/*.c \
+	src/render/software/*.c \
+	src/stdlib/*.c \
+	src/sensor/*.c \
+	src/thread/*.c \
+	src/thread/wiiu/*.c \
+	src/timer/*.c \
+	src/timer/wiiu/*.c \
+	src/timer/dummy/*.c \
+	src/video/*.c \
+	src/video/wiiu/*.c \
+	src/video/yuv2rgb/*.c \
+	src/video/dummy/*.c
+
+OBJECTS = $(shell echo $(SOURCES) | sed -e 's,\.c,\.o,g')
+INCLUDE = -I./include
+
+#---------------------------------------------------------------------------------
+# Compile flags
+#---------------------------------------------------------------------------------
+CFLAGS		+=	-O2 $(INCLUDE)
+CXXFLAGS	+=	-O2 $(INCLUDE)
+
+#---------------------------------------------------------------------------------
+# Build rules
+#---------------------------------------------------------------------------------
+.PHONY: clean install
+
+$(TARGET): $(OBJECTS)
+
+install: $(TARGET)
+	@echo INSTALL $(TARGET)
+	@mkdir -p $(PORTLIBS)/lib
+	@mkdir -p $(PORTLIBS)/include/SDL2
+	@cp $(TARGET) $(PORTLIBS)/lib/
+	@cp -f ./include/*.h $(PORTLIBS)/include/SDL2/
+
+clean:
+	@echo CLEAN ...
+	@rm -rf $(OBJECTS) $(OBJECTS:.o=.d) $(TARGET)
+
+#---------------------------------------------------------------------------------
+# Toolchain
+#---------------------------------------------------------------------------------
+include $(WUT_ROOT)/share/wut.mk
+LDFLAGS		+=	-L$(DEVKITPRO)/portlibs/ppc/lib
+CFLAGS		+=	-I$(DEVKITPRO)/portlibs/ppc/include
+CXXFLAGS	+=	-I$(DEVKITPRO)/portlibs/ppc/include
diff --git a/README.md b/README.md
index fa7f7ba0b..d1719bb6f 100644
--- a/README.md
+++ b/README.md
@@ -1,17 +1,17 @@
-
-# Simple DirectMedia Layer (SDL) Version 2.0
-
-https://www.libsdl.org/
-
-Simple DirectMedia Layer is a cross-platform development library designed
-to provide low level access to audio, keyboard, mouse, joystick, and graphics
-hardware via OpenGL and Direct3D. It is used by video playback software,
-emulators, and popular games including Valve's award winning catalog
-and many Humble Bundle games.
-
-More extensive documentation is available in the docs directory, starting
-with README.md
-
-Enjoy!
-
-Sam Lantinga (slouken@libsdl.org)
+
+# Simple DirectMedia Layer (SDL) Version 2.0
+
+https://www.libsdl.org/
+
+Simple DirectMedia Layer is a cross-platform development library designed
+to provide low level access to audio, keyboard, mouse, joystick, and graphics
+hardware via OpenGL and Direct3D. It is used by video playback software,
+emulators, and popular games including Valve's award winning catalog
+and many Humble Bundle games.
+
+More extensive documentation is available in the docs directory, starting
+with README.md
+
+Enjoy!
+
+Sam Lantinga (slouken@libsdl.org)
diff --git a/include/SDL_config.h.cmake b/include/SDL_config.h.cmake
index 35923d020..ab5b33274 100644
--- a/include/SDL_config.h.cmake
+++ b/include/SDL_config.h.cmake
@@ -329,6 +329,7 @@
 #cmakedefine SDL_AUDIO_DRIVER_PSP @SDL_AUDIO_DRIVER_PSP@
 #cmakedefine SDL_AUDIO_DRIVER_PS2 @SDL_AUDIO_DRIVER_PS2@
 #cmakedefine SDL_AUDIO_DRIVER_N3DS @SDL_AUDIO_DRIVER_N3DS@
+#cmakedefine SDL_AUDIO_DRIVER_WIIU @SDL_AUDIO_DRIVER_WIIU@
 
 /* Enable various input drivers */
 #cmakedefine SDL_INPUT_LINUXEV @SDL_INPUT_LINUXEV@
@@ -355,6 +356,7 @@
 #cmakedefine SDL_JOYSTICK_PSP @SDL_JOYSTICK_PSP@
 #cmakedefine SDL_JOYSTICK_PS2 @SDL_JOYSTICK_PS2@
 #cmakedefine SDL_JOYSTICK_N3DS @SDL_JOYSTICK_N3DS@
+#cmakedefine SDL_JOYSTICK_WIIU @SDL_JOYSTICK_WIIU@
 #cmakedefine SDL_HAPTIC_DUMMY @SDL_HAPTIC_DUMMY@
 #cmakedefine SDL_HAPTIC_LINUX @SDL_HAPTIC_LINUX@
 #cmakedefine SDL_HAPTIC_IOKIT @SDL_HAPTIC_IOKIT@
@@ -390,6 +392,7 @@
 #cmakedefine SDL_THREAD_PSP @SDL_THREAD_PSP@
 #cmakedefine SDL_THREAD_PS2 @SDL_THREAD_PS2@
 #cmakedefine SDL_THREAD_N3DS @SDL_THREAD_N3DS@
+#cmakedefine SDL_THREAD_WIIU @SDL_THREAD_WIIU@
 
 /* Enable various timer systems */
 #cmakedefine SDL_TIMER_HAIKU @SDL_TIMER_HAIKU@
@@ -401,6 +404,7 @@
 #cmakedefine SDL_TIMER_PSP @SDL_TIMER_PSP@
 #cmakedefine SDL_TIMER_PS2 @SDL_TIMER_PS2@
 #cmakedefine SDL_TIMER_N3DS @SDL_TIMER_N3DS@
+#cmakedefine SDL_TIMER_WIIU @SDL_TIMER_WIIU@
 
 /* Enable various video drivers */
 #cmakedefine SDL_VIDEO_DRIVER_ANDROID @SDL_VIDEO_DRIVER_ANDROID@
@@ -423,6 +427,7 @@
 #cmakedefine SDL_VIDEO_DRIVER_RISCOS @SDL_VIDEO_DRIVER_RISCOS@
 #cmakedefine SDL_VIDEO_DRIVER_PSP @SDL_VIDEO_DRIVER_PSP@
 #cmakedefine SDL_VIDEO_DRIVER_PS2 @SDL_VIDEO_DRIVER_PS2@
+#cmakedefine SDL_VIDEO_DRIVER_WIIU @SDL_VIDEO_DRIVER_WIIU@
 
 #cmakedefine SDL_VIDEO_DRIVER_KMSDRM @SDL_VIDEO_DRIVER_KMSDRM@
 #cmakedefine SDL_VIDEO_DRIVER_KMSDRM_DYNAMIC @SDL_VIDEO_DRIVER_KMSDRM_DYNAMIC@
@@ -467,6 +472,7 @@
 #cmakedefine SDL_VIDEO_RENDER_VITA_GXM @SDL_VIDEO_RENDER_VITA_GXM@
 #cmakedefine SDL_VIDEO_RENDER_PS2 @SDL_VIDEO_RENDER_PS2@
 #cmakedefine SDL_VIDEO_RENDER_PSP @SDL_VIDEO_RENDER_PSP@
+#cmakedefine SDL_VIDEO_RENDER_WIIU @SDL_VIDEO_RENDER_WIIU@
 
 /* Enable OpenGL support */
 #cmakedefine SDL_VIDEO_OPENGL @SDL_VIDEO_OPENGL@
diff --git a/include/SDL_config_wiiu.h b/include/SDL_config_wiiu.h
new file mode 100644
index 000000000..75be00578
--- /dev/null
+++ b/include/SDL_config_wiiu.h
@@ -0,0 +1,167 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2018 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#ifndef SDL_config_wiiu_h_
+#define SDL_config_wiiu_h_
+#define SDL_config_h_
+
+#include "SDL_platform.h"
+
+
+
+#ifdef __GNUC__
+#define HAVE_GCC_SYNC_LOCK_TEST_AND_SET 1
+#endif
+
+#define HAVE_GCC_ATOMICS    1
+
+#define STDC_HEADERS    1
+#define HAVE_ALLOCA_H       1
+#define HAVE_CTYPE_H    1
+#define HAVE_INTTYPES_H 1
+#define HAVE_LIMITS_H   1
+#define HAVE_MATH_H 1
+#define HAVE_SIGNAL_H   1
+#define HAVE_STDINT_H   1
+#define HAVE_STDIO_H    1
+#define HAVE_STRING_H   1
+#define HAVE_SYS_TYPES_H    1
+
+/* C library functions */
+#define HAVE_MALLOC 1
+#define HAVE_CALLOC 1
+#define HAVE_REALLOC    1
+#define HAVE_FREE   1
+#define HAVE_ALLOCA 1
+#define HAVE_GETENV 1
+#define HAVE_SETENV 1
+#define HAVE_PUTENV 1
+#define HAVE_SETENV 1
+#define HAVE_UNSETENV   1
+#define HAVE_QSORT  1
+#define HAVE_ABS    1
+#define HAVE_BCOPY  1
+#define HAVE_MEMSET 1
+#define HAVE_MEMCPY 1
+#define HAVE_MEMMOVE    1
+#define HAVE_MEMCMP 1
+#define HAVE_STRLEN 1
+#define HAVE_STRLCPY    1
+#define HAVE_STRLCAT    1
+#define HAVE_STRCHR 1
+#define HAVE_STRRCHR    1
+#define HAVE_STRSTR 1
+#define HAVE_STRTOL 1
+#define HAVE_STRTOUL    1
+#define HAVE_STRTOLL    1
+#define HAVE_STRTOULL   1
+#define HAVE_STRTOD 1
+#define HAVE_ATOI   1
+#define HAVE_ATOF   1
+#define HAVE_STRCMP 1
+#define HAVE_STRNCMP    1
+#define HAVE_STRCASECMP 1
+#define HAVE_STRNCASECMP 1
+#define HAVE_VSSCANF 1
+#define HAVE_VSNPRINTF  1
+#define HAVE_M_PI   1
+#define HAVE_ACOS   1
+#define HAVE_ACOSF  1
+#define HAVE_ASIN   1
+#define HAVE_ASINF  1
+#define HAVE_ATAN   1
+#define HAVE_ATANF  1
+#define HAVE_ATAN2  1
+#define HAVE_ATAN2F 1
+#define HAVE_CEIL   1
+#define HAVE_CEILF  1
+#define HAVE_COPYSIGN   1
+#define HAVE_COPYSIGNF  1
+#define HAVE_COS    1
+#define HAVE_COSF   1
+#define HAVE_EXP    1
+#define HAVE_FABS   1
+#define HAVE_FABSF  1
+#define HAVE_FLOOR  1
+#define HAVE_FLOORF 1
+#define HAVE_FMOD   1
+#define HAVE_FMODF  1
+#define HAVE_LOG    1
+#define HAVE_LOGF   1
+#define HAVE_LOG10  1
+#define HAVE_LOG10F 1
+#define HAVE_POW    1
+#define HAVE_POWF   1
+#define HAVE_SCALBN 1
+#define HAVE_SCALBNF    1
+#define HAVE_SIN    1
+#define HAVE_SINF   1
+#define HAVE_SQRT   1
+#define HAVE_SQRTF  1
+#define HAVE_TAN    1
+#define HAVE_TANF   1
+#define HAVE_SETJMP 1
+#define HAVE_NANOSLEEP  1
+/* #define HAVE_SYSCONF  1 */
+/* #define HAVE_SIGACTION    1 */
+
+
+/* Wii U isn't that sophisticated */
+#define LACKS_SYS_MMAN_H 1
+
+/* Wii U thread support (src/thread/wiiu/\*.c) */
+#define SDL_THREAD_WIIU        1
+#define SDL_THREADS_DISABLED   0
+
+/* Wii U timer support (src/timer/wiiu/\*.c) */
+#define SDL_TIMER_WIIU        1
+
+/* Wii U joystick driver (src/joystick/wiiu/\*.c) */
+#define SDL_JOYSTICK_WIIU      1
+
+/* Enable the wiiu audio driver (src/audio/wiiu/\*.c) */
+#define SDL_AUDIO_DRIVER_WIIU 1
+
+/* Wii U video dirver */
+#define SDL_VIDEO_DRIVER_WIIU  1
+
+/* Wii U render driver (src/render/wiiu/\*.c) */
+#define SDL_VIDEO_RENDER_WIIU 1
+
+/* There's no battery for the console unit */
+#define SDL_POWER_DISABLED     1
+
+/* !!! FIXME: what does Wii U do for filesystem stuff? */
+#define SDL_FILESYSTEM_DUMMY   1
+
+/* Wii U does have an haptic device, but it's not ported to sdl yet (src/haptic/dummy/\*.c) */
+#define SDL_HAPTIC_DISABLED    1
+
+/* Wii U can't load shared object (src/loadso/dummy/\*.c) */
+#define SDL_LOADSO_DISABLED    1
+
+/* Hack: for some reason some arch defines are missing in the
+   toolchain, so SDL_endian.h will think we're little endian
+   without that */
+#define SDL_BYTEORDER          SDL_BIG_ENDIAN
+
+
+#endif /* SDL_config_wiiu_h_ */
diff --git a/include/SDL_endian.h b/include/SDL_endian.h
index 71bc06729..94a790378 100644
--- a/include/SDL_endian.h
+++ b/include/SDL_endian.h
@@ -79,7 +79,7 @@ _m_prefetch(void *__P)
     defined(__m68k__) || defined(mc68000) || defined(_M_M68K) || \
     (defined(__MIPS__) && defined(__MIPSEB__)) || \
     defined(__ppc__) || defined(__POWERPC__) || defined(__powerpc__) || defined(__PPC__) || \
-    defined(__sparc__)
+    defined(__sparc__) || defined(_BIG_ENDIAN) || (__BIG_ENDIAN__ == 1)
 #define SDL_BYTEORDER   SDL_BIG_ENDIAN
 #else
 #define SDL_BYTEORDER   SDL_LIL_ENDIAN
diff --git a/include/SDL_platform.h b/include/SDL_platform.h
index d2a7e052d..262e1c37f 100644
--- a/include/SDL_platform.h
+++ b/include/SDL_platform.h
@@ -200,6 +200,10 @@
 #if defined(PS2)
 #define __PS2__ 1
 #endif
+#if defined(__WIIU__)
+#undef __WIIU__
+#define __WIIU__ 1
+#endif
 
 /* The NACL compiler defines __native_client__ and __pnacl__
  * Ref: http://www.chromium.org/nativeclient/pnacl/stability-of-the-pnacl-bitcode-abi
diff --git a/include/SDL_test_common.h b/include/SDL_test_common.h
index 6de63cad6..76c6c6c8d 100644
--- a/include/SDL_test_common.h
+++ b/include/SDL_test_common.h
@@ -40,6 +40,9 @@
 #elif defined(__VITA__)
 #define DEFAULT_WINDOW_WIDTH  960
 #define DEFAULT_WINDOW_HEIGHT 544
+#elif defined(__WIIU__)
+#define DEFAULT_WINDOW_WIDTH  1280
+#define DEFAULT_WINDOW_HEIGHT 720
 #else
 #define DEFAULT_WINDOW_WIDTH  640
 #define DEFAULT_WINDOW_HEIGHT 480
diff --git a/src/SDL.c b/src/SDL.c
index 56049adf0..66ab88ab1 100644
--- a/src/SDL.c
+++ b/src/SDL.c
@@ -610,6 +610,8 @@ const char *SDL_GetPlatform(void)
     return "Nokia N-Gage";
 #elif __3DS__
     return "Nintendo 3DS";
+#elif __WIIU__
+    return "Wii U";
 #else
     return "Unknown (see SDL_platform.h)";
 #endif
diff --git a/src/SDL_log.c b/src/SDL_log.c
index ab6e7c2cb..41461c96e 100644
--- a/src/SDL_log.c
+++ b/src/SDL_log.c
@@ -39,6 +39,10 @@
 #include <android/log.h>
 #endif
 
+#if defined(__WIIU__)
+#include <coreinit/debug.h>
+#endif
+
 #include "stdlib/SDL_vacopy.h"
 
 /* The size of the stack buffer to use for rendering log messages. */
@@ -449,6 +453,10 @@ static void SDLCALL SDL_LogOutput(void *userdata, int category, SDL_LogPriority
         SDL_NSLog(SDL_priority_prefixes[priority], message);
         return;
     }
+#elif defined(__WIIU__)
+    {
+        OSReport("SDL: %s: %s\n", SDL_priority_prefixes[priority], message);
+    }
 #elif defined(__PSP__) || defined(__PS2__)
     {
         FILE *pFile;
diff --git a/src/atomic/SDL_spinlock.c b/src/atomic/SDL_spinlock.c
index 9fd3e6167..420d49623 100644
--- a/src/atomic/SDL_spinlock.c
+++ b/src/atomic/SDL_spinlock.c
@@ -36,6 +36,10 @@
 #include <unixlib/local.h>
 #endif
 
+#if defined(__WIIU__)
+#include <stdatomic.h>
+#endif
+
 #if defined(_MSC_VER) && (defined(_M_IX86) || defined(_M_X64))
 #include <xmmintrin.h>
 #endif
@@ -163,6 +167,10 @@ SDL_bool SDL_AtomicTryLock(SDL_SpinLock *lock)
         EIntr();
     }
     return res;
+#elif defined(__WIIU__)
+    uint64_t val = 0;
+    return (SDL_bool) atomic_compare_exchange_strong((volatile _Atomic uint64_t*)lock, &val, 1);
+
 #else
 #error Please implement for your platform.
     return SDL_FALSE;
diff --git a/src/audio/SDL_audio.c b/src/audio/SDL_audio.c
index 60242e60a..936404d95 100644
--- a/src/audio/SDL_audio.c
+++ b/src/audio/SDL_audio.c
@@ -123,6 +123,9 @@ static const AudioBootStrap *const bootstrap[] = {
 #if SDL_AUDIO_DRIVER_OS2
     &OS2AUDIO_bootstrap,
 #endif
+#if SDL_AUDIO_DRIVER_WIIU
+    &WIIUAUDIO_bootstrap,
+#endif
 #if SDL_AUDIO_DRIVER_DISK
     &DISKAUDIO_bootstrap,
 #endif
diff --git a/src/audio/SDL_sysaudio.h b/src/audio/SDL_sysaudio.h
index c755d4341..052e2cd65 100644
--- a/src/audio/SDL_sysaudio.h
+++ b/src/audio/SDL_sysaudio.h
@@ -209,6 +209,7 @@ extern AudioBootStrap VITAAUD_bootstrap;
 extern AudioBootStrap N3DSAUDIO_bootstrap;
 extern AudioBootStrap EMSCRIPTENAUDIO_bootstrap;
 extern AudioBootStrap OS2AUDIO_bootstrap;
+extern AudioBootStrap WIIUAUDIO_bootstrap;
 
 #endif /* SDL_sysaudio_h_ */
 
diff --git a/src/audio/wiiu/SDL_wiiuaudio.c b/src/audio/wiiu/SDL_wiiuaudio.c
new file mode 100644
index 000000000..12a08857b
--- /dev/null
+++ b/src/audio/wiiu/SDL_wiiuaudio.c
@@ -0,0 +1,390 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 2018-2018 Ash Logan <ash@heyquark.com>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#if SDL_AUDIO_DRIVER_WIIU
+
+#include <stdio.h>
+
+#include "SDL_audio.h"
+#include "SDL_error.h"
+#include "SDL_timer.h"
+#include "../SDL_audio_c.h"
+#include "../SDL_audiodev_c.h"
+#include "../SDL_sysaudio.h"
+#include "SDL_wiiuaudio.h"
+#include "SDL_wiiuaudio_mix.h"
+
+#include <sndcore2/core.h>
+#include <sndcore2/voice.h>
+#include <sndcore2/drcvs.h>
+#include <coreinit/core.h>
+#include <coreinit/cache.h>
+#include <coreinit/thread.h>
+#include <coreinit/time.h>
+
+#define WIIUAUDIO_DRIVER_NAME "wiiu"
+
+#define AX_MAIN_AFFINITY OS_THREAD_ATTRIB_AFFINITY_CPU1
+
+static void _WIIUAUDIO_framecallback();
+static SDL_AudioDevice* cb_this;
+#define cb_hidden cb_this->hidden
+
+/*  Some helpers for AX-related math */
+/*  Absolute address to an AXVoiceOffsets offset */
+#define calc_ax_offset(offs, addr) (((void*)addr - offs.data) \
+    / sizeof_sample(offs))
+
+#define sizeof_sample(offs) (offs.dataType == AX_VOICE_FORMAT_LPCM8 ? 1 : 2)
+
+/*  +1, but never goes above NUM_BUFFERS */
+#define next_id(id) (id + 1) % NUM_BUFFERS
+
+static int WIIUAUDIO_OpenDevice(_THIS, void* handle, const char* devname, int iscapture) {
+    AXVoiceOffsets offs;
+    AXVoiceVeData vol = {
+        .volume = 0x8000,
+    };
+    uint32_t old_affinity;
+    float srcratio;
+
+    this->hidden = (struct SDL_PrivateAudioData*)SDL_malloc(sizeof(*this->hidden));
+    if (this->hidden == NULL) return SDL_OutOfMemory();
+    SDL_zerop(this->hidden);
+
+/*  We *must not* change cores when setting stuff up */
+    old_affinity = OSGetThreadAffinity(OSGetCurrentThread());
+    OSSetThreadAffinity(OSGetCurrentThread(), AX_MAIN_AFFINITY);
+
+/*  Take a quick aside to init the wiiu audio */
+    if (!AXIsInit()) {
+    /*  Init the AX audio engine */
+        AXInitParams initparams = {
+            .renderer = AX_INIT_RENDERER_48KHZ,
+            .pipeline = AX_INIT_PIPELINE_SINGLE,
+        };
+        AXInitWithParams(&initparams);
+    } else printf("DEBUG: AX already up?\n");
+
+    if (this->spec.channels < 1) this->spec.channels = 1;
+    if (this->spec.channels > WIIU_MAX_VALID_CHANNELS)
+        this->spec.channels = WIIU_MAX_VALID_CHANNELS;
+
+/*  Force wiiu-compatible audio formats.
+    TODO verify - unsigned or signed? */
+    switch (SDL_AUDIO_BITSIZE(this->spec.format)) {
+        case 8:
+        /*  TODO 8-bit audio sounds broken */
+            /*this->spec.format = AUDIO_S8;
+            break;*/
+        case 16:
+        default:
+            this->spec.format = AUDIO_S16MSB;
+            break;
+    }
+
+    //TODO maybe round this->spec.samples up even when >?
+    //maybe even force at least 2* so we get more frame callbacks to think
+    if (this->spec.samples < AXGetInputSamplesPerFrame()) {
+        this->spec.samples = AXGetInputSamplesPerFrame();
+    }
+
+/*  We changed channels and samples, so recalculate the spec */
+    SDL_CalculateAudioSpec(&this->spec);
+
+/*  Allocate buffers for double-buffering and samples */
+    for (int i = 0; i < NUM_BUFFERS; i++) {
+        this->hidden->mixbufs[i] = SDL_malloc(this->spec.size);
+        if (this->hidden->mixbufs[i] == NULL) {
+            AXQuit();
+            printf("DEBUG: Couldn't allocate buffer");
+            return SDL_SetError("Couldn't allocate buffer");
+        }
+
+        memset(this->hidden->mixbufs[i], 0, this->spec.size);
+        DCStoreRange(this->hidden->mixbufs[i], this->spec.size);
+    }
+
+/*  Allocate a scratch buffer for deinterleaving operations */
+    this->hidden->deintvbuf = SDL_malloc(this->spec.size);
+    if (this->hidden->deintvbuf == NULL) {
+        AXQuit();
+        printf("DEBUG: Couldn't allocate deinterleave buffer");
+        return SDL_SetError("Couldn't allocate deinterleave buffer");
+    }
+
+
+    for (int i = 0; i < this->spec.channels; i++) {
+    /*  Get a voice, top priority */
+        this->hidden->voice[i] = AXAcquireVoice(31, NULL, NULL);
+        if (!this->hidden->voice[i]) {
+            AXQuit();
+            printf("DEBUG: couldn't get voice\n");
+            return SDL_OutOfMemory();
+        }
+
+    /*  Start messing with it */
+        AXVoiceBegin(this->hidden->voice[i]);
+        AXSetVoiceType(this->hidden->voice[i], 0);
+
+    /*  Set the voice's volume. */
+        AXSetVoiceVe(this->hidden->voice[i], &vol);
+        switch (this->spec.channels) {
+            case 1: /* mono */ {
+                AXSetVoiceDeviceMix(this->hidden->voice[i],
+                    AX_DEVICE_TYPE_DRC, 0, mono_mix[i]);
+                AXSetVoiceDeviceMix(this->hidden->voice[i],
+                    AX_DEVICE_TYPE_TV, 0, mono_mix[i]);
+            } break;
+            case 2: /* stereo */ {
+                AXSetVoiceDeviceMix(this->hidden->voice[i],
+                    AX_DEVICE_TYPE_DRC, 0, stereo_mix[i]);
+                AXSetVoiceDeviceMix(this->hidden->voice[i],
+                    AX_DEVICE_TYPE_TV, 0, stereo_mix[i]);
+            } break;
+        }
+
+    /*  Set the samplerate conversion ratio
+        <source sample rate> / <target sample rate> */
+        srcratio = (float)this->spec.freq / (float)AXGetInputSamplesPerSec();
+        AXSetVoiceSrcRatio(this->hidden->voice[i], srcratio);
+        AXSetVoiceSrcType(this->hidden->voice[i], AX_VOICE_SRC_TYPE_LINEAR);
+
+    /*  Set up the offsets for the first mixbuf */
+        switch (SDL_AUDIO_BITSIZE(this->spec.format)) {
+            case 8:
+                offs.dataType = AX_VOICE_FORMAT_LPCM8;
+                offs.endOffset = this->spec.samples;
+                break;
+            case 16:
+            default:
+                offs.dataType = AX_VOICE_FORMAT_LPCM16;
+                offs.endOffset = this->spec.samples;
+                break;
+        }
+        offs.loopingEnabled = AX_VOICE_LOOP_ENABLED;
+        offs.loopOffset = 0;
+        offs.currentOffset = 0;
+
+        if (offs.dataType == AX_VOICE_FORMAT_LPCM8) {
+            offs.data = this->hidden->mixbufs[0]
+                + this->spec.samples * i * sizeof(Uint8);
+        } else if (offs.dataType == AX_VOICE_FORMAT_LPCM16) {
+            offs.data = this->hidden->mixbufs[0]
+                + this->spec.samples * i * sizeof(Uint16);
+        }
+        AXSetVoiceOffsets(this->hidden->voice[i], &offs);
+
+    /*  Set the last good loopcount */
+        this->hidden->last_loopcount = AXGetVoiceLoopCount(this->hidden->voice[i]);
+
+    /*  Offsets are set for playing the first mixbuf, so we should render the second */
+        this->hidden->playingid = 0;
+        this->hidden->renderingid = 1;
+
+    /*  Start playing. */
+        AXSetVoiceState(this->hidden->voice[i], AX_VOICE_STATE_PLAYING);
+
+    /*  Okay, we're good */
+        AXVoiceEnd(this->hidden->voice[i]);
+    }
+
+    cb_this = this; //wish there was a better way
+    AXRegisterAppFrameCallback(_WIIUAUDIO_framecallback);
+
+/*  Put the thread affinity back to normal - we won't call any more AX funcs */
+    OSSetThreadAffinity(OSGetCurrentThread(), old_affinity);
+    return 0;
+}
+
+/*  Called every 3ms before a frame of audio is rendered. Keep it fast! */
+static void _WIIUAUDIO_framecallback() {
+    int playing_buffer = -1;
+    AXVoiceOffsets offs[6];
+    void* endaddr;
+
+    for (int i = 0; i < cb_this->spec.channels; i++) {
+        AXGetVoiceOffsets(cb_hidden->voice[i], &offs[i]);
+    }
+
+/*  Figure out which buffer is being played by the hardware */
+    for (int i = 0; i < NUM_BUFFERS; i++) {
+        void* buf = cb_hidden->mixbufs[i];
+        uint32_t startOffset = calc_ax_offset(offs[0], buf);
+        uint32_t endOffset = startOffset + cb_this->spec.samples;
+
+    /*  NOTE endOffset definitely needs to be <= (AX plays the sample at
+        endOffset), dunno about startOffset */
+        if (offs[0].currentOffset >= startOffset &&
+            offs[0].currentOffset <= endOffset) {
+            playing_buffer = i;
+            break;
+        }
+    }
+
+    if (playing_buffer < 0 || playing_buffer >= NUM_BUFFERS) {
+    /*  UM */
+    /*  Uncomment for craploads of debug info */
+        /*printf("bad buffer %d\n" "|> %08X, %08X-%08X\n" \
+            "0: xxxxxxxx, %08X-%08X (%08X@%08X)\n" \
+            "1: xxxxxxxx, %08X-%08X (%08X@%08X)\n", \
+            playing_buffer, offs.currentOffset, offs.loopOffset, offs.endOffset,
+            calc_ax_offset(offs, (void*)cb_hidden->mixbufs[0]),
+                calc_ax_offset(offs, (void*)cb_hidden->mixbufs[0] + cb_this->spec.size),
+                cb_this->spec.size, (void*)cb_hidden->mixbufs[0],
+            calc_ax_offset(offs, (void*)cb_hidden->mixbufs[1]),
+                calc_ax_offset(offs, (void*)cb_hidden->mixbufs[1] + cb_this->spec.size),
+                cb_this->spec.size, (void*)cb_hidden->mixbufs[1]);*/
+        printf("DEBUG: Playing an invalid buffer? This is not a good sign.\n");
+        playing_buffer = 0;
+    }
+
+/*  Make sure playingid is in sync with the hardware */
+    cb_hidden->playingid = playing_buffer;
+
+/*  Make sure the end offset is correct for the playing buffer */
+    for (int i = 0; i < cb_this->spec.channels; i++) {
+    /*  Calculate end address, aka start of the next (i+1) channel's buffer */
+        endaddr = cb_hidden->mixbufs[cb_hidden->playingid] +
+            (cb_this->spec.samples * sizeof_sample(offs[i]) * (i + 1));
+
+    /*  Trial end error to try and limit popping */
+        endaddr -= 2;
+
+        AXSetVoiceEndOffset(
+            cb_hidden->voice[i],
+            calc_ax_offset(offs[i], endaddr)
+        );
+
+    /*  The next buffer is good to go, set the loop offset */
+        if (cb_hidden->renderingid != next_id(cb_hidden->playingid)) {
+        /*  Calculate start address for this channel's buffer */
+            void* loopaddr = cb_hidden->mixbufs[next_id(cb_hidden->playingid)] +
+                (cb_this->spec.samples * sizeof_sample(offs[i]) * i);
+
+            AXSetVoiceLoopOffset(cb_hidden->voice[i], calc_ax_offset(offs[i], loopaddr));
+    /*  Otherwise, make sure the loop offset is correct for the playing buffer */
+        } else {
+            void* loopaddr = cb_hidden->mixbufs[cb_hidden->playingid] +
+                (cb_this->spec.samples * sizeof_sample(offs[i]) * i);
+
+            AXSetVoiceLoopOffset(cb_hidden->voice[i], calc_ax_offset(offs[i], loopaddr));
+        }
+    }
+}
+
+static void WIIUAUDIO_PlayDevice(_THIS) {
+/*  Deinterleave stereo audio */
+    switch (SDL_AUDIO_BITSIZE(this->spec.format)) {
+        case 8: {
+            Uint8* samples = (Uint8*)this->hidden->mixbufs[this->hidden->renderingid];
+            Uint8* deintv = (Uint8*)this->hidden->deintvbuf;
+
+            /* Store the samples in a separate deinterleaved buffer */
+            for (int ch = 0; ch < this->spec.channels; ch++) {
+                for (int i = 0; i < this->spec.samples; i++) {
+                    deintv[this->spec.samples * ch + i] = samples[i * this->spec.channels + ch];
+                }
+            }
+        } break;
+        case 16: {
+            Uint16* samples = (Uint16*)this->hidden->mixbufs[this->hidden->renderingid];
+            Uint16* deintv = (Uint16*)this->hidden->deintvbuf;
+
+            /* Store the samples in a separate deinterleaved buffer */
+            for (int ch = 0; ch < this->spec.channels; ch++) {
+                for (int i = 0; i < this->spec.samples; i++) {
+                    deintv[this->spec.samples * ch + i] = samples[i * this->spec.channels + ch];
+                }
+            }
+        } break;
+        default: {} break;
+    }
+
+/*  Copy the deinterleaved buffer to the mixing buffer */
+    memcpy(
+        this->hidden->mixbufs[this->hidden->renderingid],
+        this->hidden->deintvbuf,
+        this->spec.size
+    );
+/*  Comment this out for broken-record mode ;3 */
+    DCStoreRange(this->hidden->mixbufs[this->hidden->renderingid], this->spec.size);
+/*  Signal we're no longer rendering this buffer, AX callback will notice later */
+    this->hidden->renderingid = next_id(this->hidden->renderingid);
+}
+
+static void WIIUAUDIO_WaitDevice(_THIS) {
+/*  TODO use real thread sync stuff */
+    while (SDL_AtomicGet(&this->enabled) && this->hidden->renderingid == this->hidden->playingid) {
+        OSSleepTicks(OSMillisecondsToTicks(3));
+    }
+}
+
+static Uint8* WIIUAUDIO_GetDeviceBuf(_THIS) {
+/*  SDL will write audio samples into this buffer */
+    return this->hidden->mixbufs[this->hidden->renderingid];
+}
+
+static void WIIUAUDIO_CloseDevice(_THIS) {
+    if (AXIsInit()) {
+        AXDeregisterAppFrameCallback(_WIIUAUDIO_framecallback);
+        for (int i = 0; i < SIZEOF_ARR(this->hidden->voice); i++) {
+            if (this->hidden->voice[i]) {
+                AXFreeVoice(this->hidden->voice[i]);
+                this->hidden->voice[i] = NULL;
+            }
+        }
+        AXQuit();
+    }
+    for (int i = 0; i < NUM_BUFFERS; i++) {
+        if (this->hidden->mixbufs[i]) SDL_free(this->hidden->mixbufs[i]);
+    }
+    if (this->hidden->deintvbuf) SDL_free(this->hidden->deintvbuf);
+    SDL_free(this->hidden);
+}
+
+static void WIIUAUDIO_ThreadInit(_THIS) {
+/*  Bump our thread's priority a bit */
+    OSThread* currentThread = OSGetCurrentThread();
+    int32_t priority = OSGetThreadPriority(currentThread);
+    priority -= 1;
+    OSSetThreadPriority(currentThread, priority);
+}
+
+static int WIIUAUDIO_Init(SDL_AudioDriverImpl* impl) {
+    impl->OpenDevice = WIIUAUDIO_OpenDevice;
+    impl->PlayDevice = WIIUAUDIO_PlayDevice;
+    impl->WaitDevice = WIIUAUDIO_WaitDevice;
+    impl->GetDeviceBuf = WIIUAUDIO_GetDeviceBuf;
+    impl->CloseDevice = WIIUAUDIO_CloseDevice;
+    impl->ThreadInit = WIIUAUDIO_ThreadInit;
+
+    impl->OnlyHasDefaultOutputDevice = 1;
+
+    return 1;
+}
+
+AudioBootStrap WIIUAUDIO_bootstrap = {
+    WIIUAUDIO_DRIVER_NAME, "Wii U AX Audio Driver", WIIUAUDIO_Init, 0,
+};
+
+#endif //SDL_AUDIO_DRIVER_WIIU
diff --git a/src/audio/wiiu/SDL_wiiuaudio.h b/src/audio/wiiu/SDL_wiiuaudio.h
new file mode 100644
index 000000000..41cb4a48b
--- /dev/null
+++ b/src/audio/wiiu/SDL_wiiuaudio.h
@@ -0,0 +1,51 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2018 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#ifndef SDL_wiiuaudio_h_
+#define SDL_wiiuaudio_h_
+
+#include "../SDL_sysaudio.h"
+
+#include <sndcore2/voice.h>
+
+/* Hidden "this" pointer for the audio functions */
+#define _THIS   SDL_AudioDevice *this
+
+#define NUM_BUFFERS 2
+
+#define SIZEOF_ARR(arr) (sizeof(arr) / sizeof(arr[0]))
+
+struct SDL_PrivateAudioData {
+    /* 6 possible voices for 6 channels */
+    AXVoice* voice[6];
+    /* The raw allocated mixing buffer. */
+    Uint8   *rawbuf;
+    /* Individual mixing buffers. */
+    Uint8   *mixbufs[NUM_BUFFERS];
+    /* Deinterleaving buffer. */
+    Uint8   *deintvbuf;
+
+    int renderingid;
+    int playingid;
+    uint32_t last_loopcount;
+};
+
+#endif /* SDL_wiiuaudio_h_ */
diff --git a/src/audio/wiiu/SDL_wiiuaudio_mix.h b/src/audio/wiiu/SDL_wiiuaudio_mix.h
new file mode 100644
index 000000000..57b661c89
--- /dev/null
+++ b/src/audio/wiiu/SDL_wiiuaudio_mix.h
@@ -0,0 +1,65 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2018 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#ifndef SDL_wiiuaudio_mix_h_
+#define SDL_wiiuaudio_mix_h_
+
+/* Some defines to help make the code below more readable */
+#define AX_VOICE(x) x
+#define AX_CHANNEL_LEFT 0
+#define AX_CHANNEL_RIGHT 1
+#define AX_BUS_MASTER 0
+
+/* TODO: AXGetDeviceChannelCount. For now we'll use Decaf's values.
+ * According to Decaf, the TV has 6 channels and the gamepad has 4. We set up
+ * both arrays with 6, the Gamepad callbacks just won't use the whole buffer. */
+#define AX_NUM_CHANNELS 6
+
+static AXVoiceDeviceMixData stereo_mix[2 /* voices */][AX_NUM_CHANNELS] = {
+    [AX_VOICE(0)] = {
+        [AX_CHANNEL_LEFT] = {
+            .bus = {
+                [AX_BUS_MASTER] = { .volume = 0x8000 },
+            }
+        },
+    },
+    [AX_VOICE(1)] = {
+        [AX_CHANNEL_RIGHT] = {
+            .bus = {
+                [AX_BUS_MASTER] = { .volume = 0x8000 },
+            }
+        },
+    },
+};
+static AXVoiceDeviceMixData mono_mix[1 /* voice */][AX_NUM_CHANNELS] = {
+    [AX_VOICE(0)] = {
+        [AX_CHANNEL_LEFT] = { .bus = {
+            [AX_BUS_MASTER] = { .volume = 0x8000 },
+        }},
+        [AX_CHANNEL_RIGHT] = { .bus = {
+            [AX_BUS_MASTER] = { .volume = 0x8000 },
+        }},
+    },
+};
+
+#define WIIU_MAX_VALID_CHANNELS 2
+
+#endif //SDL_wiiuaudio_mix_h_
diff --git a/src/dynapi/SDL_dynapi.h b/src/dynapi/SDL_dynapi.h
index 99ca08008..d684b5fed 100644
--- a/src/dynapi/SDL_dynapi.h
+++ b/src/dynapi/SDL_dynapi.h
@@ -59,6 +59,8 @@
 #define SDL_DYNAMIC_API 0
 #elif defined(__riscos__) && __riscos__ /* probably not useful on RISC OS, since dlopen() can't be used when using static linking. */
 #define SDL_DYNAMIC_API 0
+#elif defined(__WIIU__) && __WIIU__
+#define SDL_DYNAMIC_API 0
 #elif defined(__clang_analyzer__) || defined(SDL_THREAD_SAFETY_ANALYSIS)
 #define SDL_DYNAMIC_API 0 /* Turn off for static analysis, so reports are more clear. */
 #elif defined(__VITA__)
diff --git a/src/joystick/SDL_gamecontrollerdb.h b/src/joystick/SDL_gamecontrollerdb.h
index f926c1612..bb38d0455 100644
--- a/src/joystick/SDL_gamecontrollerdb.h
+++ b/src/joystick/SDL_gamecontrollerdb.h
@@ -991,6 +991,9 @@ static const char *s_ControllerMappings[] = {
 #endif
 #if SDL_JOYSTICK_N3DS
     "000000004e696e74656e646f20334400,Nintendo 3DS,crc:3210,a:b0,b:b1,back:b2,dpdown:b7,dpleft:b5,dpright:b4,dpup:b6,leftshoulder:b9,lefttrigger:b14,leftx:a0,lefty:a1,rightshoulder:b8,righttrigger:b15,rightx:a2,righty:a3,start:b3,x:b10,y:b11,",
+#endif
+#if defined(SDL_JOYSTICK_WIIU)
+    "576969552047616d6570616400000000,Wii U Gamepad,a:b1,b:b0,back:b11,dpdown:b15,dpleft:b12,dpright:b14,dpup:b13,leftshoulder:b6,leftstick:b4,lefttrigger:b8,leftx:a0,lefty:a1,rightshoulder:b7,rightstick:b5,righttrigger:b9,rightx:a2,righty:a3,start:b10,x:b3,y:b2,",
 #endif
     "hidapi,*,a:b0,b:b1,back:b4,dpdown:b12,dpleft:b13,dpright:b14,dpup:b11,guide:b5,leftshoulder:b9,leftstick:b7,lefttrigger:a4,leftx:a0,lefty:a1,rightshoulder:b10,rightstick:b8,righttrigger:a5,rightx:a2,righty:a3,start:b6,x:b2,y:b3,",
     NULL
diff --git a/src/joystick/SDL_joystick.c b/src/joystick/SDL_joystick.c
index 834e83d99..2bc162aee 100644
--- a/src/joystick/SDL_joystick.c
+++ b/src/joystick/SDL_joystick.c
@@ -84,7 +84,10 @@ static SDL_JoystickDriver *SDL_joystick_drivers[] = {
 #ifdef SDL_JOYSTICK_HAIKU
     &SDL_HAIKU_JoystickDriver,
 #endif
-#ifdef SDL_JOYSTICK_USBHID /* !!! FIXME: "USBHID" is a generic name, and doubly-confusing with HIDAPI next to it. This is the *BSD interface, rename this. */
+#ifdef SDL_JOYSTICK_WIIU
+    &SDL_WIIU_JoystickDriver,
+#endif
+#ifdef SDL_JOYSTICK_USBHID  /* !!! FIXME: "USBHID" is a generic name, and doubly-confusing with HIDAPI next to it. This is the *BSD interface, rename this. */
     &SDL_BSD_JoystickDriver,
 #endif
 #ifdef SDL_JOYSTICK_OS2
diff --git a/src/joystick/SDL_sysjoystick.h b/src/joystick/SDL_sysjoystick.h
index a93fa662c..4f0c0df77 100644
--- a/src/joystick/SDL_sysjoystick.h
+++ b/src/joystick/SDL_sysjoystick.h
@@ -249,6 +249,7 @@ extern SDL_JoystickDriver SDL_PS2_JoystickDriver;
 extern SDL_JoystickDriver SDL_PSP_JoystickDriver;
 extern SDL_JoystickDriver SDL_VITA_JoystickDriver;
 extern SDL_JoystickDriver SDL_N3DS_JoystickDriver;
+extern SDL_JoystickDriver SDL_WIIU_JoystickDriver;
 
 /* Ends C function definitions when using C++ */
 #ifdef __cplusplus
diff --git a/src/joystick/wiiu/SDL_wiiujoystick.c b/src/joystick/wiiu/SDL_wiiujoystick.c
new file mode 100644
index 000000000..d345b24e7
--- /dev/null
+++ b/src/joystick/wiiu/SDL_wiiujoystick.c
@@ -0,0 +1,531 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 2018 Roberto Van Eeden <r.r.qwertyuiop.r.r@gmail.com>
+  Copyright (C) 2019 Ash Logan <ash@heyquark.com>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+	 claim that you wrote the original software. If you use this software
+	 in a product, an acknowledgment in the product documentation would be
+	 appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+	 misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#include "../../SDL_internal.h"
+
+#if SDL_JOYSTICK_WIIU
+
+#include <vpad/input.h>
+#include <padscore/wpad.h>
+#include <padscore/kpad.h>
+#include <coreinit/debug.h>
+
+#include "SDL_joystick.h"
+#include "../SDL_sysjoystick.h"
+#include "../SDL_joystick_c.h"
+#include "../../events/SDL_touch_c.h"
+
+#include "SDL_log.h"
+#include "SDL_assert.h"
+#include "SDL_events.h"
+
+#include "SDL_wiiujoystick.h"
+
+//index with device_index, get WIIU_DEVICE*
+static int deviceMap[MAX_CONTROLLERS];
+//index with device_index, get SDL_JoystickID
+static SDL_JoystickID instanceMap[MAX_CONTROLLERS];
+static WPADExtensionType lastKnownExts[WIIU_NUM_WPADS];
+
+static int WIIU_GetDeviceForIndex(int device_index) {
+	return deviceMap[device_index];
+}
+static int WIIU_GetIndexForDevice(int wiiu_device) {
+	for (int i = 0; i < MAX_CONTROLLERS; i++) {
+		if (deviceMap[i] == wiiu_device) return i;
+	}
+	return -1;
+}
+
+static int WIIU_GetNextDeviceIndex() {
+	return WIIU_GetIndexForDevice(WIIU_DEVICE_INVALID);
+}
+
+static SDL_JoystickID WIIU_GetInstForIndex(int device_index) {
+	if (device_index == -1) return -1;
+	return instanceMap[device_index];
+}
+static SDL_JoystickID WIIU_GetInstForDevice(int wiiu_device) {
+	int device_index = WIIU_GetIndexForDevice(wiiu_device);
+	return WIIU_GetInstForIndex(device_index);
+}
+static int WIIU_GetDeviceForInst(SDL_JoystickID instance) {
+	for (int i = 0; i < MAX_CONTROLLERS; i++) {
+		if (instanceMap[i] == instance) return deviceMap[i];
+	}
+	return WIIU_DEVICE_INVALID;
+}
+
+static void WIIU_RemoveDevice(int wiiu_device) {
+	int device_index = WIIU_GetIndexForDevice(wiiu_device);
+	if (device_index == -1) return;
+	/* Move all the other controllers back, so all device_indexes are valid */
+	for (int i = device_index; i < MAX_CONTROLLERS; i++) {
+		if (i + 1 < MAX_CONTROLLERS) {
+			deviceMap[i] = deviceMap[i + 1];
+			instanceMap[i] = instanceMap[i + 1];
+		} else {
+			deviceMap[i] = -1;
+			instanceMap[i] = -1;
+		}
+	}
+}
+
+/* Function to scan the system for joysticks.
+ * Joystick 0 should be the system default joystick.
+ * This function should return 0, or -1 on an unrecoverable error.
+ */
+static int WIIU_JoystickInit(void)
+{
+	VPADInit();
+	KPADInit();
+	WPADEnableURCC(1);
+
+	for (int i = 0; i < MAX_CONTROLLERS; i++) {
+		deviceMap[i] = WIIU_DEVICE_INVALID;
+		instanceMap[i] = -1;
+	}
+	WIIU_JoystickDetect();
+	return 0;
+}
+
+/* Function to return the number of joystick devices plugged in right now */
+static int WIIU_JoystickGetCount(void)
+{
+	return WIIU_GetNextDeviceIndex();
+}
+
+/* Function to cause any queued joystick insertions to be processed */
+static void WIIU_JoystickDetect(void)
+{
+/*	Make sure there are no dangling instances or device indexes
+ 	These checks *should* be unneccesary, remove once battle-tested */
+	for (int i = 0; i < MAX_CONTROLLERS; i++) {
+		if (deviceMap[i] == WIIU_DEVICE_INVALID && instanceMap[i] != -1) {
+
+			SDL_LogWarn(SDL_LOG_CATEGORY_INPUT,
+				"WiiU device_index %d dangling instance %d!\n",
+				i, instanceMap[i]
+			);
+			/* Make sure that joystick actually got removed */
+			SDL_PrivateJoystickRemoved(instanceMap[i]);
+			instanceMap[i] = -1;
+		}
+		if (deviceMap[i] != WIIU_DEVICE_INVALID && instanceMap[i] == -1) {
+			SDL_LogWarn(SDL_LOG_CATEGORY_INPUT,
+				"WiiU device_index %d assigned to %d, but has no instance!\n",
+				i, deviceMap[i]
+			);
+			instanceMap[i] = -1;
+		}
+	}
+/*	Check if we are missing the WiiU Gamepad and try to connect it
+	if the gamepad is disconnected that's handled in SDL_UpdateJoystick */
+	if (WIIU_GetIndexForDevice(WIIU_DEVICE_GAMEPAD) == -1) {
+	/*	Try and detect a gamepad */
+		VPADStatus status;
+		VPADReadError err;
+		VPADRead(VPAD_CHAN_0, &status, 1, &err);
+		if (err == VPAD_READ_SUCCESS || err == VPAD_READ_NO_SAMPLES) {
+		/*	We have a gamepad! Assign a device index and instance ID. */
+			int device_index = WIIU_GetNextDeviceIndex();
+			if (device_index != -1) {
+			/*	Save its device index */
+				deviceMap[device_index] = WIIU_DEVICE_GAMEPAD;
+				instanceMap[device_index] = SDL_GetNextJoystickInstanceID();
+				SDL_PrivateJoystickAdded(instanceMap[device_index]);
+				SDL_LogInfo(SDL_LOG_CATEGORY_INPUT,
+					"WiiU: Detected Gamepad, assigned device %d/instance %d\n",
+					device_index, instanceMap[device_index]);
+			}
+		}
+	}
+	/* Check for WPAD/KPAD controllers */
+	for (int i = 0; i < WIIU_NUM_WPADS; i++) {
+		WPADExtensionType ext;
+		int wiiu_device = WIIU_DEVICE_WPAD(i);
+		int ret = WPADProbe(WIIU_WPAD_CHAN(wiiu_device), &ext);
+		if (ret == 0) { //controller connected
+			/* Is this already connected? */
+			if (WIIU_GetIndexForDevice(wiiu_device) == -1) {
+				/* No! Let's add it. */
+				int device_index = WIIU_GetNextDeviceIndex();
+				if (device_index != -1) {
+				/*	Save its device index */
+					deviceMap[device_index] = WIIU_DEVICE_WPAD(i);
+					instanceMap[device_index] = SDL_GetNextJoystickInstanceID();
+				/*	Save its extension controller */
+					lastKnownExts[WIIU_WPAD_CHAN(wiiu_device)] = ext;
+					SDL_PrivateJoystickAdded(instanceMap[device_index]);
+					SDL_LogInfo(SDL_LOG_CATEGORY_INPUT,
+						"WiiU: Detected WPAD, assigned device %d/instance %d\n",
+						device_index, instanceMap[device_index]);
+				}
+			} else if (ext != lastKnownExts[WIIU_WPAD_CHAN(wiiu_device)]) {
+				/* If this controller has changed extensions, we should
+				disconnect and reconnect it. */
+				SDL_JoystickID instance = WIIU_GetInstForDevice(wiiu_device);
+				/* Yes! We should disconnect it. */
+				SDL_PrivateJoystickRemoved(instance);
+				/* Unlink device_index, instance_id */
+				WIIU_RemoveDevice(wiiu_device);
+			}
+		} else if (ret == -1) { //no controller
+			/* Is this controller connected? */
+			if (WIIU_GetIndexForDevice(wiiu_device) != -1) {
+				SDL_JoystickID instance = WIIU_GetInstForDevice(wiiu_device);
+				/* Yes! We should disconnect it. */
+				SDL_PrivateJoystickRemoved(instance);
+				/* Unlink device_index, instance_id */
+				WIIU_RemoveDevice(wiiu_device);
+			}
+		} // otherwise do nothing (-2: pairing)
+	}
+}
+
+/* Function to get the device-dependent name of a joystick */
+static const char *WIIU_JoystickGetDeviceName(int device_index)
+{
+	int wiiu_device = WIIU_GetDeviceForIndex(device_index);
+	/* Gamepad */
+	if (wiiu_device == WIIU_DEVICE_GAMEPAD) {
+		return "WiiU Gamepad";
+	} else if (wiiu_device == WIIU_DEVICE_WPAD(0)) {
+		RETURN_WPAD_NAME(1, lastKnownExts[0]);
+	} else if (wiiu_device == WIIU_DEVICE_WPAD(1)) {
+		RETURN_WPAD_NAME(2, lastKnownExts[1]);
+	} else if (wiiu_device == WIIU_DEVICE_WPAD(2)) {
+		RETURN_WPAD_NAME(3, lastKnownExts[2]);
+	} else if (wiiu_device == WIIU_DEVICE_WPAD(3)) {
+		RETURN_WPAD_NAME(4, lastKnownExts[3]);
+	}
+
+	return "Unknown";
+}
+
+/* Function to get the player index of a joystick */
+static int WIIU_JoystickGetDevicePlayerIndex(int device_index)
+{
+	int wiiu_device = WIIU_GetDeviceForIndex(device_index);
+	switch (wiiu_device) {
+		case WIIU_DEVICE_GAMEPAD: { return 0; }
+		case WIIU_DEVICE_WPAD(1): { return 1; }
+		case WIIU_DEVICE_WPAD(2): { return 2; }
+		case WIIU_DEVICE_WPAD(3): { return 3; }
+		case WIIU_DEVICE_WPAD(4): { return 4; }
+		default: { return -1; }
+	}
+
+}
+
+/* Function to return the stable GUID for a plugged in device */
+static SDL_JoystickGUID WIIU_JoystickGetDeviceGUID(int device_index)
+{
+	SDL_JoystickGUID guid;
+	/* the GUID is just the first 16 chars of the name for now */
+	const char *name = WIIU_JoystickGetDeviceName(device_index);
+	SDL_zero(guid);
+	SDL_memcpy(&guid, name, SDL_min(sizeof(guid), SDL_strlen(name)));
+	return guid;
+}
+
+/* Function to get the current instance id of the joystick located at device_index */
+static SDL_JoystickID WIIU_JoystickGetDeviceInstanceID(int device_index)
+{
+	return WIIU_GetInstForIndex(device_index);
+}
+
+/* Function to open a joystick for use.
+   The joystick to open is specified by the device index.
+   This should fill the nbuttons and naxes fields of the joystick structure.
+   It returns 0, or -1 if there is an error.
+ */
+static int WIIU_JoystickOpen(SDL_Joystick *joystick, int device_index)
+{
+	int wiiu_device = WIIU_GetDeviceForIndex(device_index);
+	switch (wiiu_device) {
+		case WIIU_DEVICE_GAMEPAD: {
+			SDL_AddTouch(0, "WiiU Gamepad Touchscreen");
+			joystick->nbuttons = SIZEOF_ARR(vpad_button_map);
+			joystick->naxes = 4;
+			joystick->nhats = 0;
+
+			break;
+		}
+		case WIIU_DEVICE_WPAD(0):
+		case WIIU_DEVICE_WPAD(1):
+		case WIIU_DEVICE_WPAD(2):
+		case WIIU_DEVICE_WPAD(3): {
+			WPADExtensionType ext;
+			int ret = WPADProbe(WIIU_WPAD_CHAN(wiiu_device), &ext);
+			if (ret != 0) {
+				SDL_LogWarn(SDL_LOG_CATEGORY_INPUT,
+					"WiiU_JoystickOpen: WPAD device %d failed probe!",
+					WIIU_WPAD_CHAN(wiiu_device));
+				return -1;
+			}
+
+			switch (ext) {
+				case WPAD_EXT_CORE:
+				case WPAD_EXT_MPLUS:
+				default: {
+					joystick->nbuttons = SIZEOF_ARR(wiimote_button_map);
+					joystick->naxes = 0;
+					joystick->nhats = 0;
+					break;
+				}
+				case WPAD_EXT_NUNCHUK:
+				case WPAD_EXT_MPLUS_NUNCHUK: {
+					joystick->nbuttons = SIZEOF_ARR(wiimote_button_map);
+					joystick->naxes = 2;
+					joystick->nhats = 0;
+					break;
+				}
+				case WPAD_EXT_CLASSIC:
+				case WPAD_EXT_MPLUS_CLASSIC: {
+					joystick->nbuttons = SIZEOF_ARR(classic_button_map);
+					joystick->naxes = 4;
+					joystick->nhats = 0;
+					break;
+				}
+				case WPAD_EXT_PRO_CONTROLLER: {
+					joystick->nbuttons = SIZEOF_ARR(pro_button_map);
+					joystick->naxes = 4;
+					joystick->nhats = 0;
+					break;
+				}
+			}
+			break;
+		}
+	}
+
+	joystick->instance_id = WIIU_GetInstForIndex(device_index);
+	return 0;
+}
+
+/* Rumble functionality */
+static int WIIU_JoystickRumble(SDL_Joystick * joystick, Uint16 low_frequency_rumble, Uint16 high_frequency_rumble, Uint32 duration_ms)
+{
+	/* TODO */
+	return SDL_Unsupported();
+}
+
+/* Function to update the state of a joystick - called as a device poll.
+ * This function shouldn't update the joystick structure directly,
+ * but instead should call SDL_PrivateJoystick*() to deliver events
+ * and update joystick device state.
+ */
+static void WIIU_JoystickUpdate(SDL_Joystick *joystick)
+{
+	int16_t x1, y1, x2, y2;
+	/* Gamepad */
+	if (joystick->instance_id == WIIU_GetInstForDevice(WIIU_DEVICE_GAMEPAD)) {
+		static uint16_t last_touch_x = 0;
+		static uint16_t last_touch_y = 0;
+		static uint16_t last_touched = 0;
+
+		static int16_t x1_old = 0;
+		static int16_t y1_old = 0;
+		static int16_t x2_old = 0;
+		static int16_t y2_old = 0;
+
+		VPADStatus vpad;
+		VPADReadError error;
+		VPADTouchData tpdata;
+		VPADRead(VPAD_CHAN_0, &vpad, 1, &error);
+		if (error == VPAD_READ_INVALID_CONTROLLER) {
+			/* Gamepad disconnected! */
+			SDL_PrivateJoystickRemoved(joystick->instance_id);
+			/* Unlink Gamepad, device_index, instance_id */
+			WIIU_RemoveDevice(WIIU_DEVICE_GAMEPAD);
+		} else if (error != VPAD_READ_SUCCESS) {
+			return;
+		}
+
+		/* touchscreen */
+		VPADGetTPCalibratedPoint(VPAD_CHAN_0, &tpdata, &vpad.tpNormal);
+		if (tpdata.touched) {
+			/* Send an initial touch */
+			SDL_SendTouch(0, 0, SDL_TRUE,
+					(float) tpdata.x / 1280.0f,
+					(float) tpdata.y / 720.0f, 1);
+
+			/* Always send the motion */
+			SDL_SendTouchMotion(0, 0,
+					(float) tpdata.x / 1280.0f,
+					(float) tpdata.y / 720.0f, 1);
+
+			/* Update old values */
+			last_touch_x = tpdata.x;
+			last_touch_y = tpdata.y;
+			last_touched = 1;
+		} else if (last_touched) {
+			/* Finger released from screen */
+			SDL_SendTouch(0, 0, SDL_FALSE,
+					(float) last_touch_x / 1280.0f,
+					(float) last_touch_y / 720.0f, 1);
+			last_touched = 0;
+		}
+
+		/* axys */
+		x1 = (int16_t) ((vpad.leftStick.x) * 0x7ff0);
+		y1 = (int16_t) -((vpad.leftStick.y) * 0x7ff0);
+		x2 = (int16_t) ((vpad.rightStick.x) * 0x7ff0);
+		y2 = (int16_t) -((vpad.rightStick.y) * 0x7ff0);
+
+		if(x1 != x1_old) {
+			SDL_PrivateJoystickAxis(joystick, 0, x1);
+			x1_old = x1;
+		}
+		if(y1 != y1_old) {
+			SDL_PrivateJoystickAxis(joystick, 1, y1);
+			y1_old = y1;
+		}
+		if(x2 != x2_old) {
+			SDL_PrivateJoystickAxis(joystick, 2, x2);
+			x2_old = x2;
+		}
+		if(y2 != y2_old) {
+			SDL_PrivateJoystickAxis(joystick, 3, y2);
+			y2_old = y2;
+		}
+
+		/* buttons */
+		for(int i = 0; i < joystick->nbuttons; i++)
+			if (vpad.trigger & vpad_button_map[i])
+				SDL_PrivateJoystickButton(joystick, (Uint8)i, SDL_PRESSED);
+		for(int i = 0; i < joystick->nbuttons; i++)
+			if (vpad.release & vpad_button_map[i])
+				SDL_PrivateJoystickButton(joystick, (Uint8)i, SDL_RELEASED);
+	} else if (
+		joystick->instance_id == WIIU_GetInstForDevice(WIIU_DEVICE_WPAD(0)) ||
+		joystick->instance_id == WIIU_GetInstForDevice(WIIU_DEVICE_WPAD(1)) ||
+		joystick->instance_id == WIIU_GetInstForDevice(WIIU_DEVICE_WPAD(2)) ||
+		joystick->instance_id == WIIU_GetInstForDevice(WIIU_DEVICE_WPAD(3))) {
+		int wiiu_device = WIIU_GetDeviceForInst(joystick->instance_id);
+		WPADExtensionType ext;
+		KPADStatus kpad;
+		int32_t err;
+
+		if (WPADProbe(WIIU_WPAD_CHAN(wiiu_device), &ext) != 0) {
+			/* Do nothing, we'll catch it in Detect() */
+			return;
+		}
+
+		KPADReadEx(WIIU_WPAD_CHAN(wiiu_device), &kpad, 1, &err);
+		if (err != KPAD_ERROR_OK) return;
+
+		switch (ext) {
+		case WPAD_EXT_CORE:
+		case WPAD_EXT_MPLUS:
+		default: {
+			for(int i = 0; i < joystick->nbuttons; i++)
+				if (kpad.trigger & wiimote_button_map[i])
+					SDL_PrivateJoystickButton(joystick, (Uint8)i, SDL_PRESSED);
+			for(int i = 0; i < joystick->nbuttons; i++)
+				if (kpad.release & wiimote_button_map[i])
+					SDL_PrivateJoystickButton(joystick, (Uint8)i, SDL_RELEASED);
+			break;
+		}
+		case WPAD_EXT_NUNCHUK:
+		case WPAD_EXT_MPLUS_NUNCHUK: {
+			for(int i = 0; i < joystick->nbuttons; i++)
+				if (kpad.trigger & wiimote_button_map[i])
+					SDL_PrivateJoystickButton(joystick, (Uint8)i, SDL_PRESSED);
+			for(int i = 0; i < joystick->nbuttons; i++)
+				if (kpad.release & wiimote_button_map[i])
+					SDL_PrivateJoystickButton(joystick, (Uint8)i, SDL_RELEASED);
+
+			x1 = (int16_t) ((kpad.nunchuck.stick.x) * 0x7ff0);
+			y1 = (int16_t) -((kpad.nunchuck.stick.y) * 0x7ff0);
+			SDL_PrivateJoystickAxis(joystick, 0, x1);
+			SDL_PrivateJoystickAxis(joystick, 1, y1);
+			break;
+		}
+		case WPAD_EXT_CLASSIC:
+		case WPAD_EXT_MPLUS_CLASSIC: {
+			for(int i = 0; i < joystick->nbuttons; i++)
+				if (kpad.classic.trigger & classic_button_map[i])
+					SDL_PrivateJoystickButton(joystick, (Uint8)i, SDL_PRESSED);
+			for(int i = 0; i < joystick->nbuttons; i++)
+				if (kpad.classic.release & classic_button_map[i])
+					SDL_PrivateJoystickButton(joystick, (Uint8)i, SDL_RELEASED);
+
+			x1 = (int16_t) ((kpad.classic.leftStick.x) * 0x7ff0);
+			y1 = (int16_t) -((kpad.classic.leftStick.y) * 0x7ff0);
+			x2 = (int16_t) ((kpad.classic.rightStick.x) * 0x7ff0);
+			y2 = (int16_t) -((kpad.classic.rightStick.y) * 0x7ff0);
+			SDL_PrivateJoystickAxis(joystick, 0, x1);
+			SDL_PrivateJoystickAxis(joystick, 1, y1);
+			SDL_PrivateJoystickAxis(joystick, 2, x2);
+			SDL_PrivateJoystickAxis(joystick, 3, y2);
+			break;
+		}
+		case WPAD_EXT_PRO_CONTROLLER: {
+			for(int i = 0; i < joystick->nbuttons; i++)
+				if (kpad.pro.trigger & pro_button_map[i])
+					SDL_PrivateJoystickButton(joystick, (Uint8)i, SDL_PRESSED);
+			for(int i = 0; i < joystick->nbuttons; i++)
+				if (kpad.pro.release & pro_button_map[i])
+					SDL_PrivateJoystickButton(joystick, (Uint8)i, SDL_RELEASED);
+
+			x1 = (int16_t) ((kpad.pro.leftStick.x) * 0x7ff0);
+			y1 = (int16_t) -((kpad.pro.leftStick.y) * 0x7ff0);
+			x2 = (int16_t) ((kpad.pro.rightStick.x) * 0x7ff0);
+			y2 = (int16_t) -((kpad.pro.rightStick.y) * 0x7ff0);
+			SDL_PrivateJoystickAxis(joystick, 0, x1);
+			SDL_PrivateJoystickAxis(joystick, 1, y1);
+			SDL_PrivateJoystickAxis(joystick, 2, x2);
+			SDL_PrivateJoystickAxis(joystick, 3, y2);
+			break;
+		}
+		}
+	}
+}
+
+/* Function to close a joystick after use */
+static void WIIU_JoystickClose(SDL_Joystick *joystick)
+{
+}
+
+/* Function to perform any system-specific joystick related cleanup */
+static void WIIU_JoystickQuit(void)
+{
+}
+
+SDL_JoystickDriver SDL_WIIU_JoystickDriver =
+{
+	WIIU_JoystickInit,
+	WIIU_JoystickGetCount,
+	WIIU_JoystickDetect,
+	WIIU_JoystickGetDeviceName,
+	WIIU_JoystickGetDevicePlayerIndex,
+	WIIU_JoystickGetDeviceGUID,
+	WIIU_JoystickGetDeviceInstanceID,
+	WIIU_JoystickOpen,
+	WIIU_JoystickRumble,
+	WIIU_JoystickUpdate,
+	WIIU_JoystickClose,
+	WIIU_JoystickQuit,
+};
+
+#endif
diff --git a/src/joystick/wiiu/SDL_wiiujoystick.h b/src/joystick/wiiu/SDL_wiiujoystick.h
new file mode 100644
index 000000000..64fcf50e5
--- /dev/null
+++ b/src/joystick/wiiu/SDL_wiiujoystick.h
@@ -0,0 +1,112 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 2018 Roberto Van Eeden <r.r.qwertyuiop.r.r@gmail.com>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#include <padscore/wpad.h>
+
+#define WIIU_DEVICE_INVALID (-1)
+#define WIIU_DEVICE_GAMEPAD (0)
+#define WIIU_DEVICE_WPAD(x) (x + 1)
+#define WIIU_WPAD_CHAN(device) (device - 1)
+#define WIIU_NUM_WPADS (4)
+
+#define MAX_CONTROLLERS WIIU_DEVICE_WPAD(WIIU_NUM_WPADS)
+
+#define SIZEOF_ARR(arr) (sizeof(arr) / sizeof(arr[0]))
+
+static VPADButtons vpad_button_map[] =
+{
+    VPAD_BUTTON_A, VPAD_BUTTON_B, VPAD_BUTTON_X, VPAD_BUTTON_Y,
+    VPAD_BUTTON_STICK_L, VPAD_BUTTON_STICK_R,
+    VPAD_BUTTON_L, VPAD_BUTTON_R,
+    VPAD_BUTTON_ZL, VPAD_BUTTON_ZR,
+    VPAD_BUTTON_PLUS, VPAD_BUTTON_MINUS,
+    VPAD_BUTTON_LEFT, VPAD_BUTTON_UP, VPAD_BUTTON_RIGHT, VPAD_BUTTON_DOWN,
+    VPAD_STICK_L_EMULATION_LEFT, VPAD_STICK_L_EMULATION_UP, VPAD_STICK_L_EMULATION_RIGHT, VPAD_STICK_L_EMULATION_DOWN,
+    VPAD_STICK_R_EMULATION_LEFT, VPAD_STICK_R_EMULATION_UP, VPAD_STICK_R_EMULATION_RIGHT, VPAD_STICK_R_EMULATION_DOWN
+};
+
+static WPADButton wiimote_button_map[] = {
+    WPAD_BUTTON_A, WPAD_BUTTON_B, WPAD_BUTTON_Z, WPAD_BUTTON_C,
+    0, 0,
+    WPAD_BUTTON_1, WPAD_BUTTON_2,
+    0, 0,
+    WPAD_BUTTON_PLUS, WPAD_BUTTON_MINUS,
+    WPAD_BUTTON_LEFT, WPAD_BUTTON_UP, WPAD_BUTTON_RIGHT, WPAD_BUTTON_DOWN,
+};
+
+static WPADClassicButton classic_button_map[] = {
+    WPAD_CLASSIC_BUTTON_A, WPAD_CLASSIC_BUTTON_B, WPAD_CLASSIC_BUTTON_X,
+    WPAD_CLASSIC_BUTTON_Y,
+    0, 0,
+    WPAD_CLASSIC_BUTTON_L, WPAD_CLASSIC_BUTTON_R,
+    WPAD_CLASSIC_BUTTON_ZL, WPAD_CLASSIC_BUTTON_ZR,
+    WPAD_CLASSIC_BUTTON_PLUS, WPAD_CLASSIC_BUTTON_MINUS,
+    WPAD_CLASSIC_BUTTON_LEFT, WPAD_CLASSIC_BUTTON_UP, WPAD_CLASSIC_BUTTON_RIGHT,
+    WPAD_CLASSIC_BUTTON_DOWN,
+};
+
+static WPADProButton pro_button_map[] = {
+    WPAD_PRO_BUTTON_A, WPAD_PRO_BUTTON_B, WPAD_PRO_BUTTON_X, WPAD_PRO_BUTTON_Y,
+    WPAD_PRO_BUTTON_STICK_L, WPAD_PRO_BUTTON_STICK_R,
+    WPAD_PRO_TRIGGER_L, WPAD_PRO_TRIGGER_R,
+    WPAD_PRO_TRIGGER_ZL, WPAD_PRO_TRIGGER_ZR,
+    WPAD_PRO_BUTTON_PLUS, WPAD_PRO_BUTTON_MINUS,
+    WPAD_PRO_BUTTON_LEFT, WPAD_PRO_BUTTON_UP,
+    WPAD_PRO_BUTTON_RIGHT, WPAD_PRO_BUTTON_DOWN,
+    WPAD_PRO_STICK_L_EMULATION_LEFT, WPAD_PRO_STICK_L_EMULATION_UP,
+    WPAD_PRO_STICK_L_EMULATION_RIGHT, WPAD_PRO_STICK_L_EMULATION_DOWN,
+    WPAD_PRO_STICK_R_EMULATION_LEFT, WPAD_PRO_STICK_R_EMULATION_UP,
+    WPAD_PRO_STICK_R_EMULATION_RIGHT, WPAD_PRO_STICK_R_EMULATION_DOWN
+};
+
+static int WIIU_JoystickInit(void);
+static int WIIU_JoystickGetCount(void);
+static void WIIU_JoystickDetect(void);
+static const char *WIIU_JoystickGetDeviceName(int device_index);
+static int WIIU_JoystickGetDevicePlayerIndex(int device_index);
+static SDL_JoystickGUID WIIU_JoystickGetDeviceGUID(int device_index);
+static SDL_JoystickID WIIU_JoystickGetDeviceInstanceID(int device_index);
+static int WIIU_JoystickOpen(SDL_Joystick *joystick, int device_index);
+static int WIIU_JoystickRumble(SDL_Joystick * joystick, Uint16 low_frequency_rumble, Uint16 high_frequency_rumble, Uint32 duration_ms);
+static void WIIU_JoystickUpdate(SDL_Joystick *joystick);
+static void WIIU_JoystickClose(SDL_Joystick *joystick);
+static void WIIU_JoystickQuit(void);
+
+#define RETURN_WPAD_NAME(chan, ext) { \
+    switch (ext) { \
+    case WPAD_EXT_CORE: \
+    case WPAD_EXT_MPLUS: \
+    default: { \
+        return "Wii Remote #" #chan; \
+    } \
+    case WPAD_EXT_NUNCHUK: \
+    case WPAD_EXT_MPLUS_NUNCHUK: { \
+        return "Wii Remote #" #chan " and Nunchuk"; \
+    } \
+    case WPAD_EXT_CLASSIC: \
+    case WPAD_EXT_MPLUS_CLASSIC: { \
+        return "Wii Classic Controller #" #chan; \
+    } \
+    case WPAD_EXT_PRO_CONTROLLER: { \
+        return "WiiU Pro Controller #" #chan; \
+    } \
+    } \
+}
diff --git a/src/libm/math_private.h b/src/libm/math_private.h
index ee67c444e..23fad187b 100644
--- a/src/libm/math_private.h
+++ b/src/libm/math_private.h
@@ -27,7 +27,7 @@
 #define libm_hidden_def(x)
 #define strong_alias(x, y)
 
-#if !defined(__HAIKU__) && !defined(__PSP__) && !defined(__3DS__) && !defined(__PS2__) /* already defined in a system header. */
+#if !defined(__HAIKU__) && !defined(__PSP__) && !defined(__3DS__) && !defined(__PS2__) && !defined(__WIIU__) /* already defined in a system header. */
 typedef unsigned int u_int32_t;
 #endif
 
diff --git a/src/render/SDL_render.c b/src/render/SDL_render.c
index b650c6ac4..979a711da 100644
--- a/src/render/SDL_render.c
+++ b/src/render/SDL_render.c
@@ -124,6 +124,9 @@ static const SDL_RenderDriver *render_drivers[] = {
 #if SDL_VIDEO_RENDER_VITA_GXM
     &VITA_GXM_RenderDriver,
 #endif
+#if SDL_VIDEO_RENDER_WIIU
+    &WIIU_RenderDriver,
+#endif
 #if SDL_VIDEO_RENDER_SW
     &SW_RenderDriver
 #endif
diff --git a/src/render/SDL_sysrender.h b/src/render/SDL_sysrender.h
index 36e9555bb..283fe0e88 100644
--- a/src/render/SDL_sysrender.h
+++ b/src/render/SDL_sysrender.h
@@ -307,6 +307,7 @@ extern SDL_RenderDriver PS2_RenderDriver;
 extern SDL_RenderDriver PSP_RenderDriver;
 extern SDL_RenderDriver SW_RenderDriver;
 extern SDL_RenderDriver VITA_GXM_RenderDriver;
+extern SDL_RenderDriver WIIU_RenderDriver;
 
 /* Blend mode functions */
 extern SDL_BlendFactor SDL_GetBlendModeSrcColorFactor(SDL_BlendMode blendMode);
diff --git a/src/render/wiiu/SDL_rdraw_wiiu.c b/src/render/wiiu/SDL_rdraw_wiiu.c
new file mode 100644
index 000000000..78fbee4a2
--- /dev/null
+++ b/src/render/wiiu/SDL_rdraw_wiiu.c
@@ -0,0 +1,444 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 2018-2019 Ash Logan <ash@heyquark.com>
+  Copyright (C) 2018-2019 Roberto Van Eeden <r.r.qwertyuiop.r.r@gmail.com>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#if SDL_VIDEO_RENDER_WIIU
+
+#include "../../video/wiiu/SDL_wiiuvideo.h"
+#include "../../video/wiiu/wiiu_shaders.h"
+#include "../SDL_sysrender.h"
+#include "SDL_hints.h"
+#include "SDL_render_wiiu.h"
+
+#include <gx2/texture.h>
+#include <gx2/draw.h>
+#include <gx2/registers.h>
+#include <gx2/sampler.h>
+#include <gx2/state.h>
+#include <gx2/clear.h>
+#include <gx2/mem.h>
+#include <gx2/event.h>
+#include <gx2r/surface.h>
+#include <gx2r/buffer.h>
+#include <gx2r/draw.h>
+
+#include <stdio.h>
+#include <stdarg.h>
+#include <stdlib.h>
+#include <string.h>
+#include <math.h>
+
+static void WIIU_SDL_SetGX2BlendMode(SDL_BlendMode mode);
+
+int WIIU_SDL_RenderCopy(SDL_Renderer * renderer, SDL_Texture * texture,
+                        const SDL_Rect * srcrect, const SDL_FRect * dstrect)
+{
+    WIIU_RenderData *data = (WIIU_RenderData *) renderer->driverdata;
+    WIIU_TextureData *tdata = (WIIU_TextureData *) texture->driverdata;
+    GX2RBuffer *a_position, *a_texCoord;
+    WIIUVec2 *a_position_vals, *a_texCoord_vals;
+    float x_min, y_min, x_max, y_max;
+
+    if (texture->access & SDL_TEXTUREACCESS_TARGET) {
+        GX2RInvalidateSurface(&tdata->texture.surface, 0, 0);
+    }
+
+    /* Update texture rendering state */
+    WIIU_TextureStartRendering(data, tdata);
+
+    /* Allocate attribute buffers */
+    a_position = WIIU_AllocRenderData(data, (GX2RBuffer) {
+        .flags =
+            GX2R_RESOURCE_BIND_VERTEX_BUFFER |
+            GX2R_RESOURCE_USAGE_CPU_WRITE,
+        .elemSize = sizeof(WIIUVec2), // float x/y for each corner
+        .elemCount = 4, // 4 corners
+    });
+    a_texCoord = WIIU_AllocRenderData(data, (GX2RBuffer) {
+        .flags =
+            GX2R_RESOURCE_BIND_VERTEX_BUFFER |
+            GX2R_RESOURCE_USAGE_CPU_WRITE,
+        .elemSize = sizeof(WIIUVec2),
+        .elemCount = 4, // 4 corners
+    });
+
+    /* Compute vertex points */
+    x_min = renderer->viewport.x + dstrect->x;
+    y_min = renderer->viewport.y + dstrect->y;
+    x_max = renderer->viewport.x + dstrect->x + dstrect->w;
+    y_max = renderer->viewport.y + dstrect->y + dstrect->h;
+
+    /* Save them */
+    a_position_vals = GX2RLockBufferEx(a_position, 0);
+    a_position_vals[0] = (WIIUVec2){.x = x_min, .y = y_max};
+    a_position_vals[1] = (WIIUVec2){.x = x_max, .y = y_max};
+    a_position_vals[2] = (WIIUVec2){.x = x_max, .y = y_min};
+    a_position_vals[3] = (WIIUVec2){.x = x_min, .y = y_min};
+    GX2RUnlockBufferEx(a_position, 0);
+
+    /* Compute texture coords */
+    a_texCoord_vals = GX2RLockBufferEx(a_texCoord, 0);
+    a_texCoord_vals[0] = (WIIUVec2) {
+        .x = srcrect->x,
+        .y = texture->h - srcrect->y - srcrect->h,
+    };
+    a_texCoord_vals[1] = (WIIUVec2) {
+        .x = srcrect->x + srcrect->w,
+        .y = texture->h - srcrect->y - srcrect->h,
+    };
+    a_texCoord_vals[2] = (WIIUVec2) {
+        .x = srcrect->x + srcrect->w,
+        .y = texture->h - srcrect->y,
+    };
+    a_texCoord_vals[3] = (WIIUVec2) {
+        .x = srcrect->x,
+        .y = texture->h - srcrect->y,
+    };
+    GX2RUnlockBufferEx(a_texCoord, 0);
+
+    /* Render */
+    wiiuSetTextureShader();
+    GX2SetPixelTexture(&tdata->texture, 0);
+    GX2SetPixelSampler(&tdata->sampler, 0);
+    GX2RSetAttributeBuffer(a_position, 0, a_position->elemSize, 0);
+    GX2RSetAttributeBuffer(a_texCoord, 1, a_texCoord->elemSize, 0);
+    GX2SetVertexUniformReg(wiiuTextureShader.vertexShader->uniformVars[0].offset, 4, (uint32_t *)&data->u_viewSize);
+    GX2SetVertexUniformReg(wiiuTextureShader.vertexShader->uniformVars[1].offset, 4, (uint32_t *)&tdata->u_texSize);
+    GX2SetPixelUniformReg(wiiuTextureShader.pixelShader->uniformVars[0].offset, 4, (uint32_t *)&tdata->u_mod);
+    WIIU_SDL_SetGX2BlendMode(texture->blendMode);
+    GX2DrawEx(GX2_PRIMITIVE_MODE_QUADS, 4, 0, 1);
+
+    return 0;
+}
+
+
+int WIIU_SDL_RenderCopyEx(SDL_Renderer * renderer, SDL_Texture * texture,
+                          const SDL_Rect * srcrect, const SDL_FRect * dstrect,
+                          const double angle, const SDL_FPoint * center, const SDL_RendererFlip flip)
+{
+    WIIU_RenderData *data = (WIIU_RenderData *) renderer->driverdata;
+    WIIU_TextureData *tdata = (WIIU_TextureData *) texture->driverdata;
+    GX2RBuffer *a_position, *a_texCoord;
+    WIIUVec2 *a_position_vals, *a_texCoord_vals;
+
+    /* Compute real vertex points */
+    float x_min = renderer->viewport.x + dstrect->x;
+    float y_min = renderer->viewport.y + dstrect->y;
+    float x_max = x_min + dstrect->w;
+    float y_max = y_min + dstrect->h;
+    float cx = x_min + center->x;
+    float cy = y_min + center->y;
+    double r = angle * (M_PI / 180.0);
+    WIIUVec2 rvb[4] = {
+        {
+            .x = (flip & SDL_FLIP_HORIZONTAL) ? x_max : x_min,
+            .y = (flip & SDL_FLIP_VERTICAL) ? y_min : y_max,
+        },
+        {
+            .x = (flip & SDL_FLIP_HORIZONTAL) ? x_min : x_max,
+            .y = (flip & SDL_FLIP_VERTICAL) ? y_min : y_max,
+        },
+        {
+            .x = (flip & SDL_FLIP_HORIZONTAL) ? x_min : x_max,
+            .y = (flip & SDL_FLIP_VERTICAL) ? y_max : y_min,
+        },
+        {
+            .x = (flip & SDL_FLIP_HORIZONTAL) ? x_max : x_min,
+            .y = (flip & SDL_FLIP_VERTICAL) ? y_max : y_min,
+        },
+    };
+
+    if (texture->access & SDL_TEXTUREACCESS_TARGET) {
+        GX2RInvalidateSurface(&tdata->texture.surface, 0, 0);
+    }
+
+    /* Update texture rendering state */
+    WIIU_TextureStartRendering(data, tdata);
+
+    /* Allocate attribute buffers */
+    a_position = WIIU_AllocRenderData(data, (GX2RBuffer) {
+        .flags =
+            GX2R_RESOURCE_BIND_VERTEX_BUFFER |
+            GX2R_RESOURCE_USAGE_CPU_WRITE,
+        .elemSize = sizeof(WIIUVec2), // float x/y for each corner
+        .elemCount = 4, // 4 corners
+    });
+    a_texCoord = WIIU_AllocRenderData(data, (GX2RBuffer) {
+        .flags =
+            GX2R_RESOURCE_BIND_VERTEX_BUFFER |
+            GX2R_RESOURCE_USAGE_CPU_WRITE,
+        .elemSize = sizeof(WIIUVec2), // float x/y for each corner
+        .elemCount = 4, // 4 corners
+    });
+
+    /* Save vertex points */
+    a_position_vals = GX2RLockBufferEx(a_position, 0);
+    for (int i = 0; i < 4; i++) {
+        a_position_vals[i] = (WIIUVec2) {
+            .x = cx + (SDL_cos(r) * (rvb[i].x - cx) - SDL_sin(r) * (rvb[i].y - cy)),
+            .y = cy + (SDL_cos(r) * (rvb[i].y - cy) + SDL_sin(r) * (rvb[i].x - cx)),
+        };
+    }
+    GX2RUnlockBufferEx(a_position, 0);
+
+    /* Compute texture coords */
+    a_texCoord_vals = GX2RLockBufferEx(a_texCoord, 0);
+    a_texCoord_vals[0] = (WIIUVec2) {
+        .x = srcrect->x,
+        .y = texture->h - srcrect->y - srcrect->h,
+    };
+    a_texCoord_vals[1] = (WIIUVec2) {
+        .x = srcrect->x + srcrect->w,
+        .y = texture->h - srcrect->y - srcrect->h,
+    };
+    a_texCoord_vals[2] = (WIIUVec2) {
+        .x = srcrect->x + srcrect->w,
+        .y = texture->h - srcrect->y,
+    };
+    a_texCoord_vals[3] = (WIIUVec2) {
+        .x = srcrect->x,
+        .y = texture->h - srcrect->y,
+    };
+    GX2RUnlockBufferEx(a_texCoord, 0);
+
+    /* Render */
+    wiiuSetTextureShader();
+    GX2SetPixelTexture(&tdata->texture, 0);
+    GX2SetPixelSampler(&tdata->sampler, 0);
+    GX2RSetAttributeBuffer(a_position, 0, a_position->elemSize, 0);
+    GX2RSetAttributeBuffer(a_texCoord, 1, a_texCoord->elemSize, 0);
+    GX2SetVertexUniformReg(wiiuTextureShader.vertexShader->uniformVars[0].offset, 4, (uint32_t *)&data->u_viewSize);
+    GX2SetVertexUniformReg(wiiuTextureShader.vertexShader->uniformVars[1].offset, 4, (uint32_t *)&tdata->u_texSize);
+    GX2SetPixelUniformReg(wiiuTextureShader.pixelShader->uniformVars[0].offset, 4, (uint32_t *)&tdata->u_mod);
+    WIIU_SDL_SetGX2BlendMode(texture->blendMode);
+    GX2DrawEx(GX2_PRIMITIVE_MODE_QUADS, 4, 0, 1);
+
+    return 0;
+}
+
+int WIIU_SDL_RenderDrawPoints(SDL_Renderer * renderer, const SDL_FPoint * points,
+                              int count)
+{
+    WIIU_RenderData *data = (WIIU_RenderData *) renderer->driverdata;
+    GX2RBuffer *a_position;
+    WIIUVec2 *a_position_vals;
+
+    /* Compute colours */
+    WIIUVec4 u_colour = {
+        .r = (float)renderer->r / 255.0f,
+        .g = (float)renderer->g / 255.0f,
+        .b = (float)renderer->b / 255.0f,
+        .a = (float)renderer->a / 255.0f,
+    };
+
+    /* Allocate attribute buffers */
+    a_position = WIIU_AllocRenderData(data, (GX2RBuffer) {
+        .flags =
+            GX2R_RESOURCE_BIND_VERTEX_BUFFER |
+            GX2R_RESOURCE_USAGE_CPU_WRITE,
+        .elemSize = sizeof(WIIUVec2), /* float x/y for each point */
+        .elemCount = count,
+    });
+
+    /* Compute vertex positions */
+    a_position_vals = GX2RLockBufferEx(a_position, 0);
+    for (int i = 0; i < count; ++i) {
+        a_position_vals[i] = (WIIUVec2) {
+            .x = (float)renderer->viewport.x + points[i].x,
+            .y = (float)renderer->viewport.y + points[i].y,
+        };
+    }
+    GX2RUnlockBufferEx(a_position, 0);
+
+    /* Render points */
+    wiiuSetColorShader();
+    GX2RSetAttributeBuffer(a_position, 0, a_position->elemSize, 0);
+    GX2SetVertexUniformReg(wiiuColorShader.vertexShader->uniformVars[0].offset, 4, (uint32_t *)&data->u_viewSize);
+    GX2SetPixelUniformReg(wiiuColorShader.pixelShader->uniformVars[0].offset, 4, (uint32_t *)&u_colour);
+    WIIU_SDL_SetGX2BlendMode(renderer->blendMode);
+    GX2DrawEx(GX2_PRIMITIVE_MODE_POINTS, count, 0, 1);
+
+    return 0;
+}
+
+
+int WIIU_SDL_RenderDrawLines(SDL_Renderer * renderer, const SDL_FPoint * points,
+                             int count)
+{
+    WIIU_RenderData *data = (WIIU_RenderData *) renderer->driverdata;
+    GX2RBuffer *a_position;
+    WIIUVec2 *a_position_vals;
+
+    /* Compute colours */
+    WIIUVec4 u_colour = {
+        .r = (float)renderer->r / 255.0f,
+        .g = (float)renderer->g / 255.0f,
+        .b = (float)renderer->b / 255.0f,
+        .a = (float)renderer->a / 255.0f,
+    };
+
+    /*  Allocate attribute buffers */
+    a_position = WIIU_AllocRenderData(data, (GX2RBuffer) {
+        .flags =
+            GX2R_RESOURCE_BIND_VERTEX_BUFFER |
+            GX2R_RESOURCE_USAGE_CPU_WRITE,
+        .elemSize = sizeof(WIIUVec2), /* float x/y for each point */
+        .elemCount = count,
+    });
+
+    /* Compute vertex positions */
+    a_position_vals = GX2RLockBufferEx(a_position, 0);
+    for (int i = 0; i < count; ++i) {
+        a_position_vals[i] = (WIIUVec2) {
+            .x = (float)renderer->viewport.x + points[i].x,
+            .y = (float)renderer->viewport.y + points[i].y,
+        };
+    }
+    GX2RUnlockBufferEx(a_position, 0);
+
+    /* Render lines */
+    wiiuSetColorShader();
+    GX2RSetAttributeBuffer(a_position, 0, a_position->elemSize, 0);
+    GX2SetVertexUniformReg(wiiuColorShader.vertexShader->uniformVars[0].offset, 4, (uint32_t *)&data->u_viewSize);
+    GX2SetPixelUniformReg(wiiuColorShader.pixelShader->uniformVars[0].offset, 4, (uint32_t *)&u_colour);
+    WIIU_SDL_SetGX2BlendMode(renderer->blendMode);
+    GX2DrawEx(GX2_PRIMITIVE_MODE_LINE_STRIP, count, 0, 1);
+
+    return 0;
+}
+
+int WIIU_SDL_RenderFillRects(SDL_Renderer * renderer, const SDL_FRect * rects, int count)
+{
+    WIIU_RenderData *data = (WIIU_RenderData *) renderer->driverdata;
+    GX2RBuffer *a_position;
+    WIIUVec2 *a_position_vals;
+
+    /* Compute colours */
+    WIIUVec4 u_colour = {
+        .r = (float)renderer->r / 255.0f,
+        .g = (float)renderer->g / 255.0f,
+        .b = (float)renderer->b / 255.0f,
+        .a = (float)renderer->a / 255.0f,
+    };
+
+    /* Compute vertex pos */
+    float vx = (float)renderer->viewport.x;
+    float vy = (float)renderer->viewport.y;
+
+    /*  Allocate attribute buffers */
+    a_position = WIIU_AllocRenderData(data, (GX2RBuffer) {
+        .flags =
+            GX2R_RESOURCE_BIND_VERTEX_BUFFER |
+            GX2R_RESOURCE_USAGE_CPU_WRITE,
+        .elemSize = sizeof(WIIUVec2), // x/y float per corner
+        .elemCount = 4 * count, // 4 corners per square
+    });
+
+    /* Compute vertex positions */
+    a_position_vals = GX2RLockBufferEx(a_position, 0);
+    for (int i = 0; i < count; ++i) {
+        a_position_vals[i*4 + 0] = (WIIUVec2) {
+            .x = vx + rects[i].x,
+            .y = vy + rects[i].y,
+        };
+        a_position_vals[i*4 + 1] = (WIIUVec2) {
+            .x = vx + rects[i].x + rects[i].w,
+            .y = vy + rects[i].y,
+        };
+        a_position_vals[i*4 + 2] = (WIIUVec2) {
+            .x = vx + rects[i].x + rects[i].w,
+            .y = vy + rects[i].y + rects[i].h,
+        };
+        a_position_vals[i*4 + 3] = (WIIUVec2) {
+            .x = vx + rects[i].x,
+            .y = vy + rects[i].y + rects[i].h,
+        };
+    }
+    GX2RUnlockBufferEx(a_position, 0);
+
+    /* Render rects */
+    wiiuSetColorShader();
+    GX2RSetAttributeBuffer(a_position, 0, a_position->elemSize, 0);
+    GX2SetVertexUniformReg(wiiuColorShader.vertexShader->uniformVars[0].offset, 4, (uint32_t *)&data->u_viewSize);
+    GX2SetPixelUniformReg(wiiuColorShader.pixelShader->uniformVars[0].offset, 4, (uint32_t *)&u_colour);
+    WIIU_SDL_SetGX2BlendMode(renderer->blendMode);
+    GX2DrawEx(GX2_PRIMITIVE_MODE_QUADS, 4 * count, 0, 1);
+
+    return 0;
+}
+
+int WIIU_SDL_RenderClear(SDL_Renderer * renderer)
+{
+    WIIU_RenderData* data = (WIIU_RenderData*) renderer->driverdata;
+    SDL_Texture* target = WIIU_GetRenderTarget(renderer);
+    WIIU_TextureData* tdata = (WIIU_TextureData*) target->driverdata;
+
+    GX2ClearColor(&tdata->cbuf,
+                  (float)renderer->r / 255.0f,
+                  (float)renderer->g / 255.0f,
+                  (float)renderer->b / 255.0f,
+                  (float)renderer->a / 255.0f);
+
+    /* Restore SDL context state */
+    GX2SetContextState(data->ctx);
+
+    return 0;
+}
+
+static void WIIU_SDL_SetGX2BlendMode(SDL_BlendMode mode)
+{
+    if (mode == SDL_BLENDMODE_NONE) {
+        GX2SetColorControl(GX2_LOGIC_OP_COPY, 0x00, FALSE, TRUE);
+    } else if (mode == SDL_BLENDMODE_BLEND) {
+        GX2SetColorControl(GX2_LOGIC_OP_COPY, 0xFF, FALSE, TRUE);
+        GX2SetBlendControl(GX2_RENDER_TARGET_0,
+            /* RGB = [srcRGB * srcA] + [dstRGB * (1-srcA)] */
+            GX2_BLEND_MODE_SRC_ALPHA, GX2_BLEND_MODE_INV_SRC_ALPHA,
+            GX2_BLEND_COMBINE_MODE_ADD,
+            TRUE,
+            /* A = [srcA * 1] + [dstA * (1-srcA)] */
+            GX2_BLEND_MODE_ONE, GX2_BLEND_MODE_INV_SRC_ALPHA,
+            GX2_BLEND_COMBINE_MODE_ADD);
+    } else if (mode == SDL_BLENDMODE_ADD) {
+        GX2SetColorControl(GX2_LOGIC_OP_COPY, 0xFF, FALSE, TRUE);
+        GX2SetBlendControl(GX2_RENDER_TARGET_0,
+            /* RGB = [srcRGB * srcA] + [dstRGB * 1] */
+            GX2_BLEND_MODE_SRC_ALPHA, GX2_BLEND_MODE_ONE,
+            GX2_BLEND_COMBINE_MODE_ADD,
+            TRUE,
+            /* A = [srcA * 0] + [dstA * 1] */
+            GX2_BLEND_MODE_ZERO, GX2_BLEND_MODE_ONE,
+            GX2_BLEND_COMBINE_MODE_ADD);
+    } else if (mode == SDL_BLENDMODE_MOD) {
+        GX2SetColorControl(GX2_LOGIC_OP_COPY, 0xFF, FALSE, TRUE);
+        GX2SetBlendControl(GX2_RENDER_TARGET_0,
+            /* RGB = [srcRGB * dstRGB] + [dstRGB * 0]) */
+            GX2_BLEND_MODE_DST_COLOR, GX2_BLEND_MODE_ZERO,
+            GX2_BLEND_COMBINE_MODE_ADD,
+            TRUE,
+            /* A = [srcA * 0] + [dstA * 1] */
+            GX2_BLEND_MODE_ZERO, GX2_BLEND_MODE_ONE,
+            GX2_BLEND_COMBINE_MODE_ADD);
+    }
+}
+
+#endif /* SDL_VIDEO_RENDER_WIIU */
diff --git a/src/render/wiiu/SDL_render_wiiu.c b/src/render/wiiu/SDL_render_wiiu.c
new file mode 100644
index 000000000..633c26b38
--- /dev/null
+++ b/src/render/wiiu/SDL_render_wiiu.c
@@ -0,0 +1,275 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 2018-2019 Ash Logan <ash@heyquark.com>
+  Copyright (C) 2018-2019 Roberto Van Eeden <r.r.qwertyuiop.r.r@gmail.com>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#if SDL_VIDEO_RENDER_WIIU
+
+#include "../../video/wiiu/SDL_wiiuvideo.h"
+#include "../../video/wiiu/wiiu_shaders.h"
+#include "../SDL_sysrender.h"
+#include "SDL_hints.h"
+#include "SDL_render_wiiu.h"
+
+#include <gx2/event.h>
+#include <gx2/registers.h>
+#include <gx2r/surface.h>
+
+#include <malloc.h>
+
+SDL_RenderDriver WIIU_RenderDriver;
+
+SDL_Renderer *WIIU_SDL_CreateRenderer(SDL_Window * window, Uint32 flags)
+{
+    SDL_Renderer *renderer;
+    WIIU_RenderData *data;
+
+    renderer = (SDL_Renderer *) SDL_calloc(1, sizeof(*renderer));
+    if (!renderer) {
+        SDL_OutOfMemory();
+        return NULL;
+    }
+
+    data = (WIIU_RenderData *) SDL_calloc(1, sizeof(*data));
+    if (!data) {
+        WIIU_SDL_DestroyRenderer(renderer);
+        SDL_OutOfMemory();
+        return NULL;
+    }
+
+    /* Setup renderer functions */
+    renderer->WindowEvent = WIIU_SDL_WindowEvent;
+    renderer->GetOutputSize = WIIU_SDL_GetOutputSize;
+    renderer->CreateTexture = WIIU_SDL_CreateTexture;
+    renderer->SetTextureColorMod = WIIU_SDL_SetTextureColorMod;
+    renderer->SetTextureAlphaMod = WIIU_SDL_SetTextureAlphaMod;
+    renderer->UpdateTexture = WIIU_SDL_UpdateTexture;
+    renderer->LockTexture = WIIU_SDL_LockTexture;
+    renderer->UnlockTexture = WIIU_SDL_UnlockTexture;
+    renderer->SetRenderTarget = WIIU_SDL_SetRenderTarget;
+    renderer->UpdateViewport = WIIU_SDL_UpdateViewport;
+    renderer->UpdateClipRect = WIIU_SDL_UpdateClipRect;
+    renderer->RenderClear = WIIU_SDL_RenderClear;
+    renderer->RenderDrawPoints = WIIU_SDL_RenderDrawPoints;
+    renderer->RenderDrawLines = WIIU_SDL_RenderDrawLines;
+    renderer->RenderFillRects = WIIU_SDL_RenderFillRects;
+    renderer->RenderCopy = WIIU_SDL_RenderCopy;
+    renderer->RenderCopyEx = WIIU_SDL_RenderCopyEx;
+    renderer->RenderReadPixels = WIIU_SDL_RenderReadPixels;
+    renderer->RenderPresent = WIIU_SDL_RenderPresent;
+    renderer->DestroyTexture = WIIU_SDL_DestroyTexture;
+    renderer->DestroyRenderer = WIIU_SDL_DestroyRenderer;
+    renderer->info = WIIU_RenderDriver.info;
+    renderer->driverdata = data;
+    renderer->window = window;
+
+    /* Prepare shaders */
+    wiiuInitTextureShader();
+    wiiuInitColorShader();
+
+    /* List of attibutes to free after render */
+    data->listfree = NULL;
+
+    /* Setup line and point size */
+    GX2SetLineWidth(1.0f);
+    GX2SetPointSize(1.0f, 1.0f);
+
+    /* Create a fresh context state */
+    data->ctx = (GX2ContextState *) memalign(GX2_CONTEXT_STATE_ALIGNMENT, sizeof(GX2ContextState));
+    SDL_memset(data->ctx, 0, sizeof(GX2ContextState));
+    GX2SetupContextStateEx(data->ctx, TRUE);
+    GX2SetContextState(data->ctx);
+
+    /* Setup some context state options */
+    GX2SetAlphaTest(TRUE, GX2_COMPARE_FUNC_GREATER, 0.0f);
+    GX2SetDepthOnlyControl(FALSE, FALSE, GX2_COMPARE_FUNC_NEVER);
+    GX2SetCullOnlyControl(GX2_FRONT_FACE_CCW, FALSE, FALSE);
+
+    /* Make a texture for the window */
+    WIIU_SDL_CreateWindowTex(renderer, window);
+
+    /* Setup colour buffer, rendering to the window */
+    WIIU_SDL_SetRenderTarget(renderer, NULL);
+
+    return renderer;
+}
+
+void WIIU_SDL_CreateWindowTex(SDL_Renderer * renderer, SDL_Window * window)
+{
+    WIIU_RenderData *data = (WIIU_RenderData *) renderer->driverdata;
+    const char *s_hint;
+    SDL_ScaleMode s_mode;
+
+    if (data->windowTex.driverdata) {
+        WIIU_SDL_DestroyTexture(renderer, &data->windowTex);
+        data->windowTex = (SDL_Texture) {0};
+    }
+
+    /* Setup scaling mode; this is normally handled by
+       SDL_CreateTexture/SDL_GetScaleMode, but those can't
+       be called before fully initializinig the renderer */
+    s_hint = SDL_GetHint(SDL_HINT_RENDER_SCALE_QUALITY);
+    if (!s_hint || SDL_strcasecmp(s_hint, "nearest") == 0) {
+        s_mode = SDL_ScaleModeNearest;
+    } else if (SDL_strcasecmp(s_hint, "linear") == 0) {
+        s_mode = SDL_ScaleModeLinear;
+    } else if (SDL_strcasecmp(s_hint, "best") == 0) {
+        s_mode = SDL_ScaleModeBest;
+    } else {
+        s_mode = (SDL_ScaleMode)SDL_atoi(s_hint);
+    }
+
+    /* Allocate a buffer for the window */
+    data->windowTex = (SDL_Texture) {
+        .format = SDL_PIXELFORMAT_RGBA8888,
+        .r = 255, .g = 255, .b = 255, .a = 255,
+        .driverdata = WIIU_TEXTURE_MEM1_MAGIC,
+        .scaleMode = s_mode,
+    };
+
+    SDL_GetWindowSize(window, &data->windowTex.w, &data->windowTex.h);
+
+    /* Setup texture and color buffer for the window */
+    WIIU_SDL_CreateTexture(renderer, &data->windowTex);
+}
+
+int WIIU_SDL_SetRenderTarget(SDL_Renderer * renderer, SDL_Texture * texture)
+{
+    WIIU_RenderData *data = (WIIU_RenderData *) renderer->driverdata;
+
+    /* Set window or texture as target */
+    WIIU_TextureData *tdata = (WIIU_TextureData *)((texture) ? texture->driverdata
+                                                             : data->windowTex.driverdata);
+
+    /* Wait for the texture rendering to finish */
+    WIIU_TextureCheckWaitRendering(data, tdata);
+
+    /* Update u_viewSize */
+    data->u_viewSize = (WIIUVec4) {
+        .x = (float)tdata->cbuf.surface.width,
+        .y = (float)tdata->cbuf.surface.height,
+    };
+
+    /* Update context state */
+    GX2SetColorBuffer(&tdata->cbuf, GX2_RENDER_TARGET_0);
+
+    /* These may be unnecessary - see SDL_render.c: SDL_SetRenderTarget's calls
+       to UpdateViewport and UpdateClipRect. TODO for once the render is
+       basically working */
+    GX2SetViewport(0, 0, (float)tdata->cbuf.surface.width, (float)tdata->cbuf.surface.height, 0.0f, 1.0f);
+    GX2SetScissor(0, 0, (float)tdata->cbuf.surface.width, (float)tdata->cbuf.surface.height);
+
+    return 0;
+}
+
+void WIIU_SDL_DestroyRenderer(SDL_Renderer * renderer)
+{
+    WIIU_RenderData *data = (WIIU_RenderData *) renderer->driverdata;
+
+    GX2DrawDone();
+
+    WIIU_FreeRenderData(data);
+    WIIU_TextureDoneRendering(data);
+
+    free(data->ctx);
+
+    wiiuFreeColorShader();
+    wiiuFreeTextureShader();
+
+    SDL_free(data);
+    SDL_free(renderer);
+}
+
+int WIIU_SDL_RenderReadPixels(SDL_Renderer * renderer, const SDL_Rect * rect,
+                              Uint32 format, void * pixels, int pitch)
+{
+    SDL_Texture* target = WIIU_GetRenderTarget(renderer);
+    WIIU_TextureData* tdata = (WIIU_TextureData*) target->driverdata;
+    Uint8 *src_image;
+    int ret;
+
+    /* NOTE: The rect is already adjusted according to the viewport by
+       SDL_RenderReadPixels */
+
+    if (rect->x < 0 || rect->x+rect->w > tdata->cbuf.surface.width ||
+        rect->y < 0 || rect->y+rect->h > tdata->cbuf.surface.height) {
+        return SDL_SetError("Tried to read outside of surface bounds");
+    }
+
+    src_image = GX2RLockSurfaceEx(&tdata->cbuf.surface, 0, GX2R_RESOURCE_LOCKED_READ_ONLY);
+
+    /* Convert and copy the pixels to target buffer */
+    ret = SDL_ConvertPixels(rect->w, rect->h, target->format,
+                            src_image + rect->y * tdata->cbuf.surface.pitch + rect->x * 4,
+                            tdata->cbuf.surface.pitch,
+                            format, pixels, pitch);
+
+    GX2RUnlockSurfaceEx(&tdata->cbuf.surface, 0, GX2R_RESOURCE_LOCKED_READ_ONLY);
+
+    return ret;
+}
+
+
+SDL_RenderDriver WIIU_RenderDriver =
+{
+    .CreateRenderer = WIIU_SDL_CreateRenderer,
+    .info = {
+        .name = "WiiU GX2",
+        .flags = SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC | SDL_RENDERER_TARGETTEXTURE,
+        .num_texture_formats = 13, //21,
+        .texture_formats = {
+        /*  TODO: Alpha-less (X) formats */
+            SDL_PIXELFORMAT_RGBA8888,
+//            SDL_PIXELFORMAT_RGBX8888,
+
+//            SDL_PIXELFORMAT_RGB444,
+            SDL_PIXELFORMAT_ARGB4444,
+            SDL_PIXELFORMAT_RGBA4444,
+            SDL_PIXELFORMAT_ABGR4444,
+            SDL_PIXELFORMAT_BGRA4444,
+
+//            SDL_PIXELFORMAT_RGB555,
+            SDL_PIXELFORMAT_ARGB1555,
+//            SDL_PIXELFORMAT_BGR555,
+            SDL_PIXELFORMAT_ABGR1555,
+            SDL_PIXELFORMAT_RGBA5551,
+            SDL_PIXELFORMAT_BGRA5551,
+
+        /*  TODO: RGB565 doesn't seem to work right, endian issue? */
+//            SDL_PIXELFORMAT_RGB565,
+//            SDL_PIXELFORMAT_BGR565,
+
+            SDL_PIXELFORMAT_ARGB8888,
+            SDL_PIXELFORMAT_BGRA8888,
+//            SDL_PIXELFORMAT_BGRX8888,
+            SDL_PIXELFORMAT_ABGR8888,
+//            SDL_PIXELFORMAT_BGR888,
+
+            SDL_PIXELFORMAT_ARGB2101010,
+        },
+        .max_texture_width = 0,
+        .max_texture_height = 0,
+    },
+};
+
+#endif /* SDL_VIDEO_RENDER_WIIU */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/render/wiiu/SDL_render_wiiu.h b/src/render/wiiu/SDL_render_wiiu.h
new file mode 100644
index 000000000..68f9ff910
--- /dev/null
+++ b/src/render/wiiu/SDL_render_wiiu.h
@@ -0,0 +1,322 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 2018-2019 Ash Logan <ash@heyquark.com>
+  Copyright (C) 2018-2019 Roberto Van Eeden <r.r.qwertyuiop.r.r@gmail.com>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#ifndef SDL_render_wiiu_h
+#define SDL_render_wiiu_h
+
+#include "../SDL_sysrender.h"
+#include "SDL_pixels.h"
+#include <gx2r/buffer.h>
+#include <gx2/context.h>
+#include <gx2/sampler.h>
+#include <gx2/texture.h>
+#include <gx2/surface.h>
+#include <gx2/event.h>
+
+/* Driver internal data structures */
+typedef struct WIIUVec2 WIIUVec2;
+typedef struct WIIUVec3 WIIUVec3;
+typedef struct WIIUVec4 WIIUVec4;
+typedef struct WIIUPixFmt WIIUPixFmt;
+typedef struct WIIU_RenderAllocData WIIU_RenderAllocData;
+typedef struct WIIU_TextureDrawData WIIU_TextureDrawData;
+typedef struct WIIU_RenderData WIIU_RenderData;
+typedef struct WIIU_TextureData WIIU_TextureData;
+
+struct WIIUVec2
+{
+    union { float x, r; };
+    union { float y, g; };
+};
+
+struct WIIUVec3
+{
+    union { float x, r; };
+    union { float y, g; };
+    union { float z, b; };
+};
+
+struct WIIUVec4
+{
+    union { float x, r; };
+    union { float y, g; };
+    union { float z, b; };
+    union { float w, a; };
+};
+
+struct WIIUPixFmt
+{
+    GX2SurfaceFormat fmt;
+    uint32_t compMap;
+};
+
+struct WIIU_RenderAllocData
+{
+    void *next;
+    GX2RBuffer buffer;
+};
+
+struct WIIU_TextureDrawData
+{
+    void *next;
+    WIIU_TextureData *texdata;
+};
+
+struct WIIU_RenderData
+{
+    GX2ContextState *ctx;
+    WIIU_RenderAllocData *listfree;
+    WIIU_TextureDrawData *listdraw;
+    WIIUVec4 u_viewSize;
+    SDL_Texture windowTex;
+};
+
+struct WIIU_TextureData
+{
+    GX2Sampler sampler;
+    GX2Texture texture;
+    GX2ColorBuffer cbuf;
+    WIIUVec4 u_texSize;
+    WIIUVec4 u_mod;
+    int isRendering;
+};
+
+/* Ask texture driver to allocate texture's memory from MEM1 */
+#define WIIU_TEXTURE_MEM1_MAGIC (void *)0xCAFE0001
+
+/* SDL_render API implementation */
+SDL_Renderer *WIIU_SDL_CreateRenderer(SDL_Window * window, Uint32 flags);
+void WIIU_SDL_WindowEvent(SDL_Renderer * renderer,
+                             const SDL_WindowEvent *event);
+int WIIU_SDL_GetOutputSize(SDL_Renderer * renderer, int *w, int *h);
+int WIIU_SDL_CreateTexture(SDL_Renderer * renderer, SDL_Texture * texture);
+int WIIU_SDL_SetTextureColorMod(SDL_Renderer * renderer,
+                                SDL_Texture * texture);
+int WIIU_SDL_SetTextureAlphaMod(SDL_Renderer * renderer,
+                                SDL_Texture * texture);
+int WIIU_SDL_UpdateTexture(SDL_Renderer * renderer, SDL_Texture * texture,
+                       const SDL_Rect * rect, const void *pixels,
+                       int pitch);
+int WIIU_SDL_LockTexture(SDL_Renderer * renderer, SDL_Texture * texture,
+                     const SDL_Rect * rect, void **pixels, int *pitch);
+void WIIU_SDL_UnlockTexture(SDL_Renderer * renderer, SDL_Texture * texture);
+int WIIU_SDL_SetRenderTarget(SDL_Renderer * renderer, SDL_Texture * texture);
+int WIIU_SDL_UpdateViewport(SDL_Renderer * renderer);
+int WIIU_SDL_UpdateClipRect(SDL_Renderer * renderer);
+int WIIU_SDL_RenderClear(SDL_Renderer * renderer);
+int WIIU_SDL_RenderDrawPoints(SDL_Renderer * renderer,
+                          const SDL_FPoint * points, int count);
+int WIIU_SDL_RenderDrawLines(SDL_Renderer * renderer,
+                         const SDL_FPoint * points, int count);
+int WIIU_SDL_RenderFillRects(SDL_Renderer * renderer,
+                         const SDL_FRect * rects, int count);
+int WIIU_SDL_RenderCopy(SDL_Renderer * renderer, SDL_Texture * texture,
+                    const SDL_Rect * srcrect, const SDL_FRect * dstrect);
+int WIIU_SDL_RenderCopyEx(SDL_Renderer * renderer, SDL_Texture * texture,
+                      const SDL_Rect * srcrect, const SDL_FRect * dstrect,
+                      const double angle, const SDL_FPoint * center, const SDL_RendererFlip flip);
+int WIIU_SDL_RenderReadPixels(SDL_Renderer * renderer, const SDL_Rect * rect,
+                          Uint32 format, void * pixels, int pitch);
+void WIIU_SDL_RenderPresent(SDL_Renderer * renderer);
+void WIIU_SDL_DestroyTexture(SDL_Renderer * renderer, SDL_Texture * texture);
+void WIIU_SDL_DestroyRenderer(SDL_Renderer * renderer);
+
+/* Driver internal functions */
+void WIIU_SDL_CreateWindowTex(SDL_Renderer * renderer, SDL_Window * window);
+
+/* Utility/helper functions */
+static inline GX2RBuffer * WIIU_AllocRenderData(WIIU_RenderData *r, GX2RBuffer buffer)
+{
+    WIIU_RenderAllocData *rdata = SDL_malloc(sizeof(WIIU_RenderAllocData));
+
+    rdata->buffer = buffer;
+    if (!GX2RCreateBuffer(&rdata->buffer)) {
+        SDL_free(rdata);
+        return 0;
+    }
+
+    rdata->next = r->listfree;
+    r->listfree = rdata;
+    return &rdata->buffer;
+}
+
+static inline void WIIU_FreeRenderData(WIIU_RenderData *r)
+{
+    while (r->listfree) {
+        WIIU_RenderAllocData *ptr = r->listfree;
+        r->listfree = r->listfree->next;
+        GX2RDestroyBufferEx(&ptr->buffer, 0);
+        SDL_free(ptr);
+    }
+}
+
+static inline void WIIU_TextureStartRendering(WIIU_RenderData *r, WIIU_TextureData *t)
+{
+    WIIU_TextureDrawData *d = SDL_malloc(sizeof(WIIU_TextureDrawData));
+    t->isRendering = 1;
+    d->texdata = t;
+    d->next = r->listdraw;
+    r->listdraw = d;
+}
+
+static inline void WIIU_TextureDoneRendering(WIIU_RenderData *r)
+{
+    while (r->listdraw) {
+        WIIU_TextureDrawData *d = r->listdraw;
+        r->listdraw = r->listdraw->next;
+        d->texdata->isRendering = 0;
+        SDL_free(d);
+    }
+}
+
+/* If the texture is currently being rendered and we change the content
+   before the rendering is finished, the GPU will end up partially drawing
+   the new data, so we wait for the GPU to finish rendering before
+   updating the texture */
+static inline void WIIU_TextureCheckWaitRendering(WIIU_RenderData *r, WIIU_TextureData *t)
+{
+    if (t->isRendering) {
+        GX2DrawDone();
+        WIIU_TextureDoneRendering(r);
+        WIIU_FreeRenderData(r);
+    }
+}
+
+static inline SDL_Texture * WIIU_GetRenderTarget(SDL_Renderer* renderer)
+{
+    WIIU_RenderData *data = (WIIU_RenderData *) renderer->driverdata;
+
+    if (renderer->target) {
+        return renderer->target;
+    }
+
+    return &data->windowTex;
+}
+
+static inline WIIUPixFmt SDLFormatToWIIUFormat(Uint32 format)
+{
+    WIIUPixFmt outFmt = { /* sane defaults? */
+        .fmt = GX2_SURFACE_FORMAT_UNORM_R8_G8_B8_A8,
+        .compMap = 0x00010203,
+    };
+
+    switch (format) {
+        /* packed16 formats: 4 bits/channel */
+        case SDL_PIXELFORMAT_RGB444: /* aka XRGB4444 */
+        case SDL_PIXELFORMAT_ARGB4444: {
+            outFmt.fmt = GX2_SURFACE_FORMAT_UNORM_R4_G4_B4_A4;
+            outFmt.compMap = 0x01020300;
+            break;
+        }
+        case SDL_PIXELFORMAT_RGBA4444: {
+            outFmt.fmt = GX2_SURFACE_FORMAT_UNORM_R4_G4_B4_A4;
+            outFmt.compMap = 0x00010203;
+            break;
+        }
+        case SDL_PIXELFORMAT_ABGR4444: {
+            outFmt.fmt = GX2_SURFACE_FORMAT_UNORM_R4_G4_B4_A4;
+            outFmt.compMap = 0x03020100;
+            break;
+        }
+        case SDL_PIXELFORMAT_BGRA4444: {
+            outFmt.fmt = GX2_SURFACE_FORMAT_UNORM_R4_G4_B4_A4;
+            outFmt.compMap = 0x02010003;
+            break;
+        }
+
+        /* packed16 formats: 5 bits/channel */
+        case SDL_PIXELFORMAT_RGB555: /* aka XRGB1555 */
+        case SDL_PIXELFORMAT_ARGB1555: {
+            outFmt.fmt = GX2_SURFACE_FORMAT_UNORM_R5_G5_B5_A1;
+            outFmt.compMap = 0x01020300;
+            break;
+        }
+        case SDL_PIXELFORMAT_BGR555: /* aka XRGB1555 */
+        case SDL_PIXELFORMAT_ABGR1555: {
+            outFmt.fmt = GX2_SURFACE_FORMAT_UNORM_R5_G5_B5_A1;
+            outFmt.compMap = 0x03020100;
+            break;
+        }
+        case SDL_PIXELFORMAT_RGBA5551: {
+            outFmt.fmt = GX2_SURFACE_FORMAT_UNORM_R5_G5_B5_A1;
+            outFmt.compMap = 0x00010203;
+            break;
+        }
+        case SDL_PIXELFORMAT_BGRA5551: {
+            outFmt.fmt = GX2_SURFACE_FORMAT_UNORM_R5_G5_B5_A1;
+            outFmt.compMap = 0x02010003;
+            break;
+        }
+
+        /* packed16 formats: 565 */
+        case SDL_PIXELFORMAT_RGB565: {
+            outFmt.fmt = GX2_SURFACE_FORMAT_UNORM_R5_G6_B5;
+            outFmt.compMap = 0x00010203;
+            break;
+        }
+        case SDL_PIXELFORMAT_BGR565: {
+            outFmt.fmt = GX2_SURFACE_FORMAT_UNORM_R5_G6_B5;
+            outFmt.compMap = 0x02010003;
+            break;
+        }
+
+        /* packed32 formats */
+        case SDL_PIXELFORMAT_RGBA8888:
+        case SDL_PIXELFORMAT_RGBX8888: {
+            outFmt.fmt = GX2_SURFACE_FORMAT_UNORM_R8_G8_B8_A8;
+            outFmt.compMap = 0x00010203;
+            break;
+        }
+        case SDL_PIXELFORMAT_ARGB8888: {
+            outFmt.fmt = GX2_SURFACE_FORMAT_UNORM_R8_G8_B8_A8;
+            outFmt.compMap = 0x01020300;
+            break;
+        }
+        case SDL_PIXELFORMAT_BGRA8888:
+        case SDL_PIXELFORMAT_BGRX8888: {
+            outFmt.fmt = GX2_SURFACE_FORMAT_UNORM_R8_G8_B8_A8;
+            outFmt.compMap = 0x02010003;
+            break;
+        }
+        case SDL_PIXELFORMAT_ABGR8888:
+        case SDL_PIXELFORMAT_BGR888: {
+            outFmt.fmt = GX2_SURFACE_FORMAT_UNORM_R8_G8_B8_A8;
+            outFmt.compMap = 0x03020100;
+            break;
+        }
+        case SDL_PIXELFORMAT_ARGB2101010: {
+            outFmt.fmt = GX2_SURFACE_FORMAT_UNORM_R10_G10_B10_A2;
+            outFmt.compMap = 0x01020300;
+            break;
+        }
+        default: {
+            /* TODO return an error */
+            printf("SDL: WiiU format not recognised (SDL: %08X)\n", format);
+            break;
+        }
+    }
+
+    return outFmt;
+}
+
+#endif //SDL_render_wiiu_h
diff --git a/src/render/wiiu/SDL_rpresent_wiiu.c b/src/render/wiiu/SDL_rpresent_wiiu.c
new file mode 100644
index 000000000..18adae8e1
--- /dev/null
+++ b/src/render/wiiu/SDL_rpresent_wiiu.c
@@ -0,0 +1,157 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 2018-2019 Ash Logan <ash@heyquark.com>
+  Copyright (C) 2018-2019 Roberto Van Eeden <r.r.qwertyuiop.r.r@gmail.com>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#if SDL_VIDEO_RENDER_WIIU
+
+#include "../../video/wiiu/wiiu_shaders.h"
+#include "../SDL_sysrender.h"
+#include "SDL_render_wiiu.h"
+
+#include <whb/gfx.h>
+#include <gx2/registers.h>
+#include <gx2/state.h>
+#include <gx2/draw.h>
+#include <gx2r/buffer.h>
+#include <gx2r/draw.h>
+
+#define SCREEN_WIDTH    1280
+#define SCREEN_HEIGHT   720
+
+static const WIIUVec4 u_viewSize = {.x = (float)SCREEN_WIDTH, .y = (float)SCREEN_HEIGHT};
+
+static void render_scene(SDL_Renderer * renderer)
+{
+    WIIU_RenderData *data = (WIIU_RenderData *) renderer->driverdata;
+    WIIU_TextureData *tdata = (WIIU_TextureData *) data->windowTex.driverdata;
+
+    float tex_w = tdata->u_texSize.x;
+    float tex_h = tdata->u_texSize.y;
+    int win_x, win_y, win_w, win_h;
+    GX2RBuffer *a_position, *a_texCoord;
+    WIIUVec2 *a_position_vals, *a_texCoord_vals;
+
+    /* Allocate attribute buffers */
+    a_position = WIIU_AllocRenderData(data, (GX2RBuffer) {
+        .flags =
+            GX2R_RESOURCE_BIND_VERTEX_BUFFER |
+            GX2R_RESOURCE_USAGE_CPU_WRITE,
+        .elemSize = sizeof(WIIUVec2), /* float x/y for each corner */
+        .elemCount = 4, /* 4 corners */
+    });
+    a_texCoord = WIIU_AllocRenderData(data, (GX2RBuffer) {
+        .flags =
+            GX2R_RESOURCE_BIND_VERTEX_BUFFER |
+            GX2R_RESOURCE_USAGE_CPU_WRITE,
+        .elemSize = sizeof(WIIUVec2), // float x/y for each corner
+        .elemCount = 4, // 4 corners
+    });
+
+    /* Calculate and save positions */
+    if (SDL_GetWindowFlags(renderer->window) & SDL_WINDOW_FULLSCREEN) {
+        win_x = 0;
+        win_y = 0;
+        win_w = SCREEN_WIDTH;
+        win_h = SCREEN_HEIGHT;
+    } else {
+        /* Center */
+        SDL_GetWindowSize(renderer->window, &win_w, &win_h);
+        win_x = (SCREEN_WIDTH - win_w) / 2;
+        win_y = (SCREEN_HEIGHT - win_h) / 2;
+    }
+
+    a_position_vals = GX2RLockBufferEx(a_position, 0);
+    a_position_vals[0] = (WIIUVec2) {
+        .x = win_x, .y = win_y
+    };
+    a_position_vals[1] = (WIIUVec2) {
+        .x = win_x + win_w, .y = win_y
+    };
+    a_position_vals[2] = (WIIUVec2) {
+        .x = win_x + win_w, .y = win_y + win_h
+    };
+    a_position_vals[3] = (WIIUVec2) {
+        .x = win_x, .y = win_y + win_h
+    };
+    GX2RUnlockBufferEx(a_position, 0);
+
+    /* Compute texture coords */
+    a_texCoord_vals = GX2RLockBufferEx(a_texCoord, 0);
+    a_texCoord_vals[0] = (WIIUVec2) {.x = 0.0f,  .y = tex_h};
+    a_texCoord_vals[1] = (WIIUVec2) {.x = tex_w, .y = tex_h};
+    a_texCoord_vals[2] = (WIIUVec2) {.x = tex_w, .y = 0.0f};
+    a_texCoord_vals[3] = (WIIUVec2) {.x = 0.0f,  .y = 0.0f};
+    GX2RUnlockBufferEx(a_texCoord, 0);
+
+    /* Render the window */
+    WHBGfxClearColor(0.0f, 0.0f, 0.0f, 1.0f);
+    wiiuSetTextureShader();
+
+    GX2SetVertexUniformReg(wiiuTextureShader.vertexShader->uniformVars[0].offset, 4, (uint32_t *)&u_viewSize);
+    GX2SetVertexUniformReg(wiiuTextureShader.vertexShader->uniformVars[1].offset, 4, (uint32_t *)&tdata->u_texSize);
+    GX2SetPixelUniformReg(wiiuTextureShader.pixelShader->uniformVars[0].offset, 4, (uint32_t*)&tdata->u_mod);
+
+    GX2RSetAttributeBuffer(a_position, 0, a_position->elemSize, 0);
+    GX2RSetAttributeBuffer(a_texCoord, 1, a_texCoord->elemSize, 0);
+
+    GX2SetPixelTexture(&tdata->texture, wiiuTextureShader.pixelShader->samplerVars[0].location);
+    GX2SetPixelSampler(&tdata->sampler, wiiuTextureShader.pixelShader->samplerVars[0].location);
+
+    GX2SetColorControl(GX2_LOGIC_OP_COPY, 0x00, FALSE, TRUE);
+
+    GX2DrawEx(GX2_PRIMITIVE_MODE_QUADS, 4, 0, 1);
+}
+
+void WIIU_SDL_RenderPresent(SDL_Renderer * renderer)
+{
+    WIIU_RenderData *data = (WIIU_RenderData *) renderer->driverdata;
+    Uint32 flags = SDL_GetWindowFlags(renderer->window);
+
+    if (renderer->info.flags & SDL_RENDERER_PRESENTVSYNC) {
+    /*  NOTE watch libwhb's source to ensure this call only does vsync */
+        WHBGfxBeginRender();
+    }
+
+    /* Only render to TV if the window is *not* drc-only */
+    if (!(flags & SDL_WINDOW_WIIU_GAMEPAD_ONLY)) {
+        WHBGfxBeginRenderTV();
+        render_scene(renderer);
+        WHBGfxFinishRenderTV();
+    }
+
+    if (!(flags & SDL_WINDOW_WIIU_TV_ONLY)) {
+        WHBGfxBeginRenderDRC();
+        render_scene(renderer);
+        WHBGfxFinishRenderDRC();
+    }
+
+    WHBGfxFinishRender();
+
+    /* Free the list of render and draw data */
+    WIIU_FreeRenderData(data);
+    WIIU_TextureDoneRendering(data);
+
+    /* Restore SDL context state */
+    GX2SetContextState(data->ctx);
+}
+
+#endif /* SDL_VIDEO_RENDER_WIIU */
diff --git a/src/render/wiiu/SDL_rtexture_wiiu.c b/src/render/wiiu/SDL_rtexture_wiiu.c
new file mode 100644
index 000000000..7aae30b0d
--- /dev/null
+++ b/src/render/wiiu/SDL_rtexture_wiiu.c
@@ -0,0 +1,229 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 2018-2019 Ash Logan <ash@heyquark.com>
+  Copyright (C) 2018-2019 Roberto Van Eeden <r.r.qwertyuiop.r.r@gmail.com>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#if SDL_VIDEO_RENDER_WIIU
+
+#include "../SDL_sysrender.h"
+#include "SDL_render_wiiu.h"
+
+#include <gx2/context.h>
+#include <gx2/texture.h>
+#include <gx2/sampler.h>
+#include <gx2/mem.h>
+#include <gx2r/surface.h>
+#include <gx2r/resource.h>
+
+#include <malloc.h>
+#include <stdarg.h>
+
+int WIIU_SDL_CreateTexture(SDL_Renderer * renderer, SDL_Texture * texture)
+{
+    BOOL res;
+    WIIUPixFmt gx2_fmt;
+    GX2RResourceFlags surface_flags;
+    WIIU_TextureData *tdata = (WIIU_TextureData *) SDL_calloc(1, sizeof(*tdata));
+    if (!tdata) {
+        return SDL_OutOfMemory();
+    }
+
+    /* Setup sampler */
+    if (texture->scaleMode == SDL_ScaleModeNearest) {
+        GX2InitSampler(&tdata->sampler, GX2_TEX_CLAMP_MODE_CLAMP, GX2_TEX_XY_FILTER_MODE_POINT);
+    } else {
+        GX2InitSampler(&tdata->sampler, GX2_TEX_CLAMP_MODE_CLAMP, GX2_TEX_XY_FILTER_MODE_LINEAR);
+    }
+
+
+    gx2_fmt = SDLFormatToWIIUFormat(texture->format);
+
+    /* Setup GX2Texture */
+    tdata->texture.surface.width = texture->w;
+    tdata->texture.surface.height = texture->h;
+    tdata->texture.surface.format = gx2_fmt.fmt;
+    tdata->texture.surface.depth = 1;
+    tdata->texture.surface.dim = GX2_SURFACE_DIM_TEXTURE_2D;
+    tdata->texture.surface.tileMode = GX2_TILE_MODE_LINEAR_ALIGNED;
+    tdata->texture.surface.mipLevels = 1;
+    tdata->texture.viewNumMips = 1;
+    tdata->texture.viewNumSlices = 1;
+    tdata->texture.compMap = gx2_fmt.compMap;
+    GX2CalcSurfaceSizeAndAlignment(&tdata->texture.surface);
+    GX2InitTextureRegs(&tdata->texture);
+
+    /* Setup GX2ColorBuffer */
+    tdata->cbuf.surface = tdata->texture.surface;
+    tdata->cbuf.viewNumSlices = 1;
+    GX2InitColorBufferRegs(&tdata->cbuf);
+
+    /* Texture's surface flags */
+    surface_flags = GX2R_RESOURCE_BIND_TEXTURE | GX2R_RESOURCE_BIND_COLOR_BUFFER |
+                    GX2R_RESOURCE_USAGE_CPU_WRITE | GX2R_RESOURCE_USAGE_CPU_READ |
+                    GX2R_RESOURCE_USAGE_GPU_WRITE | GX2R_RESOURCE_USAGE_GPU_READ;
+
+    /* Allocate normal textures from MEM2 */
+    if (texture->driverdata != WIIU_TEXTURE_MEM1_MAGIC)
+        surface_flags |= GX2R_RESOURCE_USAGE_FORCE_MEM2;
+
+    /* Allocate the texture's surface */
+    res = GX2RCreateSurface(
+        &tdata->texture.surface,
+        surface_flags
+    );
+    if (!res) {
+        SDL_free(tdata);
+        return SDL_OutOfMemory();
+    }
+
+    /* Allocate a colour buffer, using the same backing buffer */
+    res = GX2RCreateSurfaceUserMemory(
+        &tdata->cbuf.surface,
+        tdata->texture.surface.image,
+        tdata->texture.surface.mipmaps,
+        tdata->texture.surface.resourceFlags
+    );
+    if (!res) {
+        GX2RDestroySurfaceEx(&tdata->texture.surface, 0);
+        SDL_free(tdata);
+        return SDL_OutOfMemory();
+    }
+
+    /* Initialize texture size uniform */
+    tdata->u_texSize = (WIIUVec4) {
+        .x = texture->w,
+        .y = texture->h,
+    };
+
+    /* Initialize color modifier uniform */
+    tdata->u_mod = (WIIUVec4) {
+        .r = (float)texture->r / 255.0f,
+        .g = (float)texture->g / 255.0f,
+        .b = (float)texture->b / 255.0f,
+        .a = (float)texture->a / 255.0f,
+    };
+
+    /* Setup texture driver data */
+    texture->driverdata = tdata;
+
+    return 0;
+}
+
+/* Somewhat adapted from SDL_render.c: SDL_LockTextureNative
+   The app basically wants a pointer to a particular rectangle as well as
+   write access to it. Easy GX2R! */
+int WIIU_SDL_LockTexture(SDL_Renderer * renderer, SDL_Texture * texture,
+                         const SDL_Rect * rect, void **pixels, int *pitch)
+{
+    WIIU_RenderData *data = (WIIU_RenderData *) renderer->driverdata;
+    WIIU_TextureData *tdata = (WIIU_TextureData *) texture->driverdata;
+    Uint32 BytesPerPixel = SDL_BYTESPERPIXEL(texture->format);
+    void* pixel_buffer;
+
+    /* Wait for the texture rendering to finish */
+    WIIU_TextureCheckWaitRendering(data, tdata);
+
+    pixel_buffer = GX2RLockSurfaceEx(&tdata->texture.surface, 0, 0);
+
+    /* Calculate pointer to first pixel in rect */
+    *pixels = (void *) ((Uint8 *) pixel_buffer +
+                        rect->y * (tdata->texture.surface.pitch * BytesPerPixel) +
+                        rect->x * BytesPerPixel);
+    *pitch = (tdata->texture.surface.pitch * BytesPerPixel);
+
+    /* Not sure we even need to bother keeping track of this */
+    texture->locked_rect = *rect;
+
+    return 0;
+}
+
+void WIIU_SDL_UnlockTexture(SDL_Renderer * renderer, SDL_Texture * texture)
+{
+    WIIU_TextureData *tdata = (WIIU_TextureData *) texture->driverdata;
+    GX2RUnlockSurfaceEx(&tdata->texture.surface, 0, 0);
+}
+
+int WIIU_SDL_UpdateTexture(SDL_Renderer * renderer, SDL_Texture * texture,
+                           const SDL_Rect * rect, const void *pixels, int pitch)
+{
+    Uint32 BytesPerPixel = SDL_BYTESPERPIXEL(texture->format);
+    size_t length = rect->w * BytesPerPixel;
+    Uint8 *src = (Uint8 *) pixels, *dst;
+    int row, dst_pitch;
+
+    /* We write the rules, and we say all textures are streaming */
+    WIIU_SDL_LockTexture(renderer, texture, rect, (void**)&dst, &dst_pitch);
+
+    for (row = 0; row < rect->h; ++row) {
+        SDL_memcpy(dst, src, length);
+        src += pitch;
+        dst += dst_pitch;
+    }
+
+    WIIU_SDL_UnlockTexture(renderer, texture);
+
+    return 0;
+}
+
+int WIIU_SDL_SetTextureColorMod(SDL_Renderer * renderer, SDL_Texture * texture)
+{
+    WIIU_TextureData *tdata = (WIIU_TextureData *) texture->driverdata;
+
+    /* Compute color mod */
+    tdata->u_mod.r = (float)texture->r / 255.0f;
+    tdata->u_mod.g = (float)texture->g / 255.0f;
+    tdata->u_mod.b = (float)texture->b / 255.0f;
+
+    return 0;
+}
+
+int WIIU_SDL_SetTextureAlphaMod(SDL_Renderer * renderer, SDL_Texture * texture)
+{
+    WIIU_TextureData *tdata = (WIIU_TextureData *) texture->driverdata;
+
+    /* Compute alpha mod */
+    tdata->u_mod.a = (float)texture->a / 255.0f;
+
+    return 0;
+}
+
+void WIIU_SDL_DestroyTexture(SDL_Renderer * renderer, SDL_Texture * texture)
+{
+    WIIU_RenderData *data;
+    WIIU_TextureData *tdata;
+
+    if (texture == NULL || texture->driverdata == NULL) {
+        return;
+    }
+
+    data = (WIIU_RenderData *) renderer->driverdata;
+    tdata = (WIIU_TextureData *) texture->driverdata;
+
+    /* Wait for the texture rendering to finish */
+    WIIU_TextureCheckWaitRendering(data, tdata);
+
+    GX2RDestroySurfaceEx(&tdata->cbuf.surface, 0);
+    GX2RDestroySurfaceEx(&tdata->texture.surface, 0);
+
+    SDL_free(tdata);
+}
+
+#endif //SDL_VIDEO_RENDER_WIIU
diff --git a/src/render/wiiu/SDL_rwindow_wiiu.c b/src/render/wiiu/SDL_rwindow_wiiu.c
new file mode 100644
index 000000000..fff15be94
--- /dev/null
+++ b/src/render/wiiu/SDL_rwindow_wiiu.c
@@ -0,0 +1,63 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 2018-2019 Ash Logan <ash@heyquark.com>
+  Copyright (C) 2018-2019 Roberto Van Eeden <r.r.qwertyuiop.r.r@gmail.com>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#if SDL_VIDEO_RENDER_WIIU
+
+#include "../SDL_sysrender.h"
+#include "SDL_render_wiiu.h"
+
+void WIIU_SDL_WindowEvent(SDL_Renderer * renderer, const SDL_WindowEvent *event)
+{
+    if (event->event == SDL_WINDOWEVENT_SIZE_CHANGED) {
+        /* Re-init the colour buffer etc. for new window size
+           TODO check: what if we're rendering to a texture when this happens?
+           SDL may handle this already, see SDL_render.c: SDL_RendererEventWatch */
+        WIIU_SDL_CreateWindowTex(renderer, renderer->window);
+        WIIU_SDL_SetRenderTarget(renderer, NULL);
+    }
+}
+
+/* We always output at whatever res the window is.
+   This may need to change if SDL_wiiuvideo is ever folded into SDL_render -
+   see SDL_*WindowTexture from SDL_video.c for how this could be done */
+int WIIU_SDL_GetOutputSize(SDL_Renderer * renderer, int *w, int *h)
+{
+    SDL_GetWindowSize(renderer->window, w, h);
+    return 0;
+}
+
+/* We handle all viewport changes in the render functions and shaders, so we
+   don't actually have to do anything here. SDL still requires we implement it. */
+int WIIU_SDL_UpdateViewport(SDL_Renderer * renderer)
+{
+    return 0;
+}
+
+/* Ideally this should change the GX2SetScissor values, but SetRenderTarget
+   needs refactoring first or these get overwritten. */
+int WIIU_SDL_UpdateClipRect(SDL_Renderer * renderer)
+{
+    return 0;
+}
+
+#endif //SDL_VIDEO_RENDER_WIIU
diff --git a/src/stdlib/SDL_malloc.c b/src/stdlib/SDL_malloc.c
index c1aa44414..8c796fba7 100644
--- a/src/stdlib/SDL_malloc.c
+++ b/src/stdlib/SDL_malloc.c
@@ -512,6 +512,12 @@ DEFAULT_MMAP_THRESHOLD       default: 256K
 #define LACKS_SYS_MMAN_H
 #endif  /* __OS2__ */
 
+#ifdef __WIIU__
+#define HAVE_MMAP 0
+#define LACKS_SYS_MMAN_H
+#define USE_LOCKS 0 // TODO: use locks
+#endif /* __WIIU__ */
+
 #if defined(DARWIN) || defined(_DARWIN)
 /* Mac OSX docs advise not to use sbrk; it seems better to use mmap */
 #ifndef HAVE_MORECORE
diff --git a/src/thread/SDL_thread_c.h b/src/thread/SDL_thread_c.h
index 278a68026..754c43718 100644
--- a/src/thread/SDL_thread_c.h
+++ b/src/thread/SDL_thread_c.h
@@ -46,6 +46,8 @@
 #include "os2/SDL_systhread_c.h"
 #elif SDL_THREAD_NGAGE
 #include "ngage/SDL_systhread_c.h"
+#elif SDL_THREAD_WIIU
+#include "wiiu/SDL_systhread_c.h"
 #else
 #error Need thread implementation for this platform
 #include "generic/SDL_systhread_c.h"
diff --git a/src/thread/wiiu/SDL_syscond.c b/src/thread/wiiu/SDL_syscond.c
new file mode 100644
index 000000000..318a50050
--- /dev/null
+++ b/src/thread/wiiu/SDL_syscond.c
@@ -0,0 +1,146 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2018 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#if SDL_THREAD_WIIU
+
+#include "SDL_thread.h"
+
+#include <stdbool.h>
+#include <coreinit/alarm.h>
+#include <coreinit/mutex.h>
+#include <coreinit/condition.h>
+
+typedef struct
+{
+   OSCondition *cond;
+   bool timed_out;
+} WIIU_CondWaitTimeoutData;
+
+/* Create a condition variable */
+SDL_cond *
+SDL_CreateCond(void)
+{
+    OSCondition *cond;
+
+    cond = (OSCondition *) SDL_malloc(sizeof(OSCondition));
+    if (cond) {
+        OSInitCond(cond);
+    } else {
+        SDL_OutOfMemory();
+    }
+    return (SDL_cond *)cond;
+}
+
+/* Destroy a condition variable */
+void
+SDL_DestroyCond(SDL_cond * cond)
+{
+    if (cond) {
+        SDL_free(cond);
+    }
+}
+
+/* Restart one of the threads that are waiting on the condition variable */
+int
+SDL_CondSignal(SDL_cond * cond)
+{
+    return SDL_CondBroadcast(cond);
+}
+
+/* Restart all threads that are waiting on the condition variable */
+int
+SDL_CondBroadcast(SDL_cond * cond)
+{
+    if (!cond) {
+        return SDL_SetError("Passed a NULL condition variable");
+    }
+
+    OSSignalCond((OSCondition *)cond);
+    return 0;
+}
+
+/* Wait on the condition variable for at most 'ms' milliseconds.
+   The mutex must be locked before entering this function!
+   The mutex is unlocked during the wait, and locked again after the wait.
+
+Typical use:
+
+Thread A:
+    SDL_LockMutex(lock);
+    while ( ! condition ) {
+        SDL_CondWait(cond, lock);
+    }
+    SDL_UnlockMutex(lock);
+
+Thread B:
+    SDL_LockMutex(lock);
+    ...
+    condition = true;
+    ...
+    SDL_CondSignal(cond);
+    SDL_UnlockMutex(lock);
+ */
+
+static void
+SDL_CondWaitTimeoutCallback(OSAlarm *alarm, OSContext *context)
+{
+   WIIU_CondWaitTimeoutData *data = (WIIU_CondWaitTimeoutData *)OSGetAlarmUserData(alarm);
+   data->timed_out = true;
+   OSSignalCond(data->cond);
+}
+
+int
+SDL_CondWaitTimeout(SDL_cond * cond, SDL_mutex * mutex, Uint32 ms)
+{
+	WIIU_CondWaitTimeoutData data;
+    OSAlarm alarm;
+
+	data.timed_out = false;
+	data.cond = (OSCondition *)cond;
+
+	// Timeout is zero
+	if (!ms)
+		return SDL_MUTEX_TIMEDOUT;
+
+	// Set an alarm
+	OSCreateAlarm(&alarm);
+	OSSetAlarmUserData(&alarm, &data);
+	OSSetAlarm(&alarm, OSMillisecondsToTicks(ms), &SDL_CondWaitTimeoutCallback);
+
+	// Wait on the condition
+	OSWaitCond((OSCondition *)cond, (OSMutex *)mutex);
+
+	OSCancelAlarm(&alarm);
+	return data.timed_out ? SDL_MUTEX_TIMEDOUT : 0;
+}
+
+/* Wait on the condition variable forever */
+int
+SDL_CondWait(SDL_cond * cond, SDL_mutex * mutex)
+{
+    OSWaitCond((OSCondition *)cond, (OSMutex *)mutex);
+    return 0;
+}
+
+#endif /* SDL_THREAD_WIIU */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/thread/wiiu/SDL_sysmutex.c b/src/thread/wiiu/SDL_sysmutex.c
new file mode 100644
index 000000000..f0c81699a
--- /dev/null
+++ b/src/thread/wiiu/SDL_sysmutex.c
@@ -0,0 +1,72 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2018 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#if SDL_THREAD_WIIU
+
+#include <errno.h>
+#include <coreinit/mutex.h>
+#include "SDL_thread.h"
+
+
+SDL_mutex *
+SDL_CreateMutex(void)
+{
+    OSMutex *mutex;
+
+    /* Allocate the structure */
+    mutex = (OSMutex *) SDL_calloc(1, sizeof(OSMutex));
+    OSInitMutex(mutex);
+    return (SDL_mutex *)mutex;
+}
+
+void
+SDL_DestroyMutex(SDL_mutex * mutex)
+{
+    if (mutex) {
+        SDL_free(mutex);
+    }
+}
+
+/* Lock the mutex */
+int
+SDL_LockMutex(SDL_mutex * mutex)
+{
+    OSLockMutex((OSMutex *)mutex);
+    return 0;
+}
+
+int
+SDL_TryLockMutex(SDL_mutex * mutex)
+{
+    return OSTryLockMutex((OSMutex *)mutex) ? 0 : SDL_MUTEX_TIMEDOUT;
+}
+
+int
+SDL_UnlockMutex(SDL_mutex * mutex)
+{
+    OSUnlockMutex((OSMutex *)mutex);
+    return 0;
+}
+
+#endif /* SDL_THREAD_WIIU */
+
+/* vi: set ts=4 sw=4 expandtab: */
\ No newline at end of file
diff --git a/src/thread/wiiu/SDL_sysmutex_c.h b/src/thread/wiiu/SDL_sysmutex_c.h
new file mode 100644
index 000000000..2979437b5
--- /dev/null
+++ b/src/thread/wiiu/SDL_sysmutex_c.h
@@ -0,0 +1,22 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2018 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/thread/wiiu/SDL_syssem.c b/src/thread/wiiu/SDL_syssem.c
new file mode 100644
index 000000000..a0038aa87
--- /dev/null
+++ b/src/thread/wiiu/SDL_syssem.c
@@ -0,0 +1,145 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2018 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#if SDL_THREAD_WIIU
+
+#include "SDL_timer.h"
+#include "SDL_thread.h"
+#include "SDL_systhread_c.h"
+
+#include <coreinit/semaphore.h>
+#include <coreinit/condition.h>
+#include <coreinit/alarm.h>
+#include <coreinit/mutex.h>
+#include <coreinit/time.h>
+
+#include <stdbool.h>
+
+typedef struct
+{
+   OSCondition *cond;
+   bool timed_out;
+} WIIU_SemWaitTimeoutData;
+
+struct SDL_semaphore
+{
+	OSMutex mtx;
+	OSSemaphore sem;
+	OSCondition cond;
+};
+
+SDL_sem *
+SDL_CreateSemaphore(Uint32 initial_value)
+{
+    SDL_sem *sem;
+
+    sem = (SDL_sem *) SDL_malloc(sizeof(*sem));
+    if (sem) {
+        OSInitSemaphore(&sem->sem, initial_value);
+		OSInitMutex(&sem->mtx);
+		OSInitCond(&sem->cond);
+    } else {
+        SDL_OutOfMemory();
+    }
+
+    return sem;
+}
+
+void
+SDL_DestroySemaphore(SDL_sem * sem)
+{
+    if (sem) {
+        SDL_free(sem);
+    }
+}
+
+int
+SDL_SemTryWait(SDL_sem * sem)
+{
+    return (OSTryWaitSemaphore(&sem->sem) > 0) ? 0 : SDL_MUTEX_TIMEDOUT;
+}
+
+static void
+SDL_SemWaitTimeoutCallback(OSAlarm *alarm, OSContext *context)
+{
+   WIIU_SemWaitTimeoutData *data = (WIIU_SemWaitTimeoutData *)OSGetAlarmUserData(alarm);
+   data->timed_out = true;
+   OSSignalCond(data->cond);
+}
+
+int
+SDL_SemWaitTimeout(SDL_sem * sem, Uint32 ms)
+{
+	WIIU_SemWaitTimeoutData data;
+    OSAlarm alarm;
+
+	// timeout is zero
+	if (!ms)
+		SDL_SemTryWait(sem);
+
+	OSLockMutex(&sem->mtx);
+
+	// setup callback data
+	data.timed_out = false;
+	data.cond = &sem->cond;
+
+	// set an alarm
+	OSCreateAlarm(&alarm);
+	OSSetAlarmUserData(&alarm, &data);
+	OSSetAlarm(&alarm, OSMillisecondsToTicks(ms), &SDL_SemWaitTimeoutCallback);
+
+	// try to acquire the semaphore
+    while((OSTryWaitSemaphore(&sem->sem) <= 0) && (data.timed_out == false)) {
+		OSWaitCond(&sem->cond, &sem->mtx);
+    }
+
+	OSCancelAlarm(&alarm);
+
+	OSUnlockMutex(&sem->mtx);
+
+    return (data.timed_out == false) ? 0 : SDL_MUTEX_TIMEDOUT;
+}
+
+int
+SDL_SemWait(SDL_sem * sem)
+{
+    OSWaitSemaphore(&sem->sem);
+    return 0;
+}
+
+Uint32
+SDL_SemValue(SDL_sem * sem)
+{
+    return OSGetSemaphoreCount(&sem->sem);
+}
+
+int
+SDL_SemPost(SDL_sem * sem)
+{
+	OSSignalSemaphore(&sem->sem);
+	OSSignalCond(&sem->cond);
+    return 0;
+}
+
+#endif /* SDL_THREAD_WIIU */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/thread/wiiu/SDL_systhread.c b/src/thread/wiiu/SDL_systhread.c
new file mode 100644
index 000000000..364255339
--- /dev/null
+++ b/src/thread/wiiu/SDL_systhread.c
@@ -0,0 +1,121 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2018 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#if SDL_THREAD_WIIU
+
+/* WiiU thread management routines for SDL */
+
+#include <stdio.h>
+#include <stdlib.h>
+
+#include "SDL_error.h"
+#include "SDL_thread.h"
+#include "../SDL_systhread.h"
+#include "../SDL_thread_c.h"
+#include <malloc.h>
+#include <coreinit/thread.h>
+
+static void
+thread_deallocator(OSThread *thread, void *stack)
+{
+   free(thread);
+   free(stack);
+}
+
+static void
+thread_cleanup(OSThread *thread, void *stack)
+{
+}
+
+int SDL_SYS_CreateThread(SDL_Thread *thread, void *args)
+{
+    OSThread *handle = (OSThread *)memalign(16, sizeof(OSThread));
+    unsigned int stackSize = thread->stacksize ? thread->stacksize : 0x8000;
+    void *stackTop = memalign(16, stackSize) + stackSize;
+    int priority = OSGetThreadPriority(OSGetCurrentThread());
+
+    if (!OSCreateThread(handle,
+                        (OSThreadEntryPointFn)SDL_RunThread,
+                        (int32_t)args,
+                        NULL,
+                        stackTop,
+                        stackSize,
+                        priority,
+                        OS_THREAD_ATTRIB_AFFINITY_ANY))
+    {
+        return SDL_SetError("OSCreateThread() failed");
+    }
+
+    OSSetThreadDeallocator(handle, &thread_deallocator);
+    OSSetThreadCleanupCallback(handle, &thread_cleanup);
+    OSResumeThread(handle);
+    thread->handle = handle;
+    return 0;
+}
+
+void SDL_SYS_SetupThread(const char *name)
+{
+    /* Do nothing. */
+}
+
+SDL_threadID SDL_ThreadID(void)
+{
+    return (SDL_threadID) OSGetCurrentThread();
+}
+
+void SDL_SYS_WaitThread(SDL_Thread *thread)
+{
+    OSJoinThread(thread->handle, NULL);
+}
+
+void SDL_SYS_DetachThread(SDL_Thread *thread)
+{
+    OSDetachThread(thread->handle);
+}
+
+void SDL_SYS_KillThread(SDL_Thread *thread)
+{
+    OSCancelThread(thread->handle);
+}
+
+int SDL_SYS_SetThreadPriority(SDL_ThreadPriority priority)
+{
+    int value;
+
+    if (priority == SDL_THREAD_PRIORITY_LOW) {
+        value = 17;
+    } else if (priority == SDL_THREAD_PRIORITY_HIGH) {
+        value = 15;
+    } else if (priority == SDL_THREAD_PRIORITY_TIME_CRITICAL) {
+        value = 14;
+    } else {
+        value = 16;
+    }
+
+    return OSSetThreadPriority(OSGetCurrentThread(), value);
+
+}
+
+#endif /* SDL_THREAD_WIIU */
+
+/* vim: ts=4 sw=4
+ */
\ No newline at end of file
diff --git a/src/thread/wiiu/SDL_systhread_c.h b/src/thread/wiiu/SDL_systhread_c.h
new file mode 100644
index 000000000..ca0626101
--- /dev/null
+++ b/src/thread/wiiu/SDL_systhread_c.h
@@ -0,0 +1,27 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2018 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#include <coreinit/thread.h>
+
+typedef OSThread *SYS_ThreadHandle;
+
+/* vi: set ts=4 sw=4 expandtab: */
\ No newline at end of file
diff --git a/src/thread/wiiu/SDL_systls.c b/src/thread/wiiu/SDL_systls.c
new file mode 100644
index 000000000..241862e83
--- /dev/null
+++ b/src/thread/wiiu/SDL_systls.c
@@ -0,0 +1,38 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2018 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#include "../../SDL_internal.h"
+#include "../SDL_thread_c.h"
+
+
+SDL_TLSData *
+SDL_SYS_GetTLSData(void)
+{
+    return SDL_Generic_GetTLSData();
+}
+
+int
+SDL_SYS_SetTLSData(SDL_TLSData *data)
+{
+    return SDL_Generic_SetTLSData(data);
+}
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/timer/wiiu/SDL_systimer.c b/src/timer/wiiu/SDL_systimer.c
new file mode 100644
index 000000000..6c95e1eff
--- /dev/null
+++ b/src/timer/wiiu/SDL_systimer.c
@@ -0,0 +1,86 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2018 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#ifdef SDL_TIMER_WIIU
+
+#include "SDL_thread.h"
+#include "SDL_timer.h"
+#include "SDL_error.h"
+#include "../SDL_timer_c.h"
+#include <coreinit/thread.h>
+#include <coreinit/systeminfo.h>
+#include <coreinit/time.h>
+
+static OSTime start;
+static SDL_bool ticks_started = SDL_FALSE;
+
+void
+SDL_TicksInit(void)
+{
+    if (ticks_started) {
+        return;
+    }
+    ticks_started = SDL_TRUE;
+    start = OSGetSystemTime();
+}
+
+void
+SDL_TicksQuit(void)
+{
+    ticks_started = SDL_FALSE;
+}
+
+Uint32
+SDL_GetTicks(void)
+{
+    OSTime now;
+
+    if (!ticks_started) {
+        SDL_TicksInit();
+    }
+
+    now = OSGetSystemTime();
+    return (Uint32)OSTicksToMilliseconds(now - start);
+}
+
+Uint64
+SDL_GetPerformanceCounter(void)
+{
+    return OSGetTime();
+}
+
+Uint64
+SDL_GetPerformanceFrequency(void)
+{
+    return OSTimerClockSpeed;
+}
+
+void
+SDL_Delay(Uint32 ms)
+{
+   OSSleepTicks(OSMillisecondsToTicks(ms));
+}
+
+#endif /* SDL_TIMER_WIIU */
+
+/* vim: ts=4 sw=4
+ */
diff --git a/src/video/SDL_sysvideo.h b/src/video/SDL_sysvideo.h
index d7a42cc64..0d88ea5e6 100644
--- a/src/video/SDL_sysvideo.h
+++ b/src/video/SDL_sysvideo.h
@@ -482,6 +482,7 @@ extern VideoBootStrap OFFSCREEN_bootstrap;
 extern VideoBootStrap NGAGE_bootstrap;
 extern VideoBootStrap OS2DIVE_bootstrap;
 extern VideoBootStrap OS2VMAN_bootstrap;
+extern VideoBootStrap WIIU_bootstrap;
 
 /* Use SDL_OnVideoThread() sparingly, to avoid regressions in use cases that currently happen to work */
 extern SDL_bool SDL_OnVideoThread(void);
diff --git a/src/video/SDL_video.c b/src/video/SDL_video.c
index 8065a0b8c..a22eb1be0 100644
--- a/src/video/SDL_video.c
+++ b/src/video/SDL_video.c
@@ -138,6 +138,9 @@ static VideoBootStrap *bootstrap[] = {
 #if SDL_VIDEO_DRIVER_OFFSCREEN
     &OFFSCREEN_bootstrap,
 #endif
+#if SDL_VIDEO_DRIVER_WIIU
+    &WIIU_bootstrap,
+#endif
 #if SDL_VIDEO_DRIVER_DUMMY
     &DUMMY_bootstrap,
 #if SDL_INPUT_LINUXEV
diff --git a/src/video/wiiu/SDL_wiiuvideo.c b/src/video/wiiu/SDL_wiiuvideo.c
new file mode 100644
index 000000000..4efd4e72e
--- /dev/null
+++ b/src/video/wiiu/SDL_wiiuvideo.c
@@ -0,0 +1,147 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 2018-2018 Ash Logan <ash@heyquark.com>
+  Copyright (C) 2018-2018 rw-r-r-0644 <r.r.qwertyuiop.r.r@gmail.com>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+/* This is basically just a stub at this point - all the magic happens in
+ * SDL_Render, and the textureframebuffer stuff in SDL_video.c.
+ * Potentially more could/should be done here, video modes and things.
+ * Some design work will need to go into the responsibilities of render
+ * vs video.
+ */
+
+#include "../../SDL_internal.h"
+
+#if SDL_VIDEO_DRIVER_WIIU
+
+/* SDL internals */
+#include "../SDL_sysvideo.h"
+#include "SDL_version.h"
+#include "SDL_syswm.h"
+#include "SDL_loadso.h"
+#include "SDL_events.h"
+#include "../../events/SDL_mouse_c.h"
+#include "../../events/SDL_keyboard_c.h"
+#include "SDL_wiiuvideo.h"
+
+#include <whb/proc.h>
+#include <whb/gfx.h>
+#include <string.h>
+#include <stdint.h>
+
+#include <proc_ui/procui.h>
+
+#include "wiiu_shaders.h"
+
+static int WIIU_VideoInit(_THIS);
+static int WIIU_SetDisplayMode(_THIS, SDL_VideoDisplay *display, SDL_DisplayMode *mode);
+static void WIIU_VideoQuit(_THIS);
+static void WIIU_PumpEvents(_THIS);
+
+static int using_whb_proc = 0;
+
+#define SCREEN_WIDTH    1280
+#define SCREEN_HEIGHT   720
+
+static int WIIU_VideoInit(_THIS)
+{
+	SDL_DisplayMode mode;
+
+	if (!ProcUIIsRunning()) {
+		WHBProcInit();
+		using_whb_proc = 1;
+	}
+	WHBGfxInit();
+
+	// setup shader
+	wiiuInitTextureShader();
+
+	// add default mode (1280x720)
+	mode.format = SDL_PIXELFORMAT_RGBA8888;
+	mode.w = SCREEN_WIDTH;
+	mode.h = SCREEN_HEIGHT;
+	mode.refresh_rate = 60;
+	mode.driverdata = NULL;
+	if (SDL_AddBasicVideoDisplay(&mode) < 0) {
+		return -1;
+	}
+	SDL_AddDisplayMode(&_this->displays[0], &mode);
+
+	return 0;
+}
+
+static void WIIU_VideoQuit(_THIS)
+{
+	wiiuFreeTextureShader();
+	WHBGfxShutdown();
+	if (using_whb_proc) WHBProcShutdown();
+}
+
+static int WIIU_CreateSDLWindow(_THIS, SDL_Window *window) {
+	SDL_SetKeyboardFocus(window);
+	return 0;
+}
+
+static int WIIU_SetDisplayMode(_THIS, SDL_VideoDisplay *display, SDL_DisplayMode *mode)
+{
+	return 0;
+}
+
+static void WIIU_PumpEvents(_THIS)
+{
+}
+
+static int WIIU_Available(void)
+{
+	return 1;
+}
+
+static void WIIU_DeleteDevice(SDL_VideoDevice *device)
+{
+	SDL_free(device);
+}
+
+static SDL_VideoDevice *WIIU_CreateDevice(int devindex)
+{
+	SDL_VideoDevice *device;
+
+	device = (SDL_VideoDevice*) SDL_calloc(1, sizeof(SDL_VideoDevice));
+	if(!device) {
+		SDL_OutOfMemory();
+		return NULL;
+	}
+
+	device->VideoInit = WIIU_VideoInit;
+	device->VideoQuit = WIIU_VideoQuit;
+	device->SetDisplayMode = WIIU_SetDisplayMode;
+	device->PumpEvents = WIIU_PumpEvents;
+	device->CreateSDLWindow = WIIU_CreateSDLWindow;
+
+	device->free = WIIU_DeleteDevice;
+
+	return device;
+}
+
+VideoBootStrap WIIU_bootstrap = {
+	"WiiU", "Video driver for Nintendo WiiU",
+	WIIU_Available, WIIU_CreateDevice
+};
+
+#endif /* SDL_VIDEO_DRIVER_WIIU */
diff --git a/src/video/wiiu/SDL_wiiuvideo.h b/src/video/wiiu/SDL_wiiuvideo.h
new file mode 100644
index 000000000..3cbf3df4c
--- /dev/null
+++ b/src/video/wiiu/SDL_wiiuvideo.h
@@ -0,0 +1,45 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 2018-2018 Ash Logan <ash@heyquark.com>
+  Copyright (C) 2018-2018 Roberto Van Eeden <r.r.qwertyuiop.r.r@gmail.com>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#include "../../SDL_internal.h"
+
+#ifndef SDL_wiiuvideo_h
+#define SDL_wiiuvideo_h
+
+#include <gx2/texture.h>
+#include "SDL_surface.h"
+
+#define WIIU_WINDOW_DATA "_SDL_WiiUData"
+typedef struct
+{
+    SDL_Surface *surface;
+    GX2Texture texture;
+} WIIU_WindowData;
+
+typedef struct
+{
+    SDL_bool tv_window_exists;
+    SDL_bool drc_window_exists;
+    SDL_bool mirrored_window_exists;
+} WIIU_VideoDeviceData;
+
+#endif //SDL_wiiuvideo_h
diff --git a/src/video/wiiu/shaders/build_shaders.sh b/src/video/wiiu/shaders/build_shaders.sh
new file mode 100755
index 000000000..490f82fb9
--- /dev/null
+++ b/src/video/wiiu/shaders/build_shaders.sh
@@ -0,0 +1,14 @@
+#!/bin/bash
+cd "${0%/*}"
+echo "Regenerating wiiu_shaders.c ..."
+latte-assembler compile colorShader.gsh --vsh colorShader.vsh --psh colorShader.psh
+latte-assembler compile textureShader.gsh --vsh textureShader.vsh --psh textureShader.psh
+xxd -i colorShader.gsh > colorShader.gsh.h
+xxd -i textureShader.gsh > textureShader.gsh.h
+sed -i '/_gsh_len/d' colorShader.gsh.h textureShader.gsh.h
+sed -i 's/colorShader_gsh/wiiuColorShaderData/g' colorShader.gsh.h
+sed -i 's/textureShader_gsh/wiiuTextureShaderData/g' textureShader.gsh.h
+cp wiiu_shaders.c.in ../wiiu_shaders.c
+cat colorShader.gsh.h textureShader.gsh.h >> ../wiiu_shaders.c
+rm -rf colorShader.gsh textureShader.gsh colorShader.gsh.h textureShader.gsh.h
+echo "Done!"
diff --git a/src/video/wiiu/shaders/colorShader.frag b/src/video/wiiu/shaders/colorShader.frag
new file mode 100644
index 000000000..651c31e11
--- /dev/null
+++ b/src/video/wiiu/shaders/colorShader.frag
@@ -0,0 +1,10 @@
+/* colorShader: fragment (pixel) shader (GLSL) */
+/* compile with ShaderAnalyzer (rv770) + fix latte-assembler messages */
+
+layout(location = 0) uniform vec4 u_color; /* color */
+
+void main()
+{
+    /* Set fragment color */
+    gl_FragColor = u_color;
+}
diff --git a/src/video/wiiu/shaders/colorShader.psh b/src/video/wiiu/shaders/colorShader.psh
new file mode 100644
index 000000000..5f821dc95
--- /dev/null
+++ b/src/video/wiiu/shaders/colorShader.psh
@@ -0,0 +1,14 @@
+; $MODE = "UniformRegister"
+; $UNIFORM_VARS[0].name = "u_color"
+; $UNIFORM_VARS[0].type = "float4"
+; $UNIFORM_VARS[0].count = 1
+; $UNIFORM_VARS[0].offset = 0
+; $UNIFORM_VARS[0].block = -1
+
+00 ALU: ADDR(32) CNT(4) 
+      0  x: MOV         R0.x,  C0.x      
+         y: MOV         R0.y,  C0.y      
+         z: MOV         R0.z,  C0.z      
+         w: MOV         R0.w,  C0.w      
+01 EXP_DONE: PIX0, R0
+END_OF_PROGRAM
diff --git a/src/video/wiiu/shaders/colorShader.vert b/src/video/wiiu/shaders/colorShader.vert
new file mode 100644
index 000000000..62dbe66c3
--- /dev/null
+++ b/src/video/wiiu/shaders/colorShader.vert
@@ -0,0 +1,16 @@
+/* colorShader: vertex shader (GLSL) */
+/* compile with ShaderAnalyzer (rv770) + fix latte-assembler messages */
+
+layout(location = 0) uniform vec2 u_viewSize; /* viewport size */
+layout(location = 0) in vec2 a_position;      /* vertex position */
+
+void main()
+{
+    /* Compute relative vertex position */
+    a_position.y = u_viewSize.y - a_position.y;
+    a_position.x = ((a_position.x / u_viewSize.x) * 2.0f) - 1.0f;
+    a_position.y = ((a_position.y / u_viewSize.y) * 2.0f) - 1.0f;
+
+    /* Set vertex position */
+    gl_Position = vec4(a_position, 0.0, 1.0);
+}
diff --git a/src/video/wiiu/shaders/colorShader.vsh b/src/video/wiiu/shaders/colorShader.vsh
new file mode 100644
index 000000000..d8239b94e
--- /dev/null
+++ b/src/video/wiiu/shaders/colorShader.vsh
@@ -0,0 +1,27 @@
+; $MODE = "UniformRegister"
+; $UNIFORM_VARS[0].name = "u_viewSize"
+; $UNIFORM_VARS[0].type = "float2"
+; $UNIFORM_VARS[0].count = 1
+; $UNIFORM_VARS[0].offset = 0
+; $UNIFORM_VARS[0].block = -1
+; $ATTRIB_VARS[0].name = "a_position"
+; $ATTRIB_VARS[0].type = "float2"
+; $ATTRIB_VARS[0].location = 0
+
+00 CALL_FS NO_BARRIER
+01 ALU: ADDR(32) CNT(9)
+      0  x: ADD         R0.x, -R1.y,  C0.y
+         z: MOV         R2.z,  0.0f
+         w: MOV         R2.w,  (0x3F800000, 1.0f).x
+         t: RCP_e       ____,  C0.x
+      1  z: MUL_e*2     ____,  R1.x,  PS0
+         t: RCP_e       ____,  C0.y
+      2  x: MUL_e*2     ____,  R0.x,  PS1
+         t: ADD         R2.x,  PV1.z, -1.0f
+      3  y: ADD         R2.y,  PV2.x, -1.0f
+02 EXP_DONE: POS0, R2
+03 EXP_DONE: PARAM0, R0.____
+04 ALU: ADDR(41) CNT(1)
+      4  x: NOP         ____
+05 NOP NO_BARRIER
+END_OF_PROGRAM
diff --git a/src/video/wiiu/shaders/textureShader.frag b/src/video/wiiu/shaders/textureShader.frag
new file mode 100644
index 000000000..502f7aafa
--- /dev/null
+++ b/src/video/wiiu/shaders/textureShader.frag
@@ -0,0 +1,13 @@
+/* textureShader: fragment (pixel) shader (GLSL) */
+/* compile with ShaderAnalyzer (rv770) + fix latte-assembler messages */
+/* NOTE: Ash knows R600 but not GLSL, so the .psh may have changes not in this
+   file. */
+
+layout(location = 0) uniform sampler2D s_texture; /* texture sampler */
+in vec2 texCoord; /* relative texture postion passed from vertex shader */
+
+void main()
+{
+    /* Compute fragment color for texture/position */
+    gl_FragColor = texture2D(s_texture, texCoord);
+}
diff --git a/src/video/wiiu/shaders/textureShader.psh b/src/video/wiiu/shaders/textureShader.psh
new file mode 100644
index 000000000..faca2f53e
--- /dev/null
+++ b/src/video/wiiu/shaders/textureShader.psh
@@ -0,0 +1,22 @@
+; $MODE = "UniformRegister"
+; $SAMPLER_VARS[0].name= "s_texture"
+; $SAMPLER_VARS[0].type= "sampler2D"
+; $SAMPLER_VARS[0].location = 0
+; $NUM_SPI_PS_INPUT_CNTL = 1
+; $SPI_PS_INPUT_CNTL[0].semantic = 0
+; $SPI_PS_INPUT_CNTL[0].default_val = 1
+; $UNIFORM_VARS[0].name = "u_mod"
+; $UNIFORM_VARS[0].type = "float4"
+; $UNIFORM_VARS[0].count = 1
+; $UNIFORM_VARS[0].offset = 0
+; $UNIFORM_VARS[0].block = -1
+
+00 TEX: ADDR(48) CNT(1) VALID_PIX
+      0  SAMPLE R0, R0.xy0x, t0, s0
+01 ALU: ADDR(32) CNT(4)
+      1  x: MUL R0.x, R0.x, C0.x
+         y: MUL R0.y, R0.y, C0.y
+         z: MUL R0.z, R0.z, C0.z
+         w: MUL R0.w, R0.w, C0.w
+02 EXP_DONE: PIX0, R0
+END_OF_PROGRAM
diff --git a/src/video/wiiu/shaders/textureShader.vert b/src/video/wiiu/shaders/textureShader.vert
new file mode 100644
index 000000000..d559ca533
--- /dev/null
+++ b/src/video/wiiu/shaders/textureShader.vert
@@ -0,0 +1,27 @@
+/* textureShader: vertex shader (GLSL) */
+/* compile with ShaderAnalyzer (rv770) + fix latte-assembler messages */
+
+layout(location = 0) uniform vec2 u_viewSize; /* viewport size */
+layout(location = 1) uniform vec2 u_texSize;  /* texture size */
+layout(location = 0) in vec2 a_position;      /* vertex position */
+layout(location = 1) in vec2 a_texCoordIn;    /* texture position */
+out vec2 texCoord; /* relative texture postion passed to pixel shader */
+
+void main()
+{
+    /* Compute relative vertex position */
+    a_position.y = u_viewSize.y - a_position.y;
+    a_position.x = ((a_position.x / u_viewSize.x) * 2.0f) - 1.0f;
+    a_position.y = ((a_position.y / u_viewSize.y) * 2.0f) - 1.0f;
+
+    /* Set vertex position */
+    gl_Position = vec4(a_position, 0.0, 1.0);
+
+    /* Compute relative coordinate position */
+    a_texCoordIn.y = u_texSize.y - a_texCoordIn.y;
+    a_texCoordIn.x = a_texCoordIn.x / u_texSize.x;
+    a_texCoordIn.y = a_texCoordIn.y / u_texSize.y;
+
+    /* Pass texture coordinate to pixel shader */
+    texCoord = a_texCoordIn;
+}
diff --git a/src/video/wiiu/shaders/textureShader.vsh b/src/video/wiiu/shaders/textureShader.vsh
new file mode 100644
index 000000000..84f047e3e
--- /dev/null
+++ b/src/video/wiiu/shaders/textureShader.vsh
@@ -0,0 +1,44 @@
+; $MODE = "UniformRegister"
+; $UNIFORM_VARS[0].name = "u_viewSize"
+; $UNIFORM_VARS[0].type = "float2"
+; $UNIFORM_VARS[0].count = 1
+; $UNIFORM_VARS[0].offset = 4
+; $UNIFORM_VARS[0].block = -1
+; $UNIFORM_VARS[1].name = "u_texSize"
+; $UNIFORM_VARS[1].type = "float2"
+; $UNIFORM_VARS[1].count = 1
+; $UNIFORM_VARS[1].offset = 0
+; $UNIFORM_VARS[1].block = -1
+; $ATTRIB_VARS[0].name = "a_position"
+; $ATTRIB_VARS[0].type = "float2"
+; $ATTRIB_VARS[0].location = 0
+; $ATTRIB_VARS[1].name = "a_texCoordIn"
+; $ATTRIB_VARS[1].type = "float2"
+; $ATTRIB_VARS[1].location = 1
+; $NUM_SPI_VS_OUT_ID = 1
+; $SPI_VS_OUT_ID[0].semantic_0 = 0
+
+00 CALL_FS NO_BARRIER
+01 ALU: ADDR(32) CNT(16)
+      0  x: ADD         R127.x, -R2.y,  C0.y
+         z: MOV         R0.z,  0.0f
+         w: ADD         R127.w, -R1.y,  C1.y      VEC_120
+         t: RCP_e       ____,  C1.x
+      1  y: MUL_e*2     ____,  R1.x,  PS0
+         w: MOV         R0.w,  (0x3F800000, 1.0f).x
+         t: RCP_e       ____,  C1.y
+      2  x: MUL_e*2     ____,  R127.w,  PS1
+         t: ADD         R0.x,  PV1.y, -1.0f
+      3  y: ADD         R0.y,  PV2.x, -1.0f
+         t: RCP_e       ____,  C0.x
+      4  x: MUL_e       ____,  R2.x,  PS3
+         t: RCP_e       ____,  C0.y
+      5  x: MOV         R2.x,  PV4.x
+         z: MUL_e       ____,  R127.x,  PS4
+      6  y: MOV         R2.y,  PV5.z
+02 EXP_DONE: POS0, R0
+03 EXP_DONE: PARAM0, R2.xyzz  NO_BARRIER
+04 ALU: ADDR(48) CNT(1)
+      7  x: NOP         ____
+05 NOP NO_BARRIER
+END_OF_PROGRAM
diff --git a/src/video/wiiu/shaders/wiiu_shaders.c.in b/src/video/wiiu/shaders/wiiu_shaders.c.in
new file mode 100644
index 000000000..de2901e32
--- /dev/null
+++ b/src/video/wiiu/shaders/wiiu_shaders.c.in
@@ -0,0 +1,8 @@
+#include <whb/gfx.h>
+
+WHBGfxShaderGroup wiiuTextureShader;
+int wiiuTextureShaderInit = 0;
+
+WHBGfxShaderGroup wiiuColorShader;
+int wiiuColorShaderInit = 0;
+
diff --git a/src/video/wiiu/wiiu_shaders.c b/src/video/wiiu/wiiu_shaders.c
new file mode 100644
index 000000000..341cb01f2
--- /dev/null
+++ b/src/video/wiiu/wiiu_shaders.c
@@ -0,0 +1,293 @@
+#include <whb/gfx.h>
+
+WHBGfxShaderGroup wiiuTextureShader;
+int wiiuTextureShaderInit = 0;
+
+WHBGfxShaderGroup wiiuColorShader;
+int wiiuColorShaderInit = 0;
+
+unsigned char wiiuColorShaderData[] = {
+  0x47, 0x66, 0x78, 0x32, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x07,
+  0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x4c, 0x4b, 0x7b,
+  0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x01, 0xa8, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
+  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+  0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x01,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
+  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
+  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
+  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
+  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
+  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
+  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
+  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
+  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
+  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
+  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x01, 0x50,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xd0, 0x60, 0x01, 0x34,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x01, 0xd0, 0x60, 0x01, 0x48, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0xca, 0x70, 0x01, 0x58, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x01,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xca, 0x70, 0x01, 0x64,
+  0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x75, 0x5f, 0x76, 0x69, 0x65, 0x77, 0x53, 0x69, 0x7a, 0x65, 0x00, 0x00,
+  0x61, 0x5f, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x00, 0x00,
+  0xd0, 0x60, 0x00, 0xe8, 0xd0, 0x60, 0x01, 0x08, 0xca, 0x70, 0x01, 0x34,
+  0xca, 0x70, 0x01, 0x48, 0x7d, 0x42, 0x4c, 0x4b, 0x00, 0x00, 0x00, 0x28,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x70, 0xd0, 0x60, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x18, 0xd0, 0x60, 0x01, 0x58, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x04, 0xd0, 0x60, 0x01, 0x70, 0x42, 0x4c, 0x4b, 0x7b,
+  0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x01, 0x50, 0x00, 0x00, 0x00, 0x01,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x09,
+  0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0xa0, 0x3c, 0x20, 0x01, 0x00,
+  0x88, 0x06, 0x00, 0x94, 0x00, 0x40, 0x00, 0x00, 0xff, 0x0f, 0x00, 0x94,
+  0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x14, 0xa0, 0x00,
+  0x10, 0x00, 0x00, 0x00, 0xf8, 0x08, 0x00, 0x00, 0x90, 0x0c, 0x40, 0x40,
+  0xf9, 0x00, 0x00, 0x00, 0x90, 0x0c, 0x40, 0x60, 0x00, 0x01, 0x00, 0x80,
+  0x00, 0x33, 0x00, 0x00, 0x01, 0xe0, 0x1f, 0x01, 0x20, 0x01, 0x00, 0x40,
+  0x00, 0x05, 0x00, 0x80, 0x00, 0x33, 0x00, 0x00, 0x00, 0xe0, 0x1f, 0x00,
+  0x20, 0x01, 0x00, 0x00, 0xfe, 0x28, 0x1f, 0x82, 0x10, 0x00, 0x40, 0x00,
+  0xfe, 0x20, 0x9f, 0x82, 0x10, 0x00, 0x40, 0x20, 0x00, 0x00, 0x00, 0x80,
+  0x00, 0x0d, 0x00, 0x00, 0x42, 0x4c, 0x4b, 0x7b, 0x00, 0x00, 0x00, 0x20,
+  0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06,
+  0x00, 0x00, 0x01, 0x34, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x14, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x01,
+  0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x20,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xd0, 0x60, 0x00, 0xe8,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0xca, 0x70, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x0b,
+  0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x75, 0x5f, 0x63, 0x6f, 0x6c, 0x6f, 0x72, 0x00, 0xd0, 0x60, 0x00, 0xbc,
+  0xca, 0x70, 0x00, 0xe8, 0x7d, 0x42, 0x4c, 0x4b, 0x00, 0x00, 0x00, 0x28,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x04, 0xd0, 0x60, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x08, 0xd0, 0x60, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x02, 0xd0, 0x60, 0x01, 0x04, 0x42, 0x4c, 0x4b, 0x7b,
+  0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x01, 0x20, 0x00, 0x00, 0x00, 0x03,
+  0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0xa0,
+  0x00, 0x00, 0x00, 0x00, 0x88, 0x06, 0x20, 0x94, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
+  0x90, 0x0c, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x90, 0x0c, 0x00, 0x20,
+  0x00, 0x09, 0x00, 0x00, 0x90, 0x0c, 0x00, 0x40, 0x00, 0x0d, 0x00, 0x80,
+  0x90, 0x0c, 0x00, 0x60, 0x42, 0x4c, 0x4b, 0x7b, 0x00, 0x00, 0x00, 0x20,
+  0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00
+};
+unsigned char wiiuTextureShaderData[] = {
+  0x47, 0x66, 0x78, 0x32, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x07,
+  0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x4c, 0x4b, 0x7b,
+  0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0x00,
+  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+  0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x02,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xff,
+  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
+  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
+  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
+  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
+  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
+  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
+  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
+  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
+  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
+  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x01, 0x88,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xd0, 0x60, 0x01, 0x34,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x02, 0xd0, 0x60, 0x01, 0x5c, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0xca, 0x70, 0x01, 0x7c, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x01,
+  0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0xca, 0x70, 0x01, 0x88,
+  0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0xca, 0x70, 0x01, 0x94, 0x00, 0x00, 0x00, 0x09,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xca, 0x70, 0x01, 0xa0,
+  0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
+  0x75, 0x5f, 0x76, 0x69, 0x65, 0x77, 0x53, 0x69, 0x7a, 0x65, 0x00, 0x00,
+  0x75, 0x5f, 0x74, 0x65, 0x78, 0x53, 0x69, 0x7a, 0x65, 0x00, 0x00, 0x00,
+  0x61, 0x5f, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x00, 0x00,
+  0x61, 0x5f, 0x74, 0x65, 0x78, 0x43, 0x6f, 0x6f, 0x72, 0x64, 0x49, 0x6e,
+  0x00, 0x00, 0x00, 0x00, 0xd0, 0x60, 0x00, 0xe8, 0xd0, 0x60, 0x01, 0x08,
+  0xca, 0x70, 0x01, 0x34, 0xca, 0x70, 0x01, 0x48, 0xca, 0x70, 0x01, 0x5c,
+  0xca, 0x70, 0x01, 0x6c, 0x7d, 0x42, 0x4c, 0x4b, 0x00, 0x00, 0x00, 0x28,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xb0, 0xd0, 0x60, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x34, 0xd0, 0x60, 0x01, 0x7c, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x06, 0xd0, 0x60, 0x01, 0xb0, 0x42, 0x4c, 0x4b, 0x7b,
+  0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x01, 0x88, 0x00, 0x00, 0x00, 0x01,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x09,
+  0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0xa0, 0x3c, 0x20, 0x00, 0x00,
+  0x88, 0x06, 0x00, 0x94, 0x00, 0x40, 0x01, 0x00, 0x88, 0x04, 0x00, 0x14,
+  0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x14, 0xa0, 0x00,
+  0x10, 0x00, 0xe0, 0x0f, 0xf8, 0x08, 0x00, 0x00, 0x90, 0x0c, 0x00, 0x40,
+  0x01, 0x34, 0xa0, 0x00, 0x10, 0x00, 0xe8, 0x6f, 0x01, 0x01, 0x00, 0x80,
+  0x00, 0x33, 0x00, 0x00, 0x01, 0xe0, 0x9f, 0x00, 0x20, 0x01, 0x00, 0x20,
+  0xf9, 0x00, 0x00, 0x00, 0x90, 0x0c, 0x00, 0x60, 0x01, 0x05, 0x00, 0x80,
+  0x00, 0x33, 0x00, 0x00, 0x7f, 0xec, 0x1f, 0x00, 0x20, 0x01, 0x00, 0x00,
+  0xfe, 0x24, 0x1f, 0x82, 0x10, 0x00, 0x00, 0x00, 0xfe, 0x20, 0x9f, 0x02,
+  0x10, 0x00, 0x00, 0x20, 0x00, 0x01, 0x00, 0x80, 0x00, 0x33, 0x00, 0x00,
+  0x02, 0xe0, 0x1f, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x80,
+  0x00, 0x33, 0x00, 0x00, 0xfe, 0x00, 0x00, 0x00, 0x90, 0x0c, 0x40, 0x00,
+  0x7f, 0xe0, 0x1f, 0x81, 0x00, 0x01, 0x00, 0x40, 0xfe, 0x08, 0x00, 0x80,
+  0x90, 0x0c, 0x40, 0x20, 0x00, 0x00, 0x00, 0x80, 0x00, 0x0d, 0x00, 0x00,
+  0x42, 0x4c, 0x4b, 0x7b, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x01,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x01, 0x54,
+  0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
+  0x00, 0x00, 0x00, 0x02, 0x14, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x10,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x90, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x01, 0xd0, 0x60, 0x00, 0xe8, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x01, 0xd0, 0x60, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0xca, 0x70, 0x01, 0x08, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x01,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xca, 0x70, 0x01, 0x10,
+  0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x75, 0x5f, 0x6d, 0x6f,
+  0x64, 0x00, 0x00, 0x00, 0x73, 0x5f, 0x74, 0x65, 0x78, 0x74, 0x75, 0x72,
+  0x65, 0x00, 0x00, 0x00, 0xd0, 0x60, 0x00, 0xbc, 0xd0, 0x60, 0x00, 0xd4,
+  0xca, 0x70, 0x00, 0xe8, 0xca, 0x70, 0x00, 0xfc, 0x7d, 0x42, 0x4c, 0x4b,
+  0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x1c,
+  0xd0, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0xd0, 0x60, 0x01, 0x08,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xd0, 0x60, 0x01, 0x1c,
+  0x42, 0x4c, 0x4b, 0x7b, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x01,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x01, 0x90,
+  0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0xc0, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0xa0,
+  0x00, 0x00, 0x00, 0x00, 0x88, 0x06, 0x20, 0x94, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x20, 0x00, 0x90, 0x00, 0x00, 0x00, 0x00, 0x04, 0xa0, 0x00,
+  0x90, 0x00, 0x00, 0x20, 0x00, 0x08, 0x20, 0x01, 0x90, 0x00, 0x00, 0x40,
+  0x00, 0x0c, 0xa0, 0x81, 0x90, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
+  0x00, 0x10, 0x0d, 0xf0, 0x00, 0x00, 0x80, 0x10, 0x00, 0x00, 0x00, 0x00,
+  0x42, 0x4c, 0x4b, 0x7b, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x01,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00
+};
diff --git a/src/video/wiiu/wiiu_shaders.h b/src/video/wiiu/wiiu_shaders.h
new file mode 100644
index 000000000..0f9b98ca9
--- /dev/null
+++ b/src/video/wiiu/wiiu_shaders.h
@@ -0,0 +1,83 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 2018-2018 Ash Logan <ash@heyquark.com>
+  Copyright (C) 2018-2018 Roberto Van Eeden <r.r.qwertyuiop.r.r@gmail.com>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#include "../../SDL_internal.h"
+
+#ifndef _WIIU_shaders_h
+#define _WIIU_shaders_h
+
+#include <whb/gfx.h>
+#include <gx2/shaders.h>
+
+extern unsigned char wiiuTextureShaderData[];
+extern unsigned char wiiuColorShaderData[];
+
+extern WHBGfxShaderGroup wiiuTextureShader;
+extern int wiiuTextureShaderInit;
+
+static inline void wiiuInitTextureShader() {
+    if (!wiiuTextureShaderInit) {
+        WHBGfxLoadGFDShaderGroup(&wiiuTextureShader, 0, wiiuTextureShaderData);
+	    WHBGfxInitShaderAttribute(&wiiuTextureShader, "a_position", 0, 0, GX2_ATTRIB_FORMAT_FLOAT_32_32);
+	    WHBGfxInitShaderAttribute(&wiiuTextureShader, "a_texCoordIn", 1, 0, GX2_ATTRIB_FORMAT_FLOAT_32_32);
+        WHBGfxInitFetchShader(&wiiuTextureShader);
+    }
+    wiiuTextureShaderInit++;
+}
+
+static inline void wiiuFreeTextureShader() {
+    if (wiiuTextureShaderInit)
+        if (!--wiiuTextureShaderInit)
+            WHBGfxFreeShaderGroup(&wiiuTextureShader);
+}
+
+static inline void wiiuSetTextureShader() {
+    GX2SetFetchShader(&wiiuTextureShader.fetchShader);
+    GX2SetVertexShader(wiiuTextureShader.vertexShader);
+    GX2SetPixelShader(wiiuTextureShader.pixelShader);
+}
+
+extern WHBGfxShaderGroup wiiuColorShader;
+extern int wiiuColorShaderInit;
+
+static inline void wiiuInitColorShader() {
+    if (!wiiuColorShaderInit) {
+        WHBGfxLoadGFDShaderGroup(&wiiuColorShader, 0, wiiuColorShaderData);
+        WHBGfxInitShaderAttribute(&wiiuColorShader, "a_position", 0, 0, GX2_ATTRIB_FORMAT_FLOAT_32_32);
+        WHBGfxInitFetchShader(&wiiuColorShader);
+    }
+    wiiuColorShaderInit++;
+}
+
+static inline void wiiuFreeColorShader() {
+    if (wiiuColorShaderInit)
+        if (!--wiiuColorShaderInit)
+            WHBGfxFreeShaderGroup(&wiiuColorShader);
+}
+
+static inline void wiiuSetColorShader() {
+    GX2SetFetchShader(&wiiuColorShader.fetchShader);
+    GX2SetVertexShader(wiiuColorShader.vertexShader);
+    GX2SetPixelShader(wiiuColorShader.pixelShader);
+}
+
+#endif //_WIIU_shaders_h
-- 
2.20.1


From 6cee733415054cd29cc529dd1f536c788df002db Mon Sep 17 00:00:00 2001
From: GaryOderNichts <12049776+GaryOderNichts@users.noreply.github.com>
Date: Sat, 13 Aug 2022 22:52:11 +0200
Subject: [PATCH 02/28] wiiu: update drivers for 2.0.22

---
 CMakeLists.txt                                |  46 +-
 Makefile.wiiu                                 |  72 ---
 docs/README-wiiu.md                           |  21 +
 docs/README.md                                |   1 +
 include/SDL_config_wiiu.h                     | 167 -------
 include/SDL_video.h                           |   2 +
 src/audio/wiiu/SDL_wiiuaudio.c                |   8 +-
 src/joystick/wiiu/SDL_wiiujoystick.c          |  78 ++-
 src/joystick/wiiu/SDL_wiiujoystick.h          |  13 -
 src/render/wiiu/SDL_rdraw_wiiu.c              | 444 ------------------
 src/render/wiiu/SDL_render_wiiu.c             |  87 ++--
 src/render/wiiu/SDL_render_wiiu.h             | 196 +++++---
 src/render/wiiu/SDL_rpresent_wiiu.c           |  97 +---
 src/render/wiiu/SDL_rqueue_wiiu.c             | 438 +++++++++++++++++
 src/render/wiiu/SDL_rtexture_wiiu.c           |  56 +--
 src/render/wiiu/SDL_rwindow_wiiu.c            |  27 +-
 src/render/wiiu/SDL_shaders_wiiu.c            |  74 +++
 .../wiiu/SDL_shaders_wiiu.h}                  |  34 +-
 src/render/wiiu/shaders/.gitignore            |   2 +
 src/render/wiiu/shaders/build_shaders.sh      |  17 +
 src/render/wiiu/shaders/colorShader.inc       | 111 +++++
 src/render/wiiu/shaders/colorShader.psh       |   9 +
 src/render/wiiu/shaders/colorShader.vsh       |  40 ++
 src/render/wiiu/shaders/textureShader.inc     | 149 ++++++
 src/render/wiiu/shaders/textureShader.psh     |  23 +
 src/render/wiiu/shaders/textureShader.vsh     |  47 ++
 src/thread/wiiu/SDL_systhread.c               |   4 +-
 src/timer/wiiu/SDL_systimer.c                 |   6 +-
 src/video/SDL_video.c                         |   2 +-
 src/video/wiiu/SDL_wiiuvideo.c                |  19 +-
 src/video/wiiu/SDL_wiiuvideo.h                |  25 +-
 src/video/wiiu/shaders/build_shaders.sh       |  14 -
 src/video/wiiu/shaders/colorShader.frag       |  10 -
 src/video/wiiu/shaders/colorShader.psh        |  14 -
 src/video/wiiu/shaders/colorShader.vert       |  16 -
 src/video/wiiu/shaders/colorShader.vsh        |  27 --
 src/video/wiiu/shaders/textureShader.frag     |  13 -
 src/video/wiiu/shaders/textureShader.psh      |  22 -
 src/video/wiiu/shaders/textureShader.vert     |  27 --
 src/video/wiiu/shaders/textureShader.vsh      |  44 --
 src/video/wiiu/shaders/wiiu_shaders.c.in      |   8 -
 src/video/wiiu/wiiu_shaders.c                 | 293 ------------
 src/video/wiiu/wiiu_shaders.h                 |  83 ----
 43 files changed, 1286 insertions(+), 1600 deletions(-)
 delete mode 100644 Makefile.wiiu
 create mode 100644 docs/README-wiiu.md
 delete mode 100644 include/SDL_config_wiiu.h
 delete mode 100644 src/render/wiiu/SDL_rdraw_wiiu.c
 create mode 100644 src/render/wiiu/SDL_rqueue_wiiu.c
 create mode 100644 src/render/wiiu/SDL_shaders_wiiu.c
 rename src/{thread/wiiu/SDL_systls.c => render/wiiu/SDL_shaders_wiiu.h} (63%)
 create mode 100644 src/render/wiiu/shaders/.gitignore
 create mode 100755 src/render/wiiu/shaders/build_shaders.sh
 create mode 100644 src/render/wiiu/shaders/colorShader.inc
 create mode 100644 src/render/wiiu/shaders/colorShader.psh
 create mode 100644 src/render/wiiu/shaders/colorShader.vsh
 create mode 100644 src/render/wiiu/shaders/textureShader.inc
 create mode 100644 src/render/wiiu/shaders/textureShader.psh
 create mode 100644 src/render/wiiu/shaders/textureShader.vsh
 delete mode 100755 src/video/wiiu/shaders/build_shaders.sh
 delete mode 100644 src/video/wiiu/shaders/colorShader.frag
 delete mode 100644 src/video/wiiu/shaders/colorShader.psh
 delete mode 100644 src/video/wiiu/shaders/colorShader.vert
 delete mode 100644 src/video/wiiu/shaders/colorShader.vsh
 delete mode 100644 src/video/wiiu/shaders/textureShader.frag
 delete mode 100644 src/video/wiiu/shaders/textureShader.psh
 delete mode 100644 src/video/wiiu/shaders/textureShader.vert
 delete mode 100644 src/video/wiiu/shaders/textureShader.vsh
 delete mode 100644 src/video/wiiu/shaders/wiiu_shaders.c.in
 delete mode 100644 src/video/wiiu/wiiu_shaders.c
 delete mode 100644 src/video/wiiu/wiiu_shaders.h

diff --git a/CMakeLists.txt b/CMakeLists.txt
index b38a8bbc1..d1dea4432 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -238,7 +238,7 @@ if(USE_GCC OR USE_CLANG OR USE_INTELCC OR USE_QCC)
 endif()
 
 # Default option knobs
-if(UNIX OR MINGW OR MSYS OR (USE_CLANG AND NOT WINDOWS) OR VITA OR PSP OR PS2 OR N3DS)
+if(UNIX OR MINGW OR MSYS OR (USE_CLANG AND NOT WINDOWS) OR VITA OR PSP OR PS2 OR N3DS OR WIIU)
   set(OPT_DEF_LIBC ON)
 endif()
 
@@ -350,7 +350,7 @@ if(EMSCRIPTEN)
   set(SDL_CPUINFO_ENABLED_BY_DEFAULT OFF)
 endif()
 
-if(VITA OR PSP OR PS2 OR N3DS)
+if(VITA OR PSP OR PS2 OR N3DS OR WIIU)
   set(SDL_SHARED_ENABLED_BY_DEFAULT OFF)
   set(SDL_LOADSO_ENABLED_BY_DEFAULT OFF)
 endif()
@@ -840,7 +840,7 @@ if(SDL_ASSEMBLY)
 
     check_include_file("immintrin.h" HAVE_IMMINTRIN_H)
 
-    if(SDL_ALTIVEC)
+    if(SDL_ALTIVEC AND NOT WIIU)
       set(CMAKE_REQUIRED_FLAGS "-maltivec")
       check_c_source_compiles("
           #include <altivec.h>
@@ -2883,6 +2883,46 @@ elseif(N3DS)
     endif()
     list(APPEND EXTRA_LIBS ${lib})
   endforeach()
+elseif(WIIU)
+  if(SDL_AUDIO)
+    set(SDL_AUDIO_DRIVER_WIIU 1)
+    file(GLOB WIIU_AUDIO_SOURCES ${SDL2_SOURCE_DIR}/src/audio/wiiu/*.c)
+    set(SOURCE_FILES ${SOURCE_FILES} ${WIIU_AUDIO_SOURCES})
+    set(HAVE_SDL_AUDIO TRUE)
+  endif()
+
+  if(SDL_JOYSTICK)
+    set(SDL_JOYSTICK_WIIU 1)
+    file(GLOB WIIU_JOYSTICK_SOURCES ${SDL2_SOURCE_DIR}/src/joystick/wiiu/*.c)
+    set(SOURCE_FILES ${SOURCE_FILES} ${WIIU_JOYSTICK_SOURCES})
+    set(HAVE_SDL_JOYSTICK TRUE)
+  endif()
+
+  if(SDL_THREADS)
+    set(SDL_THREAD_WIIU 1)
+    file(GLOB WIIU_THREAD_SOURCES ${SDL2_SOURCE_DIR}/src/thread/generic/SDL_systls.c ${SDL2_SOURCE_DIR}/src/thread/wiiu/*.c)
+    set(SOURCE_FILES ${SOURCE_FILES} ${WIIU_THREAD_SOURCES})
+    set(HAVE_SDL_THREADS TRUE)
+  endif()
+
+  if(SDL_TIMERS)
+    set(SDL_TIMER_WIIU 1)
+    file(GLOB WIIU_TIMER_SOURCES ${SDL2_SOURCE_DIR}/src/timer/wiiu/*.c)
+    set(SOURCE_FILES ${SOURCE_FILES} ${WIIU_TIMER_SOURCES})
+    set(HAVE_SDL_TIMERS TRUE)
+  endif()
+
+  if(SDL_VIDEO)
+    set(SDL_VIDEO_DRIVER_WIIU 1)
+    set(SDL_VIDEO_RENDER_WIIU 1)
+    file(GLOB WIIU_VIDEO_SOURCES ${SDL2_SOURCE_DIR}/src/video/wiiu/*.c)
+    set(SOURCE_FILES ${SOURCE_FILES} ${WIIU_VIDEO_SOURCES})
+    set(HAVE_SDL_VIDEO TRUE)
+  endif()
+
+  list(APPEND EXTRA_LIBS
+      wut
+    )
 endif()
 
 if(HAVE_VULKAN AND NOT SDL_LOADSO)
diff --git a/Makefile.wiiu b/Makefile.wiiu
deleted file mode 100644
index 7574f36fd..000000000
--- a/Makefile.wiiu
+++ /dev/null
@@ -1,72 +0,0 @@
-BASEDIR	:= $(dir $(firstword $(MAKEFILE_LIST)))
-VPATH	:= $(BASEDIR)
-
-#---------------------------------------------------------------------------------
-# Build options
-#---------------------------------------------------------------------------------
-TARGET  = libSDL2.a
-SOURCES = \
-	src/*.c \
-	src/atomic/*.c \
-	src/audio/*.c \
-	src/audio/wiiu/*.c \
-	src/cpuinfo/*.c \
-	src/events/*.c \
-	src/file/*.c \
-	src/haptic/*.c \
-	src/haptic/dummy/*.c \
-	src/joystick/*.c \
-	src/joystick/wiiu/*.c \
-	src/joystick/dummy/*.c \
-	src/loadso/dummy/*.c \
-	src/power/*.c \
-	src/filesystem/dummy/*.c \
-	src/render/*.c \
-	src/render/wiiu/*.c \
-	src/render/software/*.c \
-	src/stdlib/*.c \
-	src/sensor/*.c \
-	src/thread/*.c \
-	src/thread/wiiu/*.c \
-	src/timer/*.c \
-	src/timer/wiiu/*.c \
-	src/timer/dummy/*.c \
-	src/video/*.c \
-	src/video/wiiu/*.c \
-	src/video/yuv2rgb/*.c \
-	src/video/dummy/*.c
-
-OBJECTS = $(shell echo $(SOURCES) | sed -e 's,\.c,\.o,g')
-INCLUDE = -I./include
-
-#---------------------------------------------------------------------------------
-# Compile flags
-#---------------------------------------------------------------------------------
-CFLAGS		+=	-O2 $(INCLUDE)
-CXXFLAGS	+=	-O2 $(INCLUDE)
-
-#---------------------------------------------------------------------------------
-# Build rules
-#---------------------------------------------------------------------------------
-.PHONY: clean install
-
-$(TARGET): $(OBJECTS)
-
-install: $(TARGET)
-	@echo INSTALL $(TARGET)
-	@mkdir -p $(PORTLIBS)/lib
-	@mkdir -p $(PORTLIBS)/include/SDL2
-	@cp $(TARGET) $(PORTLIBS)/lib/
-	@cp -f ./include/*.h $(PORTLIBS)/include/SDL2/
-
-clean:
-	@echo CLEAN ...
-	@rm -rf $(OBJECTS) $(OBJECTS:.o=.d) $(TARGET)
-
-#---------------------------------------------------------------------------------
-# Toolchain
-#---------------------------------------------------------------------------------
-include $(WUT_ROOT)/share/wut.mk
-LDFLAGS		+=	-L$(DEVKITPRO)/portlibs/ppc/lib
-CFLAGS		+=	-I$(DEVKITPRO)/portlibs/ppc/include
-CXXFLAGS	+=	-I$(DEVKITPRO)/portlibs/ppc/include
diff --git a/docs/README-wiiu.md b/docs/README-wiiu.md
new file mode 100644
index 000000000..3a697c56f
--- /dev/null
+++ b/docs/README-wiiu.md
@@ -0,0 +1,21 @@
+Wii U
+=======
+SDL port for the Nintendo Wii U
+
+Credit to
+* @rw-r-r-0644 and @QuarkTheAwesome for the initial Wii U port
+* @GaryOderNichts
+
+Building
+--------
+To build for the Wii U, make sure you have wut and wiiu-cmake installed and run:
+```
+   /opt/devkitpro/portlibs/wiiu/bin/powerpc-eabi-cmake -S. -Bbuild -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=$DEVKITPRO/portlibs/wiiu
+   cmake --build build
+   cmake --install build
+```
+
+
+Notes
+-----
+* TODO
diff --git a/docs/README.md b/docs/README.md
index 6813f75fb..cd60e860c 100644
--- a/docs/README.md
+++ b/docs/README.md
@@ -49,6 +49,7 @@ More documentation and FAQs are available online at [the wiki](http://wiki.libsd
 - [WinRT](README-winrt.md)
 - [PSVita](README-vita.md)
 - [Nokia N-Gage](README-ngage.md)
+- [Wii U](README-wiiu.md)
 
 If you need help with the library, or just want to discuss SDL related
 issues, you can join the [SDL Discourse](https://discourse.libsdl.org/),
diff --git a/include/SDL_config_wiiu.h b/include/SDL_config_wiiu.h
deleted file mode 100644
index 75be00578..000000000
--- a/include/SDL_config_wiiu.h
+++ /dev/null
@@ -1,167 +0,0 @@
-/*
-  Simple DirectMedia Layer
-  Copyright (C) 1997-2018 Sam Lantinga <slouken@libsdl.org>
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the authors be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-*/
-
-#ifndef SDL_config_wiiu_h_
-#define SDL_config_wiiu_h_
-#define SDL_config_h_
-
-#include "SDL_platform.h"
-
-
-
-#ifdef __GNUC__
-#define HAVE_GCC_SYNC_LOCK_TEST_AND_SET 1
-#endif
-
-#define HAVE_GCC_ATOMICS    1
-
-#define STDC_HEADERS    1
-#define HAVE_ALLOCA_H       1
-#define HAVE_CTYPE_H    1
-#define HAVE_INTTYPES_H 1
-#define HAVE_LIMITS_H   1
-#define HAVE_MATH_H 1
-#define HAVE_SIGNAL_H   1
-#define HAVE_STDINT_H   1
-#define HAVE_STDIO_H    1
-#define HAVE_STRING_H   1
-#define HAVE_SYS_TYPES_H    1
-
-/* C library functions */
-#define HAVE_MALLOC 1
-#define HAVE_CALLOC 1
-#define HAVE_REALLOC    1
-#define HAVE_FREE   1
-#define HAVE_ALLOCA 1
-#define HAVE_GETENV 1
-#define HAVE_SETENV 1
-#define HAVE_PUTENV 1
-#define HAVE_SETENV 1
-#define HAVE_UNSETENV   1
-#define HAVE_QSORT  1
-#define HAVE_ABS    1
-#define HAVE_BCOPY  1
-#define HAVE_MEMSET 1
-#define HAVE_MEMCPY 1
-#define HAVE_MEMMOVE    1
-#define HAVE_MEMCMP 1
-#define HAVE_STRLEN 1
-#define HAVE_STRLCPY    1
-#define HAVE_STRLCAT    1
-#define HAVE_STRCHR 1
-#define HAVE_STRRCHR    1
-#define HAVE_STRSTR 1
-#define HAVE_STRTOL 1
-#define HAVE_STRTOUL    1
-#define HAVE_STRTOLL    1
-#define HAVE_STRTOULL   1
-#define HAVE_STRTOD 1
-#define HAVE_ATOI   1
-#define HAVE_ATOF   1
-#define HAVE_STRCMP 1
-#define HAVE_STRNCMP    1
-#define HAVE_STRCASECMP 1
-#define HAVE_STRNCASECMP 1
-#define HAVE_VSSCANF 1
-#define HAVE_VSNPRINTF  1
-#define HAVE_M_PI   1
-#define HAVE_ACOS   1
-#define HAVE_ACOSF  1
-#define HAVE_ASIN   1
-#define HAVE_ASINF  1
-#define HAVE_ATAN   1
-#define HAVE_ATANF  1
-#define HAVE_ATAN2  1
-#define HAVE_ATAN2F 1
-#define HAVE_CEIL   1
-#define HAVE_CEILF  1
-#define HAVE_COPYSIGN   1
-#define HAVE_COPYSIGNF  1
-#define HAVE_COS    1
-#define HAVE_COSF   1
-#define HAVE_EXP    1
-#define HAVE_FABS   1
-#define HAVE_FABSF  1
-#define HAVE_FLOOR  1
-#define HAVE_FLOORF 1
-#define HAVE_FMOD   1
-#define HAVE_FMODF  1
-#define HAVE_LOG    1
-#define HAVE_LOGF   1
-#define HAVE_LOG10  1
-#define HAVE_LOG10F 1
-#define HAVE_POW    1
-#define HAVE_POWF   1
-#define HAVE_SCALBN 1
-#define HAVE_SCALBNF    1
-#define HAVE_SIN    1
-#define HAVE_SINF   1
-#define HAVE_SQRT   1
-#define HAVE_SQRTF  1
-#define HAVE_TAN    1
-#define HAVE_TANF   1
-#define HAVE_SETJMP 1
-#define HAVE_NANOSLEEP  1
-/* #define HAVE_SYSCONF  1 */
-/* #define HAVE_SIGACTION    1 */
-
-
-/* Wii U isn't that sophisticated */
-#define LACKS_SYS_MMAN_H 1
-
-/* Wii U thread support (src/thread/wiiu/\*.c) */
-#define SDL_THREAD_WIIU        1
-#define SDL_THREADS_DISABLED   0
-
-/* Wii U timer support (src/timer/wiiu/\*.c) */
-#define SDL_TIMER_WIIU        1
-
-/* Wii U joystick driver (src/joystick/wiiu/\*.c) */
-#define SDL_JOYSTICK_WIIU      1
-
-/* Enable the wiiu audio driver (src/audio/wiiu/\*.c) */
-#define SDL_AUDIO_DRIVER_WIIU 1
-
-/* Wii U video dirver */
-#define SDL_VIDEO_DRIVER_WIIU  1
-
-/* Wii U render driver (src/render/wiiu/\*.c) */
-#define SDL_VIDEO_RENDER_WIIU 1
-
-/* There's no battery for the console unit */
-#define SDL_POWER_DISABLED     1
-
-/* !!! FIXME: what does Wii U do for filesystem stuff? */
-#define SDL_FILESYSTEM_DUMMY   1
-
-/* Wii U does have an haptic device, but it's not ported to sdl yet (src/haptic/dummy/\*.c) */
-#define SDL_HAPTIC_DISABLED    1
-
-/* Wii U can't load shared object (src/loadso/dummy/\*.c) */
-#define SDL_LOADSO_DISABLED    1
-
-/* Hack: for some reason some arch defines are missing in the
-   toolchain, so SDL_endian.h will think we're little endian
-   without that */
-#define SDL_BYTEORDER          SDL_BIG_ENDIAN
-
-
-#endif /* SDL_config_wiiu_h_ */
diff --git a/include/SDL_video.h b/include/SDL_video.h
index c8b2d7a0d..a0e403941 100644
--- a/include/SDL_video.h
+++ b/include/SDL_video.h
@@ -124,6 +124,8 @@ typedef enum
     SDL_WINDOW_TOOLTIP          = 0x00040000,   /**< window should be treated as a tooltip */
     SDL_WINDOW_POPUP_MENU       = 0x00080000,   /**< window should be treated as a popup menu */
     SDL_WINDOW_KEYBOARD_GRABBED = 0x00100000,   /**< window has grabbed keyboard input */
+    SDL_WINDOW_WIIU_GAMEPAD_ONLY = 0x01000000,      /**< Wii U: window must be drawn only on the Gamepad */
+    SDL_WINDOW_WIIU_TV_ONLY      = 0x02000000,      /**< Wii U: window must be drawn only on the TV */
     SDL_WINDOW_VULKAN           = 0x10000000,   /**< window usable for Vulkan surface */
     SDL_WINDOW_METAL            = 0x20000000,   /**< window usable for Metal view */
 
diff --git a/src/audio/wiiu/SDL_wiiuaudio.c b/src/audio/wiiu/SDL_wiiuaudio.c
index 12a08857b..763653531 100644
--- a/src/audio/wiiu/SDL_wiiuaudio.c
+++ b/src/audio/wiiu/SDL_wiiuaudio.c
@@ -59,7 +59,7 @@ static SDL_AudioDevice* cb_this;
 /*  +1, but never goes above NUM_BUFFERS */
 #define next_id(id) (id + 1) % NUM_BUFFERS
 
-static int WIIUAUDIO_OpenDevice(_THIS, void* handle, const char* devname, int iscapture) {
+static int WIIUAUDIO_OpenDevice(_THIS, const char* devname) {
     AXVoiceOffsets offs;
     AXVoiceVeData vol = {
         .volume = 0x8000,
@@ -370,7 +370,7 @@ static void WIIUAUDIO_ThreadInit(_THIS) {
     OSSetThreadPriority(currentThread, priority);
 }
 
-static int WIIUAUDIO_Init(SDL_AudioDriverImpl* impl) {
+static SDL_bool WIIUAUDIO_Init(SDL_AudioDriverImpl* impl) {
     impl->OpenDevice = WIIUAUDIO_OpenDevice;
     impl->PlayDevice = WIIUAUDIO_PlayDevice;
     impl->WaitDevice = WIIUAUDIO_WaitDevice;
@@ -378,9 +378,9 @@ static int WIIUAUDIO_Init(SDL_AudioDriverImpl* impl) {
     impl->CloseDevice = WIIUAUDIO_CloseDevice;
     impl->ThreadInit = WIIUAUDIO_ThreadInit;
 
-    impl->OnlyHasDefaultOutputDevice = 1;
+    impl->OnlyHasDefaultOutputDevice = SDL_TRUE;
 
-    return 1;
+    return SDL_TRUE;
 }
 
 AudioBootStrap WIIUAUDIO_bootstrap = {
diff --git a/src/joystick/wiiu/SDL_wiiujoystick.c b/src/joystick/wiiu/SDL_wiiujoystick.c
index d345b24e7..4a7dfcc9f 100644
--- a/src/joystick/wiiu/SDL_wiiujoystick.c
+++ b/src/joystick/wiiu/SDL_wiiujoystick.c
@@ -46,6 +46,26 @@ static int deviceMap[MAX_CONTROLLERS];
 static SDL_JoystickID instanceMap[MAX_CONTROLLERS];
 static WPADExtensionType lastKnownExts[WIIU_NUM_WPADS];
 
+static int WIIU_JoystickInit(void);
+static int WIIU_JoystickGetCount(void);
+static void WIIU_JoystickDetect(void);
+static const char *WIIU_JoystickGetDeviceName(int device_index);
+static int WIIU_JoystickGetDevicePlayerIndex(int device_index);
+static void WIIU_JoystickSetDevicePlayerIndex(int device_index, int player_index);
+static SDL_JoystickGUID WIIU_JoystickGetDeviceGUID(int device_index);
+static SDL_JoystickID WIIU_JoystickGetDeviceInstanceID(int device_index);
+static int WIIU_JoystickOpen(SDL_Joystick *joystick, int device_index);
+static int WIIU_JoystickRumble(SDL_Joystick *joystick, Uint16 low_frequency_rumble, Uint16 high_frequency_rumble);
+static int WIIU_JoystickRumbleTriggers(SDL_Joystick *joystick, Uint16 left_rumble, Uint16 right_rumble);
+static Uint32 WIIU_JoystickGetCapabilities(SDL_Joystick *joystick);
+static int WIIU_JoystickSetLED(SDL_Joystick *joystick, Uint8 red, Uint8 green, Uint8 blue);
+static int WIIU_JoystickSendEffect(SDL_Joystick *joystick, const void *data, int size);
+static int WIIU_JoystickSetSensorsEnabled(SDL_Joystick *joystick, SDL_bool enabled);
+static void WIIU_JoystickUpdate(SDL_Joystick *joystick);
+static void WIIU_JoystickClose(SDL_Joystick *joystick);
+static void WIIU_JoystickQuit(void);
+static SDL_bool WIIU_JoystickGetGamepadMapping(int device_index, SDL_GamepadMapping * out);
+
 static int WIIU_GetDeviceForIndex(int device_index) {
 	return deviceMap[device_index];
 }
@@ -237,6 +257,10 @@ static int WIIU_JoystickGetDevicePlayerIndex(int device_index)
 
 }
 
+static void WIIU_JoystickSetDevicePlayerIndex(int device_index, int player_index)
+{
+}
+
 /* Function to return the stable GUID for a plugged in device */
 static SDL_JoystickGUID WIIU_JoystickGetDeviceGUID(int device_index)
 {
@@ -264,7 +288,7 @@ static int WIIU_JoystickOpen(SDL_Joystick *joystick, int device_index)
 	int wiiu_device = WIIU_GetDeviceForIndex(device_index);
 	switch (wiiu_device) {
 		case WIIU_DEVICE_GAMEPAD: {
-			SDL_AddTouch(0, "WiiU Gamepad Touchscreen");
+			SDL_AddTouch(0, SDL_TOUCH_DEVICE_DIRECT, "WiiU Gamepad Touchscreen");
 			joystick->nbuttons = SIZEOF_ARR(vpad_button_map);
 			joystick->naxes = 4;
 			joystick->nhats = 0;
@@ -323,12 +347,43 @@ static int WIIU_JoystickOpen(SDL_Joystick *joystick, int device_index)
 }
 
 /* Rumble functionality */
-static int WIIU_JoystickRumble(SDL_Joystick * joystick, Uint16 low_frequency_rumble, Uint16 high_frequency_rumble, Uint32 duration_ms)
+static int WIIU_JoystickRumble(SDL_Joystick *joystick, Uint16 low_frequency_rumble, Uint16 high_frequency_rumble)
 {
 	/* TODO */
 	return SDL_Unsupported();
 }
 
+static int WIIU_JoystickRumbleTriggers(SDL_Joystick *joystick, Uint16 left_rumble, Uint16 right_rumble)
+{
+	return SDL_Unsupported();
+}
+
+/* Capability detection */
+static Uint32 WIIU_JoystickGetCapabilities(SDL_Joystick *joystick)
+{
+	/* TODO implement supported capabilities */
+	return 0;
+}
+
+/* LED functionality */
+static int WIIU_JoystickSetLED(SDL_Joystick *joystick, Uint8 red, Uint8 green, Uint8 blue)
+{
+	return SDL_Unsupported();
+}
+
+/* General effects */
+static int WIIU_JoystickSendEffect(SDL_Joystick *joystick, const void *data, int size)
+{
+	return SDL_Unsupported();
+}
+
+/* Sensor functionality */
+static int WIIU_JoystickSetSensorsEnabled(SDL_Joystick *joystick, SDL_bool enabled)
+{
+	return SDL_Unsupported();
+}
+
+
 /* Function to update the state of a joystick - called as a device poll.
  * This function shouldn't update the joystick structure directly,
  * but instead should call SDL_PrivateJoystick*() to deliver events
@@ -365,12 +420,12 @@ static void WIIU_JoystickUpdate(SDL_Joystick *joystick)
 		VPADGetTPCalibratedPoint(VPAD_CHAN_0, &tpdata, &vpad.tpNormal);
 		if (tpdata.touched) {
 			/* Send an initial touch */
-			SDL_SendTouch(0, 0, SDL_TRUE,
+			SDL_SendTouch(0, 0, NULL, SDL_TRUE,
 					(float) tpdata.x / 1280.0f,
 					(float) tpdata.y / 720.0f, 1);
 
 			/* Always send the motion */
-			SDL_SendTouchMotion(0, 0,
+			SDL_SendTouchMotion(0, 0, NULL,
 					(float) tpdata.x / 1280.0f,
 					(float) tpdata.y / 720.0f, 1);
 
@@ -380,7 +435,7 @@ static void WIIU_JoystickUpdate(SDL_Joystick *joystick)
 			last_touched = 1;
 		} else if (last_touched) {
 			/* Finger released from screen */
-			SDL_SendTouch(0, 0, SDL_FALSE,
+			SDL_SendTouch(0, 0, NULL, SDL_FALSE,
 					(float) last_touch_x / 1280.0f,
 					(float) last_touch_y / 720.0f, 1);
 			last_touched = 0;
@@ -512,6 +567,12 @@ static void WIIU_JoystickQuit(void)
 {
 }
 
+/* Function to get the autodetected controller mapping; returns false if there isn't any. */
+static SDL_bool WIIU_JoystickGetGamepadMapping(int device_index, SDL_GamepadMapping * out)
+{
+	return SDL_FALSE;
+}
+
 SDL_JoystickDriver SDL_WIIU_JoystickDriver =
 {
 	WIIU_JoystickInit,
@@ -519,13 +580,20 @@ SDL_JoystickDriver SDL_WIIU_JoystickDriver =
 	WIIU_JoystickDetect,
 	WIIU_JoystickGetDeviceName,
 	WIIU_JoystickGetDevicePlayerIndex,
+	WIIU_JoystickSetDevicePlayerIndex,
 	WIIU_JoystickGetDeviceGUID,
 	WIIU_JoystickGetDeviceInstanceID,
 	WIIU_JoystickOpen,
 	WIIU_JoystickRumble,
+	WIIU_JoystickRumbleTriggers,
+	WIIU_JoystickGetCapabilities,
+	WIIU_JoystickSetLED,
+	WIIU_JoystickSendEffect,
+	WIIU_JoystickSetSensorsEnabled,
 	WIIU_JoystickUpdate,
 	WIIU_JoystickClose,
 	WIIU_JoystickQuit,
+	WIIU_JoystickGetGamepadMapping,
 };
 
 #endif
diff --git a/src/joystick/wiiu/SDL_wiiujoystick.h b/src/joystick/wiiu/SDL_wiiujoystick.h
index 64fcf50e5..7e26ef22e 100644
--- a/src/joystick/wiiu/SDL_wiiujoystick.h
+++ b/src/joystick/wiiu/SDL_wiiujoystick.h
@@ -77,19 +77,6 @@ static WPADProButton pro_button_map[] = {
     WPAD_PRO_STICK_R_EMULATION_RIGHT, WPAD_PRO_STICK_R_EMULATION_DOWN
 };
 
-static int WIIU_JoystickInit(void);
-static int WIIU_JoystickGetCount(void);
-static void WIIU_JoystickDetect(void);
-static const char *WIIU_JoystickGetDeviceName(int device_index);
-static int WIIU_JoystickGetDevicePlayerIndex(int device_index);
-static SDL_JoystickGUID WIIU_JoystickGetDeviceGUID(int device_index);
-static SDL_JoystickID WIIU_JoystickGetDeviceInstanceID(int device_index);
-static int WIIU_JoystickOpen(SDL_Joystick *joystick, int device_index);
-static int WIIU_JoystickRumble(SDL_Joystick * joystick, Uint16 low_frequency_rumble, Uint16 high_frequency_rumble, Uint32 duration_ms);
-static void WIIU_JoystickUpdate(SDL_Joystick *joystick);
-static void WIIU_JoystickClose(SDL_Joystick *joystick);
-static void WIIU_JoystickQuit(void);
-
 #define RETURN_WPAD_NAME(chan, ext) { \
     switch (ext) { \
     case WPAD_EXT_CORE: \
diff --git a/src/render/wiiu/SDL_rdraw_wiiu.c b/src/render/wiiu/SDL_rdraw_wiiu.c
deleted file mode 100644
index 78fbee4a2..000000000
--- a/src/render/wiiu/SDL_rdraw_wiiu.c
+++ /dev/null
@@ -1,444 +0,0 @@
-/*
-  Simple DirectMedia Layer
-  Copyright (C) 2018-2019 Ash Logan <ash@heyquark.com>
-  Copyright (C) 2018-2019 Roberto Van Eeden <r.r.qwertyuiop.r.r@gmail.com>
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the authors be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-*/
-#include "../../SDL_internal.h"
-
-#if SDL_VIDEO_RENDER_WIIU
-
-#include "../../video/wiiu/SDL_wiiuvideo.h"
-#include "../../video/wiiu/wiiu_shaders.h"
-#include "../SDL_sysrender.h"
-#include "SDL_hints.h"
-#include "SDL_render_wiiu.h"
-
-#include <gx2/texture.h>
-#include <gx2/draw.h>
-#include <gx2/registers.h>
-#include <gx2/sampler.h>
-#include <gx2/state.h>
-#include <gx2/clear.h>
-#include <gx2/mem.h>
-#include <gx2/event.h>
-#include <gx2r/surface.h>
-#include <gx2r/buffer.h>
-#include <gx2r/draw.h>
-
-#include <stdio.h>
-#include <stdarg.h>
-#include <stdlib.h>
-#include <string.h>
-#include <math.h>
-
-static void WIIU_SDL_SetGX2BlendMode(SDL_BlendMode mode);
-
-int WIIU_SDL_RenderCopy(SDL_Renderer * renderer, SDL_Texture * texture,
-                        const SDL_Rect * srcrect, const SDL_FRect * dstrect)
-{
-    WIIU_RenderData *data = (WIIU_RenderData *) renderer->driverdata;
-    WIIU_TextureData *tdata = (WIIU_TextureData *) texture->driverdata;
-    GX2RBuffer *a_position, *a_texCoord;
-    WIIUVec2 *a_position_vals, *a_texCoord_vals;
-    float x_min, y_min, x_max, y_max;
-
-    if (texture->access & SDL_TEXTUREACCESS_TARGET) {
-        GX2RInvalidateSurface(&tdata->texture.surface, 0, 0);
-    }
-
-    /* Update texture rendering state */
-    WIIU_TextureStartRendering(data, tdata);
-
-    /* Allocate attribute buffers */
-    a_position = WIIU_AllocRenderData(data, (GX2RBuffer) {
-        .flags =
-            GX2R_RESOURCE_BIND_VERTEX_BUFFER |
-            GX2R_RESOURCE_USAGE_CPU_WRITE,
-        .elemSize = sizeof(WIIUVec2), // float x/y for each corner
-        .elemCount = 4, // 4 corners
-    });
-    a_texCoord = WIIU_AllocRenderData(data, (GX2RBuffer) {
-        .flags =
-            GX2R_RESOURCE_BIND_VERTEX_BUFFER |
-            GX2R_RESOURCE_USAGE_CPU_WRITE,
-        .elemSize = sizeof(WIIUVec2),
-        .elemCount = 4, // 4 corners
-    });
-
-    /* Compute vertex points */
-    x_min = renderer->viewport.x + dstrect->x;
-    y_min = renderer->viewport.y + dstrect->y;
-    x_max = renderer->viewport.x + dstrect->x + dstrect->w;
-    y_max = renderer->viewport.y + dstrect->y + dstrect->h;
-
-    /* Save them */
-    a_position_vals = GX2RLockBufferEx(a_position, 0);
-    a_position_vals[0] = (WIIUVec2){.x = x_min, .y = y_max};
-    a_position_vals[1] = (WIIUVec2){.x = x_max, .y = y_max};
-    a_position_vals[2] = (WIIUVec2){.x = x_max, .y = y_min};
-    a_position_vals[3] = (WIIUVec2){.x = x_min, .y = y_min};
-    GX2RUnlockBufferEx(a_position, 0);
-
-    /* Compute texture coords */
-    a_texCoord_vals = GX2RLockBufferEx(a_texCoord, 0);
-    a_texCoord_vals[0] = (WIIUVec2) {
-        .x = srcrect->x,
-        .y = texture->h - srcrect->y - srcrect->h,
-    };
-    a_texCoord_vals[1] = (WIIUVec2) {
-        .x = srcrect->x + srcrect->w,
-        .y = texture->h - srcrect->y - srcrect->h,
-    };
-    a_texCoord_vals[2] = (WIIUVec2) {
-        .x = srcrect->x + srcrect->w,
-        .y = texture->h - srcrect->y,
-    };
-    a_texCoord_vals[3] = (WIIUVec2) {
-        .x = srcrect->x,
-        .y = texture->h - srcrect->y,
-    };
-    GX2RUnlockBufferEx(a_texCoord, 0);
-
-    /* Render */
-    wiiuSetTextureShader();
-    GX2SetPixelTexture(&tdata->texture, 0);
-    GX2SetPixelSampler(&tdata->sampler, 0);
-    GX2RSetAttributeBuffer(a_position, 0, a_position->elemSize, 0);
-    GX2RSetAttributeBuffer(a_texCoord, 1, a_texCoord->elemSize, 0);
-    GX2SetVertexUniformReg(wiiuTextureShader.vertexShader->uniformVars[0].offset, 4, (uint32_t *)&data->u_viewSize);
-    GX2SetVertexUniformReg(wiiuTextureShader.vertexShader->uniformVars[1].offset, 4, (uint32_t *)&tdata->u_texSize);
-    GX2SetPixelUniformReg(wiiuTextureShader.pixelShader->uniformVars[0].offset, 4, (uint32_t *)&tdata->u_mod);
-    WIIU_SDL_SetGX2BlendMode(texture->blendMode);
-    GX2DrawEx(GX2_PRIMITIVE_MODE_QUADS, 4, 0, 1);
-
-    return 0;
-}
-
-
-int WIIU_SDL_RenderCopyEx(SDL_Renderer * renderer, SDL_Texture * texture,
-                          const SDL_Rect * srcrect, const SDL_FRect * dstrect,
-                          const double angle, const SDL_FPoint * center, const SDL_RendererFlip flip)
-{
-    WIIU_RenderData *data = (WIIU_RenderData *) renderer->driverdata;
-    WIIU_TextureData *tdata = (WIIU_TextureData *) texture->driverdata;
-    GX2RBuffer *a_position, *a_texCoord;
-    WIIUVec2 *a_position_vals, *a_texCoord_vals;
-
-    /* Compute real vertex points */
-    float x_min = renderer->viewport.x + dstrect->x;
-    float y_min = renderer->viewport.y + dstrect->y;
-    float x_max = x_min + dstrect->w;
-    float y_max = y_min + dstrect->h;
-    float cx = x_min + center->x;
-    float cy = y_min + center->y;
-    double r = angle * (M_PI / 180.0);
-    WIIUVec2 rvb[4] = {
-        {
-            .x = (flip & SDL_FLIP_HORIZONTAL) ? x_max : x_min,
-            .y = (flip & SDL_FLIP_VERTICAL) ? y_min : y_max,
-        },
-        {
-            .x = (flip & SDL_FLIP_HORIZONTAL) ? x_min : x_max,
-            .y = (flip & SDL_FLIP_VERTICAL) ? y_min : y_max,
-        },
-        {
-            .x = (flip & SDL_FLIP_HORIZONTAL) ? x_min : x_max,
-            .y = (flip & SDL_FLIP_VERTICAL) ? y_max : y_min,
-        },
-        {
-            .x = (flip & SDL_FLIP_HORIZONTAL) ? x_max : x_min,
-            .y = (flip & SDL_FLIP_VERTICAL) ? y_max : y_min,
-        },
-    };
-
-    if (texture->access & SDL_TEXTUREACCESS_TARGET) {
-        GX2RInvalidateSurface(&tdata->texture.surface, 0, 0);
-    }
-
-    /* Update texture rendering state */
-    WIIU_TextureStartRendering(data, tdata);
-
-    /* Allocate attribute buffers */
-    a_position = WIIU_AllocRenderData(data, (GX2RBuffer) {
-        .flags =
-            GX2R_RESOURCE_BIND_VERTEX_BUFFER |
-            GX2R_RESOURCE_USAGE_CPU_WRITE,
-        .elemSize = sizeof(WIIUVec2), // float x/y for each corner
-        .elemCount = 4, // 4 corners
-    });
-    a_texCoord = WIIU_AllocRenderData(data, (GX2RBuffer) {
-        .flags =
-            GX2R_RESOURCE_BIND_VERTEX_BUFFER |
-            GX2R_RESOURCE_USAGE_CPU_WRITE,
-        .elemSize = sizeof(WIIUVec2), // float x/y for each corner
-        .elemCount = 4, // 4 corners
-    });
-
-    /* Save vertex points */
-    a_position_vals = GX2RLockBufferEx(a_position, 0);
-    for (int i = 0; i < 4; i++) {
-        a_position_vals[i] = (WIIUVec2) {
-            .x = cx + (SDL_cos(r) * (rvb[i].x - cx) - SDL_sin(r) * (rvb[i].y - cy)),
-            .y = cy + (SDL_cos(r) * (rvb[i].y - cy) + SDL_sin(r) * (rvb[i].x - cx)),
-        };
-    }
-    GX2RUnlockBufferEx(a_position, 0);
-
-    /* Compute texture coords */
-    a_texCoord_vals = GX2RLockBufferEx(a_texCoord, 0);
-    a_texCoord_vals[0] = (WIIUVec2) {
-        .x = srcrect->x,
-        .y = texture->h - srcrect->y - srcrect->h,
-    };
-    a_texCoord_vals[1] = (WIIUVec2) {
-        .x = srcrect->x + srcrect->w,
-        .y = texture->h - srcrect->y - srcrect->h,
-    };
-    a_texCoord_vals[2] = (WIIUVec2) {
-        .x = srcrect->x + srcrect->w,
-        .y = texture->h - srcrect->y,
-    };
-    a_texCoord_vals[3] = (WIIUVec2) {
-        .x = srcrect->x,
-        .y = texture->h - srcrect->y,
-    };
-    GX2RUnlockBufferEx(a_texCoord, 0);
-
-    /* Render */
-    wiiuSetTextureShader();
-    GX2SetPixelTexture(&tdata->texture, 0);
-    GX2SetPixelSampler(&tdata->sampler, 0);
-    GX2RSetAttributeBuffer(a_position, 0, a_position->elemSize, 0);
-    GX2RSetAttributeBuffer(a_texCoord, 1, a_texCoord->elemSize, 0);
-    GX2SetVertexUniformReg(wiiuTextureShader.vertexShader->uniformVars[0].offset, 4, (uint32_t *)&data->u_viewSize);
-    GX2SetVertexUniformReg(wiiuTextureShader.vertexShader->uniformVars[1].offset, 4, (uint32_t *)&tdata->u_texSize);
-    GX2SetPixelUniformReg(wiiuTextureShader.pixelShader->uniformVars[0].offset, 4, (uint32_t *)&tdata->u_mod);
-    WIIU_SDL_SetGX2BlendMode(texture->blendMode);
-    GX2DrawEx(GX2_PRIMITIVE_MODE_QUADS, 4, 0, 1);
-
-    return 0;
-}
-
-int WIIU_SDL_RenderDrawPoints(SDL_Renderer * renderer, const SDL_FPoint * points,
-                              int count)
-{
-    WIIU_RenderData *data = (WIIU_RenderData *) renderer->driverdata;
-    GX2RBuffer *a_position;
-    WIIUVec2 *a_position_vals;
-
-    /* Compute colours */
-    WIIUVec4 u_colour = {
-        .r = (float)renderer->r / 255.0f,
-        .g = (float)renderer->g / 255.0f,
-        .b = (float)renderer->b / 255.0f,
-        .a = (float)renderer->a / 255.0f,
-    };
-
-    /* Allocate attribute buffers */
-    a_position = WIIU_AllocRenderData(data, (GX2RBuffer) {
-        .flags =
-            GX2R_RESOURCE_BIND_VERTEX_BUFFER |
-            GX2R_RESOURCE_USAGE_CPU_WRITE,
-        .elemSize = sizeof(WIIUVec2), /* float x/y for each point */
-        .elemCount = count,
-    });
-
-    /* Compute vertex positions */
-    a_position_vals = GX2RLockBufferEx(a_position, 0);
-    for (int i = 0; i < count; ++i) {
-        a_position_vals[i] = (WIIUVec2) {
-            .x = (float)renderer->viewport.x + points[i].x,
-            .y = (float)renderer->viewport.y + points[i].y,
-        };
-    }
-    GX2RUnlockBufferEx(a_position, 0);
-
-    /* Render points */
-    wiiuSetColorShader();
-    GX2RSetAttributeBuffer(a_position, 0, a_position->elemSize, 0);
-    GX2SetVertexUniformReg(wiiuColorShader.vertexShader->uniformVars[0].offset, 4, (uint32_t *)&data->u_viewSize);
-    GX2SetPixelUniformReg(wiiuColorShader.pixelShader->uniformVars[0].offset, 4, (uint32_t *)&u_colour);
-    WIIU_SDL_SetGX2BlendMode(renderer->blendMode);
-    GX2DrawEx(GX2_PRIMITIVE_MODE_POINTS, count, 0, 1);
-
-    return 0;
-}
-
-
-int WIIU_SDL_RenderDrawLines(SDL_Renderer * renderer, const SDL_FPoint * points,
-                             int count)
-{
-    WIIU_RenderData *data = (WIIU_RenderData *) renderer->driverdata;
-    GX2RBuffer *a_position;
-    WIIUVec2 *a_position_vals;
-
-    /* Compute colours */
-    WIIUVec4 u_colour = {
-        .r = (float)renderer->r / 255.0f,
-        .g = (float)renderer->g / 255.0f,
-        .b = (float)renderer->b / 255.0f,
-        .a = (float)renderer->a / 255.0f,
-    };
-
-    /*  Allocate attribute buffers */
-    a_position = WIIU_AllocRenderData(data, (GX2RBuffer) {
-        .flags =
-            GX2R_RESOURCE_BIND_VERTEX_BUFFER |
-            GX2R_RESOURCE_USAGE_CPU_WRITE,
-        .elemSize = sizeof(WIIUVec2), /* float x/y for each point */
-        .elemCount = count,
-    });
-
-    /* Compute vertex positions */
-    a_position_vals = GX2RLockBufferEx(a_position, 0);
-    for (int i = 0; i < count; ++i) {
-        a_position_vals[i] = (WIIUVec2) {
-            .x = (float)renderer->viewport.x + points[i].x,
-            .y = (float)renderer->viewport.y + points[i].y,
-        };
-    }
-    GX2RUnlockBufferEx(a_position, 0);
-
-    /* Render lines */
-    wiiuSetColorShader();
-    GX2RSetAttributeBuffer(a_position, 0, a_position->elemSize, 0);
-    GX2SetVertexUniformReg(wiiuColorShader.vertexShader->uniformVars[0].offset, 4, (uint32_t *)&data->u_viewSize);
-    GX2SetPixelUniformReg(wiiuColorShader.pixelShader->uniformVars[0].offset, 4, (uint32_t *)&u_colour);
-    WIIU_SDL_SetGX2BlendMode(renderer->blendMode);
-    GX2DrawEx(GX2_PRIMITIVE_MODE_LINE_STRIP, count, 0, 1);
-
-    return 0;
-}
-
-int WIIU_SDL_RenderFillRects(SDL_Renderer * renderer, const SDL_FRect * rects, int count)
-{
-    WIIU_RenderData *data = (WIIU_RenderData *) renderer->driverdata;
-    GX2RBuffer *a_position;
-    WIIUVec2 *a_position_vals;
-
-    /* Compute colours */
-    WIIUVec4 u_colour = {
-        .r = (float)renderer->r / 255.0f,
-        .g = (float)renderer->g / 255.0f,
-        .b = (float)renderer->b / 255.0f,
-        .a = (float)renderer->a / 255.0f,
-    };
-
-    /* Compute vertex pos */
-    float vx = (float)renderer->viewport.x;
-    float vy = (float)renderer->viewport.y;
-
-    /*  Allocate attribute buffers */
-    a_position = WIIU_AllocRenderData(data, (GX2RBuffer) {
-        .flags =
-            GX2R_RESOURCE_BIND_VERTEX_BUFFER |
-            GX2R_RESOURCE_USAGE_CPU_WRITE,
-        .elemSize = sizeof(WIIUVec2), // x/y float per corner
-        .elemCount = 4 * count, // 4 corners per square
-    });
-
-    /* Compute vertex positions */
-    a_position_vals = GX2RLockBufferEx(a_position, 0);
-    for (int i = 0; i < count; ++i) {
-        a_position_vals[i*4 + 0] = (WIIUVec2) {
-            .x = vx + rects[i].x,
-            .y = vy + rects[i].y,
-        };
-        a_position_vals[i*4 + 1] = (WIIUVec2) {
-            .x = vx + rects[i].x + rects[i].w,
-            .y = vy + rects[i].y,
-        };
-        a_position_vals[i*4 + 2] = (WIIUVec2) {
-            .x = vx + rects[i].x + rects[i].w,
-            .y = vy + rects[i].y + rects[i].h,
-        };
-        a_position_vals[i*4 + 3] = (WIIUVec2) {
-            .x = vx + rects[i].x,
-            .y = vy + rects[i].y + rects[i].h,
-        };
-    }
-    GX2RUnlockBufferEx(a_position, 0);
-
-    /* Render rects */
-    wiiuSetColorShader();
-    GX2RSetAttributeBuffer(a_position, 0, a_position->elemSize, 0);
-    GX2SetVertexUniformReg(wiiuColorShader.vertexShader->uniformVars[0].offset, 4, (uint32_t *)&data->u_viewSize);
-    GX2SetPixelUniformReg(wiiuColorShader.pixelShader->uniformVars[0].offset, 4, (uint32_t *)&u_colour);
-    WIIU_SDL_SetGX2BlendMode(renderer->blendMode);
-    GX2DrawEx(GX2_PRIMITIVE_MODE_QUADS, 4 * count, 0, 1);
-
-    return 0;
-}
-
-int WIIU_SDL_RenderClear(SDL_Renderer * renderer)
-{
-    WIIU_RenderData* data = (WIIU_RenderData*) renderer->driverdata;
-    SDL_Texture* target = WIIU_GetRenderTarget(renderer);
-    WIIU_TextureData* tdata = (WIIU_TextureData*) target->driverdata;
-
-    GX2ClearColor(&tdata->cbuf,
-                  (float)renderer->r / 255.0f,
-                  (float)renderer->g / 255.0f,
-                  (float)renderer->b / 255.0f,
-                  (float)renderer->a / 255.0f);
-
-    /* Restore SDL context state */
-    GX2SetContextState(data->ctx);
-
-    return 0;
-}
-
-static void WIIU_SDL_SetGX2BlendMode(SDL_BlendMode mode)
-{
-    if (mode == SDL_BLENDMODE_NONE) {
-        GX2SetColorControl(GX2_LOGIC_OP_COPY, 0x00, FALSE, TRUE);
-    } else if (mode == SDL_BLENDMODE_BLEND) {
-        GX2SetColorControl(GX2_LOGIC_OP_COPY, 0xFF, FALSE, TRUE);
-        GX2SetBlendControl(GX2_RENDER_TARGET_0,
-            /* RGB = [srcRGB * srcA] + [dstRGB * (1-srcA)] */
-            GX2_BLEND_MODE_SRC_ALPHA, GX2_BLEND_MODE_INV_SRC_ALPHA,
-            GX2_BLEND_COMBINE_MODE_ADD,
-            TRUE,
-            /* A = [srcA * 1] + [dstA * (1-srcA)] */
-            GX2_BLEND_MODE_ONE, GX2_BLEND_MODE_INV_SRC_ALPHA,
-            GX2_BLEND_COMBINE_MODE_ADD);
-    } else if (mode == SDL_BLENDMODE_ADD) {
-        GX2SetColorControl(GX2_LOGIC_OP_COPY, 0xFF, FALSE, TRUE);
-        GX2SetBlendControl(GX2_RENDER_TARGET_0,
-            /* RGB = [srcRGB * srcA] + [dstRGB * 1] */
-            GX2_BLEND_MODE_SRC_ALPHA, GX2_BLEND_MODE_ONE,
-            GX2_BLEND_COMBINE_MODE_ADD,
-            TRUE,
-            /* A = [srcA * 0] + [dstA * 1] */
-            GX2_BLEND_MODE_ZERO, GX2_BLEND_MODE_ONE,
-            GX2_BLEND_COMBINE_MODE_ADD);
-    } else if (mode == SDL_BLENDMODE_MOD) {
-        GX2SetColorControl(GX2_LOGIC_OP_COPY, 0xFF, FALSE, TRUE);
-        GX2SetBlendControl(GX2_RENDER_TARGET_0,
-            /* RGB = [srcRGB * dstRGB] + [dstRGB * 0]) */
-            GX2_BLEND_MODE_DST_COLOR, GX2_BLEND_MODE_ZERO,
-            GX2_BLEND_COMBINE_MODE_ADD,
-            TRUE,
-            /* A = [srcA * 0] + [dstA * 1] */
-            GX2_BLEND_MODE_ZERO, GX2_BLEND_MODE_ONE,
-            GX2_BLEND_COMBINE_MODE_ADD);
-    }
-}
-
-#endif /* SDL_VIDEO_RENDER_WIIU */
diff --git a/src/render/wiiu/SDL_render_wiiu.c b/src/render/wiiu/SDL_render_wiiu.c
index 633c26b38..06f2917ad 100644
--- a/src/render/wiiu/SDL_render_wiiu.c
+++ b/src/render/wiiu/SDL_render_wiiu.c
@@ -2,6 +2,7 @@
   Simple DirectMedia Layer
   Copyright (C) 2018-2019 Ash Logan <ash@heyquark.com>
   Copyright (C) 2018-2019 Roberto Van Eeden <r.r.qwertyuiop.r.r@gmail.com>
+  Copyright (C) 2022 GaryOderNichts <garyodernichts@gmail.com>
 
   This software is provided 'as-is', without any express or implied
   warranty.  In no event will the authors be held liable for any damages
@@ -23,9 +24,6 @@
 
 #if SDL_VIDEO_RENDER_WIIU
 
-#include "../../video/wiiu/SDL_wiiuvideo.h"
-#include "../../video/wiiu/wiiu_shaders.h"
-#include "../SDL_sysrender.h"
 #include "SDL_hints.h"
 #include "SDL_render_wiiu.h"
 
@@ -35,8 +33,6 @@
 
 #include <malloc.h>
 
-SDL_RenderDriver WIIU_RenderDriver;
-
 SDL_Renderer *WIIU_SDL_CreateRenderer(SDL_Window * window, Uint32 flags)
 {
     SDL_Renderer *renderer;
@@ -50,29 +46,26 @@ SDL_Renderer *WIIU_SDL_CreateRenderer(SDL_Window * window, Uint32 flags)
 
     data = (WIIU_RenderData *) SDL_calloc(1, sizeof(*data));
     if (!data) {
-        WIIU_SDL_DestroyRenderer(renderer);
+        SDL_free(renderer);
         SDL_OutOfMemory();
         return NULL;
     }
 
     /* Setup renderer functions */
     renderer->WindowEvent = WIIU_SDL_WindowEvent;
-    renderer->GetOutputSize = WIIU_SDL_GetOutputSize;
+    renderer->SupportsBlendMode = WIIU_SDL_SupportsBlendMode;
     renderer->CreateTexture = WIIU_SDL_CreateTexture;
-    renderer->SetTextureColorMod = WIIU_SDL_SetTextureColorMod;
-    renderer->SetTextureAlphaMod = WIIU_SDL_SetTextureAlphaMod;
     renderer->UpdateTexture = WIIU_SDL_UpdateTexture;
     renderer->LockTexture = WIIU_SDL_LockTexture;
     renderer->UnlockTexture = WIIU_SDL_UnlockTexture;
+    renderer->SetTextureScaleMode = WIIU_SDL_SetTextureScaleMode;
     renderer->SetRenderTarget = WIIU_SDL_SetRenderTarget;
-    renderer->UpdateViewport = WIIU_SDL_UpdateViewport;
-    renderer->UpdateClipRect = WIIU_SDL_UpdateClipRect;
-    renderer->RenderClear = WIIU_SDL_RenderClear;
-    renderer->RenderDrawPoints = WIIU_SDL_RenderDrawPoints;
-    renderer->RenderDrawLines = WIIU_SDL_RenderDrawLines;
-    renderer->RenderFillRects = WIIU_SDL_RenderFillRects;
-    renderer->RenderCopy = WIIU_SDL_RenderCopy;
-    renderer->RenderCopyEx = WIIU_SDL_RenderCopyEx;
+    renderer->QueueSetViewport = WIIU_SDL_QueueSetViewport;
+    renderer->QueueSetDrawColor = WIIU_SDL_QueueSetDrawColor;
+    renderer->QueueDrawPoints = WIIU_SDL_QueueDrawPoints;
+    renderer->QueueDrawLines = WIIU_SDL_QueueDrawLines;
+    renderer->QueueGeometry = WIIU_SDL_QueueGeometry;
+    renderer->RunCommandQueue = WIIU_SDL_RunCommandQueue;
     renderer->RenderReadPixels = WIIU_SDL_RenderReadPixels;
     renderer->RenderPresent = WIIU_SDL_RenderPresent;
     renderer->DestroyTexture = WIIU_SDL_DestroyTexture;
@@ -82,8 +75,7 @@ SDL_Renderer *WIIU_SDL_CreateRenderer(SDL_Window * window, Uint32 flags)
     renderer->window = window;
 
     /* Prepare shaders */
-    wiiuInitTextureShader();
-    wiiuInitColorShader();
+    WIIU_SDL_CreateShaders();
 
     /* List of attibutes to free after render */
     data->listfree = NULL;
@@ -103,6 +95,12 @@ SDL_Renderer *WIIU_SDL_CreateRenderer(SDL_Window * window, Uint32 flags)
     GX2SetDepthOnlyControl(FALSE, FALSE, GX2_COMPARE_FUNC_NEVER);
     GX2SetCullOnlyControl(GX2_FRONT_FACE_CCW, FALSE, FALSE);
 
+    data->drawState.blendMode = SDL_BLENDMODE_INVALID;
+    data->drawState.shader = SHADER_INVALID;
+    data->drawState.projectionMatrix[3][0] = -1.0f;
+    data->drawState.projectionMatrix[3][1] = 1.0f;
+    data->drawState.projectionMatrix[3][3] = 1.0f;
+
     /* Make a texture for the window */
     WIIU_SDL_CreateWindowTex(renderer, window);
 
@@ -112,6 +110,26 @@ SDL_Renderer *WIIU_SDL_CreateRenderer(SDL_Window * window, Uint32 flags)
     return renderer;
 }
 
+SDL_bool WIIU_SDL_SupportsBlendMode(SDL_Renderer * renderer, SDL_BlendMode blendMode)
+{
+    SDL_BlendFactor srcColorFactor = SDL_GetBlendModeSrcColorFactor(blendMode);
+    SDL_BlendFactor srcAlphaFactor = SDL_GetBlendModeSrcAlphaFactor(blendMode);
+    SDL_BlendOperation colorOperation = SDL_GetBlendModeColorOperation(blendMode);
+    SDL_BlendFactor dstColorFactor = SDL_GetBlendModeDstColorFactor(blendMode);
+    SDL_BlendFactor dstAlphaFactor = SDL_GetBlendModeDstAlphaFactor(blendMode);
+    SDL_BlendOperation alphaOperation = SDL_GetBlendModeAlphaOperation(blendMode);
+
+    if (WIIU_SDL_GetBlendMode(srcColorFactor) == -1 ||
+        WIIU_SDL_GetBlendMode(srcAlphaFactor) == -1 ||
+        WIIU_SDL_GetBlendCombineMode(colorOperation) == -1 ||
+        WIIU_SDL_GetBlendMode(dstColorFactor) == -1 ||
+        WIIU_SDL_GetBlendMode(dstAlphaFactor) == -1 ||
+        WIIU_SDL_GetBlendCombineMode(alphaOperation) == -1) {
+        return SDL_FALSE;
+    }
+    return SDL_TRUE;
+}
+
 void WIIU_SDL_CreateWindowTex(SDL_Renderer * renderer, SDL_Window * window)
 {
     WIIU_RenderData *data = (WIIU_RenderData *) renderer->driverdata;
@@ -140,7 +158,6 @@ void WIIU_SDL_CreateWindowTex(SDL_Renderer * renderer, SDL_Window * window)
     /* Allocate a buffer for the window */
     data->windowTex = (SDL_Texture) {
         .format = SDL_PIXELFORMAT_RGBA8888,
-        .r = 255, .g = 255, .b = 255, .a = 255,
         .driverdata = WIIU_TEXTURE_MEM1_MAGIC,
         .scaleMode = s_mode,
     };
@@ -162,21 +179,11 @@ int WIIU_SDL_SetRenderTarget(SDL_Renderer * renderer, SDL_Texture * texture)
     /* Wait for the texture rendering to finish */
     WIIU_TextureCheckWaitRendering(data, tdata);
 
-    /* Update u_viewSize */
-    data->u_viewSize = (WIIUVec4) {
-        .x = (float)tdata->cbuf.surface.width,
-        .y = (float)tdata->cbuf.surface.height,
-    };
+    data->drawState.viewportDirty = SDL_TRUE;
 
     /* Update context state */
     GX2SetColorBuffer(&tdata->cbuf, GX2_RENDER_TARGET_0);
 
-    /* These may be unnecessary - see SDL_render.c: SDL_SetRenderTarget's calls
-       to UpdateViewport and UpdateClipRect. TODO for once the render is
-       basically working */
-    GX2SetViewport(0, 0, (float)tdata->cbuf.surface.width, (float)tdata->cbuf.surface.height, 0.0f, 1.0f);
-    GX2SetScissor(0, 0, (float)tdata->cbuf.surface.width, (float)tdata->cbuf.surface.height);
-
     return 0;
 }
 
@@ -191,8 +198,7 @@ void WIIU_SDL_DestroyRenderer(SDL_Renderer * renderer)
 
     free(data->ctx);
 
-    wiiuFreeColorShader();
-    wiiuFreeTextureShader();
+    WIIU_SDL_DestroyShaders();
 
     SDL_free(data);
     SDL_free(renderer);
@@ -234,34 +240,25 @@ SDL_RenderDriver WIIU_RenderDriver =
     .info = {
         .name = "WiiU GX2",
         .flags = SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC | SDL_RENDERER_TARGETTEXTURE,
-        .num_texture_formats = 13, //21,
+        .num_texture_formats = 15,
         .texture_formats = {
-        /*  TODO: Alpha-less (X) formats */
             SDL_PIXELFORMAT_RGBA8888,
-//            SDL_PIXELFORMAT_RGBX8888,
+            SDL_PIXELFORMAT_RGBX8888,
 
-//            SDL_PIXELFORMAT_RGB444,
             SDL_PIXELFORMAT_ARGB4444,
             SDL_PIXELFORMAT_RGBA4444,
             SDL_PIXELFORMAT_ABGR4444,
             SDL_PIXELFORMAT_BGRA4444,
 
-//            SDL_PIXELFORMAT_RGB555,
             SDL_PIXELFORMAT_ARGB1555,
-//            SDL_PIXELFORMAT_BGR555,
             SDL_PIXELFORMAT_ABGR1555,
             SDL_PIXELFORMAT_RGBA5551,
             SDL_PIXELFORMAT_BGRA5551,
 
-        /*  TODO: RGB565 doesn't seem to work right, endian issue? */
-//            SDL_PIXELFORMAT_RGB565,
-//            SDL_PIXELFORMAT_BGR565,
-
             SDL_PIXELFORMAT_ARGB8888,
             SDL_PIXELFORMAT_BGRA8888,
-//            SDL_PIXELFORMAT_BGRX8888,
+            SDL_PIXELFORMAT_BGRX8888,
             SDL_PIXELFORMAT_ABGR8888,
-//            SDL_PIXELFORMAT_BGR888,
 
             SDL_PIXELFORMAT_ARGB2101010,
         },
diff --git a/src/render/wiiu/SDL_render_wiiu.h b/src/render/wiiu/SDL_render_wiiu.h
index 68f9ff910..f8b24f235 100644
--- a/src/render/wiiu/SDL_render_wiiu.h
+++ b/src/render/wiiu/SDL_render_wiiu.h
@@ -2,6 +2,7 @@
   Simple DirectMedia Layer
   Copyright (C) 2018-2019 Ash Logan <ash@heyquark.com>
   Copyright (C) 2018-2019 Roberto Van Eeden <r.r.qwertyuiop.r.r@gmail.com>
+  Copyright (C) 2022 GaryOderNichts <garyodernichts@gmail.com>
 
   This software is provided 'as-is', without any express or implied
   warranty.  In no event will the authors be held liable for any damages
@@ -24,47 +25,29 @@
 #ifndef SDL_render_wiiu_h
 #define SDL_render_wiiu_h
 
+#if SDL_VIDEO_RENDER_WIIU
+
 #include "../SDL_sysrender.h"
 #include "SDL_pixels.h"
+#include "SDL_shaders_wiiu.h"
+
 #include <gx2r/buffer.h>
 #include <gx2/context.h>
 #include <gx2/sampler.h>
 #include <gx2/texture.h>
 #include <gx2/surface.h>
 #include <gx2/event.h>
+#include <gx2/utils.h>
 
 /* Driver internal data structures */
-typedef struct WIIUVec2 WIIUVec2;
-typedef struct WIIUVec3 WIIUVec3;
-typedef struct WIIUVec4 WIIUVec4;
-typedef struct WIIUPixFmt WIIUPixFmt;
+typedef struct WIIU_PixFmt WIIU_PixFmt;
 typedef struct WIIU_RenderAllocData WIIU_RenderAllocData;
 typedef struct WIIU_TextureDrawData WIIU_TextureDrawData;
+typedef struct WIIU_DrawState WIIU_DrawState;
 typedef struct WIIU_RenderData WIIU_RenderData;
 typedef struct WIIU_TextureData WIIU_TextureData;
 
-struct WIIUVec2
-{
-    union { float x, r; };
-    union { float y, g; };
-};
-
-struct WIIUVec3
-{
-    union { float x, r; };
-    union { float y, g; };
-    union { float z, b; };
-};
-
-struct WIIUVec4
-{
-    union { float x, r; };
-    union { float y, g; };
-    union { float z, b; };
-    union { float w, a; };
-};
-
-struct WIIUPixFmt
+struct WIIU_PixFmt
 {
     GX2SurfaceFormat fmt;
     uint32_t compMap;
@@ -82,13 +65,33 @@ struct WIIU_TextureDrawData
     WIIU_TextureData *texdata;
 };
 
+struct WIIU_DrawState
+{
+    SDL_Texture *target;
+    SDL_Texture *texture;
+
+    SDL_Rect viewport;
+    SDL_bool viewportDirty;
+    int drawableWidth, drawableHeight;
+    float projectionMatrix[4][4];
+
+    SDL_bool cliprectEnabledDirty;
+    SDL_bool cliprectEnabled;
+    SDL_bool cliprectDirty;
+    SDL_Rect cliprect;
+
+    SDL_BlendMode blendMode;
+
+    WIIU_ShaderType shader;
+};
+
 struct WIIU_RenderData
 {
     GX2ContextState *ctx;
     WIIU_RenderAllocData *listfree;
     WIIU_TextureDrawData *listdraw;
-    WIIUVec4 u_viewSize;
     SDL_Texture windowTex;
+    WIIU_DrawState drawState;
 };
 
 struct WIIU_TextureData
@@ -96,8 +99,6 @@ struct WIIU_TextureData
     GX2Sampler sampler;
     GX2Texture texture;
     GX2ColorBuffer cbuf;
-    WIIUVec4 u_texSize;
-    WIIUVec4 u_mod;
     int isRendering;
 };
 
@@ -108,33 +109,25 @@ struct WIIU_TextureData
 SDL_Renderer *WIIU_SDL_CreateRenderer(SDL_Window * window, Uint32 flags);
 void WIIU_SDL_WindowEvent(SDL_Renderer * renderer,
                              const SDL_WindowEvent *event);
-int WIIU_SDL_GetOutputSize(SDL_Renderer * renderer, int *w, int *h);
+SDL_bool WIIU_SDL_SupportsBlendMode(SDL_Renderer * renderer, SDL_BlendMode blendMode);
 int WIIU_SDL_CreateTexture(SDL_Renderer * renderer, SDL_Texture * texture);
-int WIIU_SDL_SetTextureColorMod(SDL_Renderer * renderer,
-                                SDL_Texture * texture);
-int WIIU_SDL_SetTextureAlphaMod(SDL_Renderer * renderer,
-                                SDL_Texture * texture);
 int WIIU_SDL_UpdateTexture(SDL_Renderer * renderer, SDL_Texture * texture,
                        const SDL_Rect * rect, const void *pixels,
                        int pitch);
 int WIIU_SDL_LockTexture(SDL_Renderer * renderer, SDL_Texture * texture,
                      const SDL_Rect * rect, void **pixels, int *pitch);
 void WIIU_SDL_UnlockTexture(SDL_Renderer * renderer, SDL_Texture * texture);
+void WIIU_SDL_SetTextureScaleMode(SDL_Renderer * renderer, SDL_Texture * texture, SDL_ScaleMode scaleMode);
 int WIIU_SDL_SetRenderTarget(SDL_Renderer * renderer, SDL_Texture * texture);
-int WIIU_SDL_UpdateViewport(SDL_Renderer * renderer);
-int WIIU_SDL_UpdateClipRect(SDL_Renderer * renderer);
-int WIIU_SDL_RenderClear(SDL_Renderer * renderer);
-int WIIU_SDL_RenderDrawPoints(SDL_Renderer * renderer,
-                          const SDL_FPoint * points, int count);
-int WIIU_SDL_RenderDrawLines(SDL_Renderer * renderer,
-                         const SDL_FPoint * points, int count);
-int WIIU_SDL_RenderFillRects(SDL_Renderer * renderer,
-                         const SDL_FRect * rects, int count);
-int WIIU_SDL_RenderCopy(SDL_Renderer * renderer, SDL_Texture * texture,
-                    const SDL_Rect * srcrect, const SDL_FRect * dstrect);
-int WIIU_SDL_RenderCopyEx(SDL_Renderer * renderer, SDL_Texture * texture,
-                      const SDL_Rect * srcrect, const SDL_FRect * dstrect,
-                      const double angle, const SDL_FPoint * center, const SDL_RendererFlip flip);
+int WIIU_SDL_QueueSetViewport(SDL_Renderer * renderer, SDL_RenderCommand * cmd);
+int WIIU_SDL_QueueSetDrawColor(SDL_Renderer * renderer, SDL_RenderCommand * cmd);
+int WIIU_SDL_QueueDrawPoints(SDL_Renderer * renderer, SDL_RenderCommand * cmd, const SDL_FPoint * points, int count);
+int WIIU_SDL_QueueDrawLines(SDL_Renderer * renderer, SDL_RenderCommand * cmd, const SDL_FPoint * points, int count);
+int WIIU_SDL_QueueGeometry(SDL_Renderer * renderer, SDL_RenderCommand * cmd, SDL_Texture * texture,
+        const float * xy, int xy_stride, const SDL_Color * color, int color_stride, const float * uv, int uv_stride,
+        int num_vertices, const void * indices, int num_indices, int size_indices,
+        float scale_x, float scale_y);
+int WIIU_SDL_RunCommandQueue(SDL_Renderer * renderer, SDL_RenderCommand *cmd, void *vertices, size_t vertsize);
 int WIIU_SDL_RenderReadPixels(SDL_Renderer * renderer, const SDL_Rect * rect,
                           Uint32 format, void * pixels, int pitch);
 void WIIU_SDL_RenderPresent(SDL_Renderer * renderer);
@@ -213,105 +206,106 @@ static inline SDL_Texture * WIIU_GetRenderTarget(SDL_Renderer* renderer)
     return &data->windowTex;
 }
 
-static inline WIIUPixFmt SDLFormatToWIIUFormat(Uint32 format)
+static inline WIIU_PixFmt WIIU_SDL_GetPixFmt(Uint32 format)
 {
-    WIIUPixFmt outFmt = { /* sane defaults? */
-        .fmt = GX2_SURFACE_FORMAT_UNORM_R8_G8_B8_A8,
-        .compMap = 0x00010203,
-    };
+    WIIU_PixFmt outFmt = { .fmt = -1, .compMap = 0 };
 
     switch (format) {
         /* packed16 formats: 4 bits/channel */
-        case SDL_PIXELFORMAT_RGB444: /* aka XRGB4444 */
         case SDL_PIXELFORMAT_ARGB4444: {
             outFmt.fmt = GX2_SURFACE_FORMAT_UNORM_R4_G4_B4_A4;
-            outFmt.compMap = 0x01020300;
+            outFmt.compMap = GX2_COMP_MAP(GX2_SQ_SEL_G, GX2_SQ_SEL_B, GX2_SQ_SEL_A, GX2_SQ_SEL_R);
             break;
         }
         case SDL_PIXELFORMAT_RGBA4444: {
             outFmt.fmt = GX2_SURFACE_FORMAT_UNORM_R4_G4_B4_A4;
-            outFmt.compMap = 0x00010203;
+            outFmt.compMap = GX2_COMP_MAP(GX2_SQ_SEL_R, GX2_SQ_SEL_G, GX2_SQ_SEL_B, GX2_SQ_SEL_A);
             break;
         }
         case SDL_PIXELFORMAT_ABGR4444: {
             outFmt.fmt = GX2_SURFACE_FORMAT_UNORM_R4_G4_B4_A4;
-            outFmt.compMap = 0x03020100;
+            outFmt.compMap = GX2_COMP_MAP(GX2_SQ_SEL_A, GX2_SQ_SEL_B, GX2_SQ_SEL_G, GX2_SQ_SEL_R);
             break;
         }
         case SDL_PIXELFORMAT_BGRA4444: {
             outFmt.fmt = GX2_SURFACE_FORMAT_UNORM_R4_G4_B4_A4;
-            outFmt.compMap = 0x02010003;
+            outFmt.compMap = GX2_COMP_MAP(GX2_SQ_SEL_B, GX2_SQ_SEL_G, GX2_SQ_SEL_R, GX2_SQ_SEL_A);
             break;
         }
 
         /* packed16 formats: 5 bits/channel */
-        case SDL_PIXELFORMAT_RGB555: /* aka XRGB1555 */
         case SDL_PIXELFORMAT_ARGB1555: {
             outFmt.fmt = GX2_SURFACE_FORMAT_UNORM_R5_G5_B5_A1;
-            outFmt.compMap = 0x01020300;
+            outFmt.compMap = GX2_COMP_MAP(GX2_SQ_SEL_G, GX2_SQ_SEL_B, GX2_SQ_SEL_A, GX2_SQ_SEL_R);
             break;
         }
-        case SDL_PIXELFORMAT_BGR555: /* aka XRGB1555 */
         case SDL_PIXELFORMAT_ABGR1555: {
             outFmt.fmt = GX2_SURFACE_FORMAT_UNORM_R5_G5_B5_A1;
-            outFmt.compMap = 0x03020100;
+            outFmt.compMap = GX2_COMP_MAP(GX2_SQ_SEL_A, GX2_SQ_SEL_B, GX2_SQ_SEL_G, GX2_SQ_SEL_R);
             break;
         }
         case SDL_PIXELFORMAT_RGBA5551: {
             outFmt.fmt = GX2_SURFACE_FORMAT_UNORM_R5_G5_B5_A1;
-            outFmt.compMap = 0x00010203;
+            outFmt.compMap = GX2_COMP_MAP(GX2_SQ_SEL_R, GX2_SQ_SEL_G, GX2_SQ_SEL_B, GX2_SQ_SEL_A);
             break;
         }
         case SDL_PIXELFORMAT_BGRA5551: {
             outFmt.fmt = GX2_SURFACE_FORMAT_UNORM_R5_G5_B5_A1;
-            outFmt.compMap = 0x02010003;
+            outFmt.compMap = GX2_COMP_MAP(GX2_SQ_SEL_B, GX2_SQ_SEL_G, GX2_SQ_SEL_R, GX2_SQ_SEL_A);
             break;
         }
 
         /* packed16 formats: 565 */
         case SDL_PIXELFORMAT_RGB565: {
             outFmt.fmt = GX2_SURFACE_FORMAT_UNORM_R5_G6_B5;
-            outFmt.compMap = 0x00010203;
+            outFmt.compMap = GX2_COMP_MAP(GX2_SQ_SEL_R, GX2_SQ_SEL_G, GX2_SQ_SEL_B, GX2_SQ_SEL_A);
             break;
         }
         case SDL_PIXELFORMAT_BGR565: {
             outFmt.fmt = GX2_SURFACE_FORMAT_UNORM_R5_G6_B5;
-            outFmt.compMap = 0x02010003;
+            outFmt.compMap = GX2_COMP_MAP(GX2_SQ_SEL_B, GX2_SQ_SEL_G, GX2_SQ_SEL_R, GX2_SQ_SEL_A);
             break;
         }
 
         /* packed32 formats */
-        case SDL_PIXELFORMAT_RGBA8888:
         case SDL_PIXELFORMAT_RGBX8888: {
             outFmt.fmt = GX2_SURFACE_FORMAT_UNORM_R8_G8_B8_A8;
-            outFmt.compMap = 0x00010203;
+            outFmt.compMap = GX2_COMP_MAP(GX2_SQ_SEL_R, GX2_SQ_SEL_G, GX2_SQ_SEL_B, GX2_SQ_SEL_1);
+            break;
+        }
+        case SDL_PIXELFORMAT_RGBA8888: {
+            outFmt.fmt = GX2_SURFACE_FORMAT_UNORM_R8_G8_B8_A8;
+            outFmt.compMap = GX2_COMP_MAP(GX2_SQ_SEL_R, GX2_SQ_SEL_G, GX2_SQ_SEL_B, GX2_SQ_SEL_A);
             break;
         }
         case SDL_PIXELFORMAT_ARGB8888: {
             outFmt.fmt = GX2_SURFACE_FORMAT_UNORM_R8_G8_B8_A8;
-            outFmt.compMap = 0x01020300;
+            outFmt.compMap = GX2_COMP_MAP(GX2_SQ_SEL_G, GX2_SQ_SEL_B, GX2_SQ_SEL_A, GX2_SQ_SEL_R);
             break;
         }
-        case SDL_PIXELFORMAT_BGRA8888:
         case SDL_PIXELFORMAT_BGRX8888: {
             outFmt.fmt = GX2_SURFACE_FORMAT_UNORM_R8_G8_B8_A8;
-            outFmt.compMap = 0x02010003;
+            outFmt.compMap = GX2_COMP_MAP(GX2_SQ_SEL_B, GX2_SQ_SEL_G, GX2_SQ_SEL_R, GX2_SQ_SEL_1);
             break;
         }
-        case SDL_PIXELFORMAT_ABGR8888:
-        case SDL_PIXELFORMAT_BGR888: {
+        case SDL_PIXELFORMAT_BGRA8888: {
             outFmt.fmt = GX2_SURFACE_FORMAT_UNORM_R8_G8_B8_A8;
-            outFmt.compMap = 0x03020100;
+            outFmt.compMap = GX2_COMP_MAP(GX2_SQ_SEL_B, GX2_SQ_SEL_G, GX2_SQ_SEL_R, GX2_SQ_SEL_A);
+            break;
+        }
+        case SDL_PIXELFORMAT_ABGR8888: {
+            outFmt.fmt = GX2_SURFACE_FORMAT_UNORM_R8_G8_B8_A8;
+            outFmt.compMap = GX2_COMP_MAP(GX2_SQ_SEL_A, GX2_SQ_SEL_B, GX2_SQ_SEL_G, GX2_SQ_SEL_R);
             break;
         }
         case SDL_PIXELFORMAT_ARGB2101010: {
             outFmt.fmt = GX2_SURFACE_FORMAT_UNORM_R10_G10_B10_A2;
-            outFmt.compMap = 0x01020300;
+            outFmt.compMap = GX2_COMP_MAP(GX2_SQ_SEL_G, GX2_SQ_SEL_B, GX2_SQ_SEL_A, GX2_SQ_SEL_R);
             break;
         }
         default: {
-            /* TODO return an error */
             printf("SDL: WiiU format not recognised (SDL: %08X)\n", format);
+            outFmt.fmt = -1;
             break;
         }
     }
@@ -319,4 +313,52 @@ static inline WIIUPixFmt SDLFormatToWIIUFormat(Uint32 format)
     return outFmt;
 }
 
-#endif //SDL_render_wiiu_h
+static inline GX2BlendMode WIIU_SDL_GetBlendMode(SDL_BlendFactor factor)
+{
+    switch (factor) {
+        case SDL_BLENDFACTOR_ZERO:
+            return GX2_BLEND_MODE_ZERO;
+        case SDL_BLENDFACTOR_ONE:
+            return GX2_BLEND_MODE_ONE;
+        case SDL_BLENDFACTOR_SRC_COLOR:
+            return GX2_BLEND_MODE_SRC_COLOR;
+        case SDL_BLENDFACTOR_ONE_MINUS_SRC_COLOR:
+            return GX2_BLEND_MODE_INV_SRC_COLOR;
+        case SDL_BLENDFACTOR_SRC_ALPHA:
+            return GX2_BLEND_MODE_SRC_ALPHA;
+        case SDL_BLENDFACTOR_ONE_MINUS_SRC_ALPHA:
+            return GX2_BLEND_MODE_INV_SRC_ALPHA;
+        case SDL_BLENDFACTOR_DST_COLOR:
+            return GX2_BLEND_MODE_DST_COLOR;
+        case SDL_BLENDFACTOR_ONE_MINUS_DST_COLOR:
+            return GX2_BLEND_MODE_INV_DST_COLOR;
+        case SDL_BLENDFACTOR_DST_ALPHA:
+            return GX2_BLEND_MODE_DST_ALPHA;
+        case SDL_BLENDFACTOR_ONE_MINUS_DST_ALPHA:
+            return GX2_BLEND_MODE_INV_DST_COLOR;
+        default:
+            return -1;
+    }
+}
+
+static inline GX2BlendCombineMode WIIU_SDL_GetBlendCombineMode(SDL_BlendOperation operation)
+{
+    switch (operation) {
+        case SDL_BLENDOPERATION_ADD:
+            return GX2_BLEND_COMBINE_MODE_ADD;
+        case SDL_BLENDOPERATION_SUBTRACT:
+            return GX2_BLEND_COMBINE_MODE_SUB;
+        case SDL_BLENDOPERATION_REV_SUBTRACT:
+            return GX2_BLEND_COMBINE_MODE_REV_SUB;
+        case SDL_BLENDOPERATION_MINIMUM:
+            return GX2_BLEND_COMBINE_MODE_MIN;
+        case SDL_BLENDOPERATION_MAXIMUM:
+            return GX2_BLEND_COMBINE_MODE_MAX;
+        default:
+            return -1;
+    }
+}
+
+#endif /* SDL_VIDEO_RENDER_WIIU */
+
+#endif /* SDL_render_wiiu_h */
diff --git a/src/render/wiiu/SDL_rpresent_wiiu.c b/src/render/wiiu/SDL_rpresent_wiiu.c
index 18adae8e1..52fc71a97 100644
--- a/src/render/wiiu/SDL_rpresent_wiiu.c
+++ b/src/render/wiiu/SDL_rpresent_wiiu.c
@@ -2,6 +2,7 @@
   Simple DirectMedia Layer
   Copyright (C) 2018-2019 Ash Logan <ash@heyquark.com>
   Copyright (C) 2018-2019 Roberto Van Eeden <r.r.qwertyuiop.r.r@gmail.com>
+  Copyright (C) 2022 GaryOderNichts <garyodernichts@gmail.com>
 
   This software is provided 'as-is', without any express or implied
   warranty.  In no event will the authors be held liable for any damages
@@ -23,7 +24,6 @@
 
 #if SDL_VIDEO_RENDER_WIIU
 
-#include "../../video/wiiu/wiiu_shaders.h"
 #include "../SDL_sysrender.h"
 #include "SDL_render_wiiu.h"
 
@@ -37,37 +37,20 @@
 #define SCREEN_WIDTH    1280
 #define SCREEN_HEIGHT   720
 
-static const WIIUVec4 u_viewSize = {.x = (float)SCREEN_WIDTH, .y = (float)SCREEN_HEIGHT};
-
-static void render_scene(SDL_Renderer * renderer)
+void WIIU_SDL_RenderPresent(SDL_Renderer * renderer)
 {
     WIIU_RenderData *data = (WIIU_RenderData *) renderer->driverdata;
     WIIU_TextureData *tdata = (WIIU_TextureData *) data->windowTex.driverdata;
-
-    float tex_w = tdata->u_texSize.x;
-    float tex_h = tdata->u_texSize.y;
+    Uint32 flags = SDL_GetWindowFlags(renderer->window);
     int win_x, win_y, win_w, win_h;
-    GX2RBuffer *a_position, *a_texCoord;
-    WIIUVec2 *a_position_vals, *a_texCoord_vals;
-
-    /* Allocate attribute buffers */
-    a_position = WIIU_AllocRenderData(data, (GX2RBuffer) {
-        .flags =
-            GX2R_RESOURCE_BIND_VERTEX_BUFFER |
-            GX2R_RESOURCE_USAGE_CPU_WRITE,
-        .elemSize = sizeof(WIIUVec2), /* float x/y for each corner */
-        .elemCount = 4, /* 4 corners */
-    });
-    a_texCoord = WIIU_AllocRenderData(data, (GX2RBuffer) {
-        .flags =
-            GX2R_RESOURCE_BIND_VERTEX_BUFFER |
-            GX2R_RESOURCE_USAGE_CPU_WRITE,
-        .elemSize = sizeof(WIIUVec2), // float x/y for each corner
-        .elemCount = 4, // 4 corners
-    });
-
-    /* Calculate and save positions */
-    if (SDL_GetWindowFlags(renderer->window) & SDL_WINDOW_FULLSCREEN) {
+
+    if (renderer->info.flags & SDL_RENDERER_PRESENTVSYNC) {
+    /*  NOTE watch libwhb's source to ensure this call only does vsync */
+        WHBGfxBeginRender();
+    }
+
+    /* Calculate and save positions TODO: make use of the window position */
+    if (flags & SDL_WINDOW_FULLSCREEN) {
         win_x = 0;
         win_y = 0;
         win_w = SCREEN_WIDTH;
@@ -79,68 +62,18 @@ static void render_scene(SDL_Renderer * renderer)
         win_y = (SCREEN_HEIGHT - win_h) / 2;
     }
 
-    a_position_vals = GX2RLockBufferEx(a_position, 0);
-    a_position_vals[0] = (WIIUVec2) {
-        .x = win_x, .y = win_y
-    };
-    a_position_vals[1] = (WIIUVec2) {
-        .x = win_x + win_w, .y = win_y
-    };
-    a_position_vals[2] = (WIIUVec2) {
-        .x = win_x + win_w, .y = win_y + win_h
-    };
-    a_position_vals[3] = (WIIUVec2) {
-        .x = win_x, .y = win_y + win_h
-    };
-    GX2RUnlockBufferEx(a_position, 0);
-
-    /* Compute texture coords */
-    a_texCoord_vals = GX2RLockBufferEx(a_texCoord, 0);
-    a_texCoord_vals[0] = (WIIUVec2) {.x = 0.0f,  .y = tex_h};
-    a_texCoord_vals[1] = (WIIUVec2) {.x = tex_w, .y = tex_h};
-    a_texCoord_vals[2] = (WIIUVec2) {.x = tex_w, .y = 0.0f};
-    a_texCoord_vals[3] = (WIIUVec2) {.x = 0.0f,  .y = 0.0f};
-    GX2RUnlockBufferEx(a_texCoord, 0);
-
-    /* Render the window */
-    WHBGfxClearColor(0.0f, 0.0f, 0.0f, 1.0f);
-    wiiuSetTextureShader();
-
-    GX2SetVertexUniformReg(wiiuTextureShader.vertexShader->uniformVars[0].offset, 4, (uint32_t *)&u_viewSize);
-    GX2SetVertexUniformReg(wiiuTextureShader.vertexShader->uniformVars[1].offset, 4, (uint32_t *)&tdata->u_texSize);
-    GX2SetPixelUniformReg(wiiuTextureShader.pixelShader->uniformVars[0].offset, 4, (uint32_t*)&tdata->u_mod);
-
-    GX2RSetAttributeBuffer(a_position, 0, a_position->elemSize, 0);
-    GX2RSetAttributeBuffer(a_texCoord, 1, a_texCoord->elemSize, 0);
-
-    GX2SetPixelTexture(&tdata->texture, wiiuTextureShader.pixelShader->samplerVars[0].location);
-    GX2SetPixelSampler(&tdata->sampler, wiiuTextureShader.pixelShader->samplerVars[0].location);
-
-    GX2SetColorControl(GX2_LOGIC_OP_COPY, 0x00, FALSE, TRUE);
-
-    GX2DrawEx(GX2_PRIMITIVE_MODE_QUADS, 4, 0, 1);
-}
-
-void WIIU_SDL_RenderPresent(SDL_Renderer * renderer)
-{
-    WIIU_RenderData *data = (WIIU_RenderData *) renderer->driverdata;
-    Uint32 flags = SDL_GetWindowFlags(renderer->window);
-
-    if (renderer->info.flags & SDL_RENDERER_PRESENTVSYNC) {
-    /*  NOTE watch libwhb's source to ensure this call only does vsync */
-        WHBGfxBeginRender();
-    }
-
     /* Only render to TV if the window is *not* drc-only */
     if (!(flags & SDL_WINDOW_WIIU_GAMEPAD_ONLY)) {
         WHBGfxBeginRenderTV();
-        render_scene(renderer);
+        GX2CopySurface(&tdata->texture.surface, 0, 0, &WHBGfxGetTVColourBuffer()->surface, 0, 0);
+        GX2SetContextState(data->ctx);
         WHBGfxFinishRenderTV();
     }
 
     if (!(flags & SDL_WINDOW_WIIU_TV_ONLY)) {
         WHBGfxBeginRenderDRC();
-        render_scene(renderer);
+        GX2CopySurface(&tdata->texture.surface, 0, 0, &WHBGfxGetDRCColourBuffer()->surface, 0, 0);
+        GX2SetContextState(data->ctx);
         WHBGfxFinishRenderDRC();
     }
 
diff --git a/src/render/wiiu/SDL_rqueue_wiiu.c b/src/render/wiiu/SDL_rqueue_wiiu.c
new file mode 100644
index 000000000..d4140d545
--- /dev/null
+++ b/src/render/wiiu/SDL_rqueue_wiiu.c
@@ -0,0 +1,438 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 2022 GaryOderNichts <garyodernichts@gmail.com>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#if SDL_VIDEO_RENDER_WIIU
+
+#include "../SDL_sysrender.h"
+#include "SDL_hints.h"
+#include "SDL_render_wiiu.h"
+
+#include <gx2/texture.h>
+#include <gx2/draw.h>
+#include <gx2/registers.h>
+#include <gx2/sampler.h>
+#include <gx2/state.h>
+#include <gx2/clear.h>
+#include <gx2/mem.h>
+#include <gx2/event.h>
+#include <gx2r/surface.h>
+#include <gx2r/buffer.h>
+#include <gx2r/draw.h>
+
+#include <stdio.h>
+#include <stdarg.h>
+#include <stdlib.h>
+#include <string.h>
+#include <math.h>
+
+int WIIU_SDL_QueueSetViewport(SDL_Renderer * renderer, SDL_RenderCommand * cmd)
+{
+    return 0;
+}
+
+int WIIU_SDL_QueueSetDrawColor(SDL_Renderer * renderer, SDL_RenderCommand * cmd)
+{
+    return 0;
+}
+
+int WIIU_SDL_QueueDrawPoints(SDL_Renderer * renderer, SDL_RenderCommand * cmd, const SDL_FPoint * points, int count)
+{
+    WIIU_RenderData *data = (WIIU_RenderData *) renderer->driverdata;
+    SDL_VertexSolid *vertices;
+    GX2RBuffer *vertexBuffer;
+    SDL_Color color;
+    color.r = cmd->data.draw.r;
+    color.g = cmd->data.draw.g;
+    color.b = cmd->data.draw.b;
+    color.a = cmd->data.draw.a;
+
+    vertexBuffer = WIIU_AllocRenderData(data, (GX2RBuffer) {
+        .flags =
+            GX2R_RESOURCE_BIND_VERTEX_BUFFER |
+            GX2R_RESOURCE_USAGE_CPU_WRITE,
+        .elemSize = sizeof(SDL_VertexSolid),
+        .elemCount = count,
+    });
+
+    if (!vertexBuffer) {
+        return -1;
+    }
+
+    cmd->data.draw.first = (size_t)vertexBuffer;
+    cmd->data.draw.count = count;
+
+    vertices = GX2RLockBufferEx(vertexBuffer, 0);
+
+    for (int i = 0; i < count; ++i) {
+        vertices[i].position.x = points[i].x;
+        vertices[i].position.y = points[i].y;
+        vertices[i].color = color;
+    }
+
+    GX2RUnlockBufferEx(vertexBuffer, 0);
+
+    return 0;
+}
+
+int WIIU_SDL_QueueDrawLines(SDL_Renderer * renderer, SDL_RenderCommand * cmd, const SDL_FPoint * points, int count)
+{
+    WIIU_RenderData *data = (WIIU_RenderData *) renderer->driverdata;
+    SDL_VertexSolid *vertices;
+    GX2RBuffer *vertexBuffer;
+    SDL_Color color;
+    color.r = cmd->data.draw.r;
+    color.g = cmd->data.draw.g;
+    color.b = cmd->data.draw.b;
+    color.a = cmd->data.draw.a;
+
+    vertexBuffer = WIIU_AllocRenderData(data, (GX2RBuffer) {
+        .flags =
+            GX2R_RESOURCE_BIND_VERTEX_BUFFER |
+            GX2R_RESOURCE_USAGE_CPU_WRITE,
+        .elemSize = sizeof(SDL_VertexSolid),
+        .elemCount = (count - 1) * 2,
+    });
+
+    if (!vertexBuffer) {
+        return -1;
+    }
+
+    cmd->data.draw.first = (size_t)vertexBuffer;
+    cmd->data.draw.count = (count - 1) * 2;
+
+    vertices = GX2RLockBufferEx(vertexBuffer, 0);
+
+    for (int i = 0; i < count - 1; ++i) {
+        vertices[i * 2].position.x = points[i].x;
+        vertices[i * 2].position.y = points[i].y;
+        vertices[i * 2].color = color;
+
+        vertices[i * 2 + 1].position.x = points[i + 1].x;
+        vertices[i * 2 + 1].position.y = points[i + 1].y;
+        vertices[i * 2 + 1].color = color;
+    }
+
+    GX2RUnlockBufferEx(vertexBuffer, 0);
+
+    return 0;
+}
+
+int WIIU_SDL_QueueGeometry(SDL_Renderer * renderer, SDL_RenderCommand * cmd, SDL_Texture * texture,
+        const float * xy, int xy_stride, const SDL_Color * color, int color_stride, const float * uv, int uv_stride,
+        int num_vertices, const void * indices, int num_indices, int size_indices,
+        float scale_x, float scale_y)
+{
+    WIIU_RenderData *data = (WIIU_RenderData *) renderer->driverdata;
+    GX2RBuffer *vertexBuffer;
+
+    int count = indices ? num_indices : num_vertices;
+    cmd->data.draw.count = count;
+
+    size_indices = indices ? size_indices : 0;
+
+    if (texture) {
+        SDL_Vertex *vertices;
+        vertexBuffer = WIIU_AllocRenderData(data, (GX2RBuffer) {
+            .flags =
+                GX2R_RESOURCE_BIND_VERTEX_BUFFER |
+                GX2R_RESOURCE_USAGE_CPU_WRITE,
+            .elemSize = sizeof(SDL_Vertex),
+            .elemCount = count,
+        });
+
+        if (!vertexBuffer) {
+            return -1;
+        }
+
+        vertices = GX2RLockBufferEx(vertexBuffer, 0);
+
+        for (int i = 0; i < count; i++) {
+            int j;
+            float *xy_;
+            float *uv_;
+            SDL_Color col_;
+            if (size_indices == 4) {
+                j = ((const Uint32 *)indices)[i];
+            } else if (size_indices == 2) {
+                j = ((const Uint16 *)indices)[i];
+            } else if (size_indices == 1) {
+                j = ((const Uint8 *)indices)[i];
+            } else {
+                j = i;
+            }
+
+            xy_ = (float *)((char*)xy + j * xy_stride);
+            col_ = *(SDL_Color *)((char*)color + j * color_stride);
+            uv_ = (float *)((char*)uv + j * uv_stride);
+
+            vertices[i].position.x = xy_[0] * scale_x;
+            vertices[i].position.y = xy_[1] * scale_y;
+            vertices[i].tex_coord.x = uv_[0];
+            vertices[i].tex_coord.y = uv_[1];
+            vertices[i].color = col_;
+        }
+
+        GX2RUnlockBufferEx(vertexBuffer, 0);
+
+        cmd->data.draw.first = (size_t)vertexBuffer;
+    } else {
+        SDL_VertexSolid *vertices;
+        vertexBuffer = WIIU_AllocRenderData(data, (GX2RBuffer) {
+            .flags =
+                GX2R_RESOURCE_BIND_VERTEX_BUFFER |
+                GX2R_RESOURCE_USAGE_CPU_WRITE,
+            .elemSize = sizeof(SDL_VertexSolid),
+            .elemCount = count,
+        });
+
+        if (!vertexBuffer) {
+            return -1;
+        }
+
+        vertices = GX2RLockBufferEx(vertexBuffer, 0);
+
+        for (int i = 0; i < count; i++) {
+            int j;
+            float *xy_;
+            SDL_Color col_;
+            if (size_indices == 4) {
+                j = ((const Uint32 *)indices)[i];
+            } else if (size_indices == 2) {
+                j = ((const Uint16 *)indices)[i];
+            } else if (size_indices == 1) {
+                j = ((const Uint8 *)indices)[i];
+            } else {
+                j = i;
+            }
+
+            xy_ = (float *)((char*)xy + j * xy_stride);
+            col_ = *(SDL_Color *)((char*)color + j * color_stride);
+
+            vertices[i].position.x = xy_[0] * scale_x;
+            vertices[i].position.y = xy_[1] * scale_y;
+            vertices[i].color = col_;
+        }
+
+        GX2RUnlockBufferEx(vertexBuffer, 0);
+
+        cmd->data.draw.first = (size_t)vertexBuffer;
+    }
+
+    return 0;
+}
+
+static int WIIU_SDL_RenderClear(SDL_Renderer * renderer, SDL_RenderCommand * cmd)
+{
+    WIIU_RenderData *data = (WIIU_RenderData*) renderer->driverdata;
+    SDL_Texture *target = WIIU_GetRenderTarget(renderer);
+    WIIU_TextureData *tdata = (WIIU_TextureData*) target->driverdata;
+
+    GX2ClearColor(&tdata->cbuf,
+                  (float) cmd->data.color.r / 255.0f,
+                  (float) cmd->data.color.g / 255.0f,
+                  (float) cmd->data.color.b / 255.0f,
+                  (float) cmd->data.color.a / 255.0f);
+
+    /* Restore SDL context state */
+    GX2SetContextState(data->ctx);
+
+    return 0;
+}
+
+static int WIIU_SDL_SetDrawState(WIIU_RenderData * data, const SDL_RenderCommand * cmd)
+{
+    SDL_bool matrixUpdated = SDL_FALSE;
+    SDL_bool shaderUpdated = SDL_FALSE;
+    const SDL_BlendMode blendMode = cmd->data.draw.blend;
+    WIIU_ShaderType shader = cmd->data.draw.texture ? SHADER_TEXTURE : SHADER_COLOR;
+    WHBGfxShaderGroup* shaderGroup = WIIU_SDL_GetShaderGroup(shader);
+    SDL_Texture *texture = cmd->data.draw.texture;
+
+    if (data->drawState.viewportDirty) {
+        const SDL_Rect *viewport = &data->drawState.viewport;
+
+        GX2SetViewport(viewport->x, viewport->y, viewport->w, viewport->h, 0.0f, 1.0f);
+
+        if (viewport->w && viewport->h) {
+            data->drawState.projectionMatrix[0][0] = 2.0f / viewport->w;
+            data->drawState.projectionMatrix[1][1] = 2.0f / viewport->h;
+            matrixUpdated = SDL_TRUE;
+        }
+
+        data->drawState.viewportDirty = SDL_FALSE;
+    }
+
+    if (data->drawState.cliprectEnabledDirty || data->drawState.cliprectDirty) {
+        SDL_Rect scissor;
+        const SDL_Rect *viewport = &data->drawState.viewport;
+        const SDL_Rect *rect = &data->drawState.cliprect;
+
+        if (data->drawState.cliprectEnabled) {
+            // make sure scissor is never larger than the colorbuffer to prevent memory corruption
+            scissor.x = SDL_min(viewport->w, rect->x);
+            scissor.y = SDL_min(viewport->h, rect->h);
+            scissor.w = SDL_min(viewport->w, rect->w);
+            scissor.h = SDL_min(viewport->w, rect->h);
+        } else {
+            scissor = *viewport;
+        }
+
+        GX2SetScissor(scissor.x, scissor.y, scissor.w, scissor.h);
+
+        data->drawState.cliprectEnabledDirty = SDL_FALSE;
+        data->drawState.cliprectDirty = SDL_FALSE;
+    }
+
+    if (blendMode != data->drawState.blendMode) {
+        if (blendMode == SDL_BLENDMODE_NONE) {
+            GX2SetColorControl(GX2_LOGIC_OP_COPY, 0x00, FALSE, TRUE);
+        } else {
+            GX2SetColorControl(GX2_LOGIC_OP_COPY, 0xFF, FALSE, TRUE);
+            GX2SetBlendControl(GX2_RENDER_TARGET_0,
+                WIIU_SDL_GetBlendMode(SDL_GetBlendModeSrcColorFactor(blendMode)),
+                WIIU_SDL_GetBlendMode(SDL_GetBlendModeDstColorFactor(blendMode)),
+                WIIU_SDL_GetBlendCombineMode(SDL_GetBlendModeColorOperation(blendMode)),
+                TRUE,
+                WIIU_SDL_GetBlendMode(SDL_GetBlendModeSrcAlphaFactor(blendMode)),
+                WIIU_SDL_GetBlendMode(SDL_GetBlendModeDstAlphaFactor(blendMode)),
+                WIIU_SDL_GetBlendCombineMode(SDL_GetBlendModeAlphaOperation(blendMode)));
+        }
+
+        data->drawState.blendMode = blendMode;
+    }
+
+    if (shader != data->drawState.shader) {
+        WIIU_SDL_SelectShader(shader);
+        shaderUpdated = SDL_TRUE;
+        data->drawState.shader = shader;
+    }
+
+    if (shaderUpdated || matrixUpdated) {
+        GX2SetVertexUniformReg(shaderGroup->vertexShader->uniformVars[0].offset, 16, data->drawState.projectionMatrix);
+    }
+
+    if (texture != data->drawState.texture) {
+        if (texture) {
+            WIIU_TextureData *tdata = (WIIU_TextureData*) texture->driverdata;
+            uint32_t location = shaderGroup->pixelShader->samplerVars[0].location;
+            GX2SetPixelTexture(&tdata->texture, location);
+            GX2SetPixelSampler(&tdata->sampler, location);
+
+            WIIU_TextureStartRendering(data, tdata);
+        }
+
+        data->drawState.texture = texture;
+    }
+
+    return 0;
+}
+
+int WIIU_SDL_RunCommandQueue(SDL_Renderer * renderer, SDL_RenderCommand *cmd, void *vertices, size_t vertsize)
+{
+    WIIU_RenderData* data = (WIIU_RenderData*) renderer->driverdata;
+
+    data->drawState.target = renderer->target;
+    if (!data->drawState.target) {
+        int w, h;
+        SDL_GL_GetDrawableSize(renderer->window, &w, &h);
+        if ((w != data->drawState.drawableWidth) || (h != data->drawState.drawableHeight)) {
+            data->drawState.viewportDirty = SDL_TRUE;  // if the window dimensions changed, invalidate the current viewport, etc.
+            data->drawState.cliprectDirty = SDL_TRUE;
+            data->drawState.drawableWidth = w;
+            data->drawState.drawableHeight = h;
+        }
+    }
+
+    while (cmd) {
+        switch (cmd->command) {
+
+            case SDL_RENDERCMD_SETVIEWPORT: {
+                SDL_Rect *viewport = &data->drawState.viewport;
+                if (SDL_memcmp(viewport, &cmd->data.viewport.rect, sizeof (SDL_Rect)) != 0) {
+                    SDL_memcpy(viewport, &cmd->data.viewport.rect, sizeof (SDL_Rect));
+                    data->drawState.viewportDirty = SDL_TRUE;
+                }
+                break;
+            }
+
+            case SDL_RENDERCMD_SETCLIPRECT: {
+                const SDL_Rect *rect = &cmd->data.cliprect.rect;
+                if (data->drawState.cliprectEnabled != cmd->data.cliprect.enabled) {
+                    data->drawState.cliprectEnabled = cmd->data.cliprect.enabled;
+                    data->drawState.cliprectEnabledDirty = SDL_TRUE;
+                }
+
+                if (SDL_memcmp(&data->drawState.cliprect, rect, sizeof (SDL_Rect)) != 0) {
+                    SDL_memcpy(&data->drawState.cliprect, rect, sizeof (SDL_Rect));
+                    data->drawState.cliprectDirty = SDL_TRUE;
+                }
+                break;
+            }
+
+            case SDL_RENDERCMD_SETDRAWCOLOR:
+                break;
+
+            case SDL_RENDERCMD_CLEAR: {
+                WIIU_SDL_RenderClear(renderer, cmd);
+                break;
+            }
+
+            case SDL_RENDERCMD_DRAW_POINTS: {
+                GX2RBuffer *vertexBuffer = (GX2RBuffer *) cmd->data.draw.first;
+                WIIU_SDL_SetDrawState(data, cmd);
+                GX2RSetAttributeBuffer(vertexBuffer, 0, vertexBuffer->elemSize, 0);
+                GX2DrawEx(GX2_PRIMITIVE_MODE_POINTS, cmd->data.draw.count, 0, 1);
+                break;
+            }
+
+            case SDL_RENDERCMD_DRAW_LINES: {
+                GX2RBuffer *vertexBuffer = (GX2RBuffer *) cmd->data.draw.first;
+                WIIU_SDL_SetDrawState(data, cmd);
+                GX2RSetAttributeBuffer(vertexBuffer, 0, vertexBuffer->elemSize, 0);
+                GX2DrawEx(GX2_PRIMITIVE_MODE_LINE_STRIP, cmd->data.draw.count, 0, 1);
+                break;
+            }
+
+            /* unused (will be handled by geometry) */
+            case SDL_RENDERCMD_FILL_RECTS:
+            case SDL_RENDERCMD_COPY:
+            case SDL_RENDERCMD_COPY_EX:
+                break;
+
+            case SDL_RENDERCMD_GEOMETRY: {
+                GX2RBuffer *vertexBuffer = (GX2RBuffer *) cmd->data.draw.first;
+                WIIU_SDL_SetDrawState(data, cmd);
+                GX2RSetAttributeBuffer(vertexBuffer, 0, vertexBuffer->elemSize, 0);
+                GX2DrawEx(GX2_PRIMITIVE_MODE_TRIANGLES, cmd->data.draw.count, 0, 1);
+            }
+
+            case SDL_RENDERCMD_NO_OP:
+                break;
+        }
+
+        cmd = cmd->next;
+    }
+
+    return 0;
+}
+
+#endif /* SDL_VIDEO_RENDER_WIIU */
diff --git a/src/render/wiiu/SDL_rtexture_wiiu.c b/src/render/wiiu/SDL_rtexture_wiiu.c
index 7aae30b0d..7b507f6b8 100644
--- a/src/render/wiiu/SDL_rtexture_wiiu.c
+++ b/src/render/wiiu/SDL_rtexture_wiiu.c
@@ -2,6 +2,7 @@
   Simple DirectMedia Layer
   Copyright (C) 2018-2019 Ash Logan <ash@heyquark.com>
   Copyright (C) 2018-2019 Roberto Van Eeden <r.r.qwertyuiop.r.r@gmail.com>
+  Copyright (C) 2022 GaryOderNichts <garyodernichts@gmail.com>
 
   This software is provided 'as-is', without any express or implied
   warranty.  In no event will the authors be held liable for any damages
@@ -39,7 +40,7 @@
 int WIIU_SDL_CreateTexture(SDL_Renderer * renderer, SDL_Texture * texture)
 {
     BOOL res;
-    WIIUPixFmt gx2_fmt;
+    WIIU_PixFmt gx2_fmt;
     GX2RResourceFlags surface_flags;
     WIIU_TextureData *tdata = (WIIU_TextureData *) SDL_calloc(1, sizeof(*tdata));
     if (!tdata) {
@@ -53,8 +54,10 @@ int WIIU_SDL_CreateTexture(SDL_Renderer * renderer, SDL_Texture * texture)
         GX2InitSampler(&tdata->sampler, GX2_TEX_CLAMP_MODE_CLAMP, GX2_TEX_XY_FILTER_MODE_LINEAR);
     }
 
-
-    gx2_fmt = SDLFormatToWIIUFormat(texture->format);
+    gx2_fmt = WIIU_SDL_GetPixFmt(texture->format);
+    if (gx2_fmt.fmt == -1) {
+        return SDL_SetError("Unsupported texture format");
+    }
 
     /* Setup GX2Texture */
     tdata->texture.surface.width = texture->w;
@@ -107,20 +110,6 @@ int WIIU_SDL_CreateTexture(SDL_Renderer * renderer, SDL_Texture * texture)
         return SDL_OutOfMemory();
     }
 
-    /* Initialize texture size uniform */
-    tdata->u_texSize = (WIIUVec4) {
-        .x = texture->w,
-        .y = texture->h,
-    };
-
-    /* Initialize color modifier uniform */
-    tdata->u_mod = (WIIUVec4) {
-        .r = (float)texture->r / 255.0f,
-        .g = (float)texture->g / 255.0f,
-        .b = (float)texture->b / 255.0f,
-        .a = (float)texture->a / 255.0f,
-    };
-
     /* Setup texture driver data */
     texture->driverdata = tdata;
 
@@ -161,6 +150,17 @@ void WIIU_SDL_UnlockTexture(SDL_Renderer * renderer, SDL_Texture * texture)
     GX2RUnlockSurfaceEx(&tdata->texture.surface, 0, 0);
 }
 
+void WIIU_SDL_SetTextureScaleMode(SDL_Renderer * renderer, SDL_Texture * texture, SDL_ScaleMode scaleMode)
+{
+    WIIU_TextureData *tdata = (WIIU_TextureData *) texture->driverdata;
+
+    if (texture->scaleMode == SDL_ScaleModeNearest) {
+        GX2InitSampler(&tdata->sampler, GX2_TEX_CLAMP_MODE_CLAMP, GX2_TEX_XY_FILTER_MODE_POINT);
+    } else {
+        GX2InitSampler(&tdata->sampler, GX2_TEX_CLAMP_MODE_CLAMP, GX2_TEX_XY_FILTER_MODE_LINEAR);
+    }
+}
+
 int WIIU_SDL_UpdateTexture(SDL_Renderer * renderer, SDL_Texture * texture,
                            const SDL_Rect * rect, const void *pixels, int pitch)
 {
@@ -183,28 +183,6 @@ int WIIU_SDL_UpdateTexture(SDL_Renderer * renderer, SDL_Texture * texture,
     return 0;
 }
 
-int WIIU_SDL_SetTextureColorMod(SDL_Renderer * renderer, SDL_Texture * texture)
-{
-    WIIU_TextureData *tdata = (WIIU_TextureData *) texture->driverdata;
-
-    /* Compute color mod */
-    tdata->u_mod.r = (float)texture->r / 255.0f;
-    tdata->u_mod.g = (float)texture->g / 255.0f;
-    tdata->u_mod.b = (float)texture->b / 255.0f;
-
-    return 0;
-}
-
-int WIIU_SDL_SetTextureAlphaMod(SDL_Renderer * renderer, SDL_Texture * texture)
-{
-    WIIU_TextureData *tdata = (WIIU_TextureData *) texture->driverdata;
-
-    /* Compute alpha mod */
-    tdata->u_mod.a = (float)texture->a / 255.0f;
-
-    return 0;
-}
-
 void WIIU_SDL_DestroyTexture(SDL_Renderer * renderer, SDL_Texture * texture)
 {
     WIIU_RenderData *data;
diff --git a/src/render/wiiu/SDL_rwindow_wiiu.c b/src/render/wiiu/SDL_rwindow_wiiu.c
index fff15be94..0403e68de 100644
--- a/src/render/wiiu/SDL_rwindow_wiiu.c
+++ b/src/render/wiiu/SDL_rwindow_wiiu.c
@@ -29,35 +29,10 @@
 void WIIU_SDL_WindowEvent(SDL_Renderer * renderer, const SDL_WindowEvent *event)
 {
     if (event->event == SDL_WINDOWEVENT_SIZE_CHANGED) {
-        /* Re-init the colour buffer etc. for new window size
-           TODO check: what if we're rendering to a texture when this happens?
-           SDL may handle this already, see SDL_render.c: SDL_RendererEventWatch */
+        /* Re-init the colour buffer etc. for new window size */
         WIIU_SDL_CreateWindowTex(renderer, renderer->window);
         WIIU_SDL_SetRenderTarget(renderer, NULL);
     }
 }
 
-/* We always output at whatever res the window is.
-   This may need to change if SDL_wiiuvideo is ever folded into SDL_render -
-   see SDL_*WindowTexture from SDL_video.c for how this could be done */
-int WIIU_SDL_GetOutputSize(SDL_Renderer * renderer, int *w, int *h)
-{
-    SDL_GetWindowSize(renderer->window, w, h);
-    return 0;
-}
-
-/* We handle all viewport changes in the render functions and shaders, so we
-   don't actually have to do anything here. SDL still requires we implement it. */
-int WIIU_SDL_UpdateViewport(SDL_Renderer * renderer)
-{
-    return 0;
-}
-
-/* Ideally this should change the GX2SetScissor values, but SetRenderTarget
-   needs refactoring first or these get overwritten. */
-int WIIU_SDL_UpdateClipRect(SDL_Renderer * renderer)
-{
-    return 0;
-}
-
 #endif //SDL_VIDEO_RENDER_WIIU
diff --git a/src/render/wiiu/SDL_shaders_wiiu.c b/src/render/wiiu/SDL_shaders_wiiu.c
new file mode 100644
index 000000000..858410c0b
--- /dev/null
+++ b/src/render/wiiu/SDL_shaders_wiiu.c
@@ -0,0 +1,74 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 2022 GaryOderNichts <garyodernichts@gmail.com>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#if SDL_VIDEO_RENDER_WIIU
+
+#include "SDL_shaders_wiiu.h"
+
+#include "shaders/colorShader.inc"
+#include "shaders/textureShader.inc"
+
+static WHBGfxShaderGroup shaderGroups[NUM_SHADERS];
+static int shaderRefCount = 0;
+
+void WIIU_SDL_CreateShaders(void)
+{
+    if (!shaderRefCount++) {
+        WHBGfxShaderGroup* colorShader = &shaderGroups[SHADER_COLOR];
+        WHBGfxShaderGroup* textureShader = &shaderGroups[SHADER_TEXTURE];
+
+        WHBGfxLoadGFDShaderGroup(colorShader, 0, colorShader_gsh);
+        WHBGfxInitShaderAttribute(colorShader, "a_position", 0, 0, GX2_ATTRIB_FORMAT_FLOAT_32_32);
+        WHBGfxInitShaderAttribute(colorShader, "a_color", 0, 8, GX2_ATTRIB_FORMAT_FLOAT_32_32_32_32);
+        WHBGfxInitFetchShader(colorShader);
+
+        WHBGfxLoadGFDShaderGroup(textureShader, 0, textureShader_gsh);
+        WHBGfxInitShaderAttribute(textureShader, "a_position", 0, 0, GX2_ATTRIB_FORMAT_FLOAT_32_32);
+        WHBGfxInitShaderAttribute(textureShader, "a_color", 0, 8, GX2_ATTRIB_FORMAT_UNORM_8_8_8_8);
+        WHBGfxInitShaderAttribute(textureShader, "a_texcoord", 0, 12, GX2_ATTRIB_FORMAT_FLOAT_32_32);
+        WHBGfxInitFetchShader(textureShader);
+    }
+}
+
+void WIIU_SDL_DestroyShaders(void)
+{
+    if (!--shaderRefCount) {
+        WHBGfxFreeShaderGroup(&shaderGroups[SHADER_COLOR]);
+        WHBGfxFreeShaderGroup(&shaderGroups[SHADER_TEXTURE]);
+    }
+}
+
+void WIIU_SDL_SelectShader(WIIU_ShaderType shader)
+{
+    WHBGfxShaderGroup* shaderGroup = &shaderGroups[shader];
+
+    GX2SetFetchShader(&shaderGroup->fetchShader);
+    GX2SetVertexShader(shaderGroup->vertexShader);
+    GX2SetPixelShader(shaderGroup->pixelShader);
+}
+
+WHBGfxShaderGroup* WIIU_SDL_GetShaderGroup(WIIU_ShaderType shader)
+{
+    return &shaderGroups[shader];
+}
+
+#endif //SDL_VIDEO_RENDER_WIIU
diff --git a/src/thread/wiiu/SDL_systls.c b/src/render/wiiu/SDL_shaders_wiiu.h
similarity index 63%
rename from src/thread/wiiu/SDL_systls.c
rename to src/render/wiiu/SDL_shaders_wiiu.h
index 241862e83..f4b19c90d 100644
--- a/src/thread/wiiu/SDL_systls.c
+++ b/src/render/wiiu/SDL_shaders_wiiu.h
@@ -1,6 +1,6 @@
 /*
   Simple DirectMedia Layer
-  Copyright (C) 1997-2018 Sam Lantinga <slouken@libsdl.org>
+  Copyright (C) 2022 GaryOderNichts <garyodernichts@gmail.com>
 
   This software is provided 'as-is', without any express or implied
   warranty.  In no event will the authors be held liable for any damages
@@ -18,21 +18,27 @@
      misrepresented as being the original software.
   3. This notice may not be removed or altered from any source distribution.
 */
-
 #include "../../SDL_internal.h"
-#include "../SDL_thread_c.h"
 
+#ifndef SDL_shaders_wiiu_h
+#define SDL_shaders_wiiu_h
+
+#if SDL_VIDEO_RENDER_WIIU
+
+#include <whb/gfx.h>
+
+typedef enum {
+    SHADER_INVALID = -1,
+    SHADER_COLOR,
+    SHADER_TEXTURE,
+    NUM_SHADERS
+} WIIU_ShaderType;
 
-SDL_TLSData *
-SDL_SYS_GetTLSData(void)
-{
-    return SDL_Generic_GetTLSData();
-}
+void WIIU_SDL_CreateShaders(void);
+void WIIU_SDL_DestroyShaders(void);
+void WIIU_SDL_SelectShader(WIIU_ShaderType shader);
+WHBGfxShaderGroup* WIIU_SDL_GetShaderGroup(WIIU_ShaderType shader);
 
-int
-SDL_SYS_SetTLSData(SDL_TLSData *data)
-{
-    return SDL_Generic_SetTLSData(data);
-}
+#endif /* SDL_VIDEO_RENDER_WIIU */
 
-/* vi: set ts=4 sw=4 expandtab: */
+#endif /* SDL_shaders_wiiu_h */
diff --git a/src/render/wiiu/shaders/.gitignore b/src/render/wiiu/shaders/.gitignore
new file mode 100644
index 000000000..3fd11a5ac
--- /dev/null
+++ b/src/render/wiiu/shaders/.gitignore
@@ -0,0 +1,2 @@
+latte-assembler
+*.gsh
diff --git a/src/render/wiiu/shaders/build_shaders.sh b/src/render/wiiu/shaders/build_shaders.sh
new file mode 100755
index 000000000..33b7cfc94
--- /dev/null
+++ b/src/render/wiiu/shaders/build_shaders.sh
@@ -0,0 +1,17 @@
+#!/bin/bash
+# to build shaders you need to place a copy of latte-assembler into the current directory
+# latte-assembler is part of decaf-emu <https://github.com/decaf-emu/decaf-emu>
+
+cd "${0%/*}"
+
+# colorShader
+echo "Building colorShader ..."
+./latte-assembler assemble --vsh=colorShader.vsh --psh=colorShader.psh colorShader.gsh
+xxd -i colorShader.gsh > colorShader.inc
+echo "Done!"
+
+# textureShader
+echo "Building textureShader ..."
+./latte-assembler assemble --vsh=textureShader.vsh --psh=textureShader.psh textureShader.gsh
+xxd -i textureShader.gsh > textureShader.inc
+echo "Done!"
diff --git a/src/render/wiiu/shaders/colorShader.inc b/src/render/wiiu/shaders/colorShader.inc
new file mode 100644
index 000000000..90543c0ad
--- /dev/null
+++ b/src/render/wiiu/shaders/colorShader.inc
@@ -0,0 +1,111 @@
+unsigned char colorShader_gsh[] = {
+  0x47, 0x66, 0x78, 0x32, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x07,
+  0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x4c, 0x4b, 0x7b,
+  0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x01, 0xc8, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0x00,
+  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+  0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x02,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xff,
+  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
+  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
+  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
+  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
+  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
+  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
+  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
+  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
+  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
+  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x01, 0x70,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xd0, 0x60, 0x01, 0x34,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x02, 0xd0, 0x60, 0x01, 0x48, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0xca, 0x70, 0x01, 0x68, 0x00, 0x00, 0x00, 0x1d, 0x00, 0x00, 0x00, 0x01,
+  0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xca, 0x70, 0x01, 0x78,
+  0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0xca, 0x70, 0x01, 0x84, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x01, 0x75, 0x5f, 0x70, 0x72, 0x6f, 0x6a, 0x65, 0x63,
+  0x74, 0x69, 0x6f, 0x6e, 0x00, 0x00, 0x00, 0x00, 0x61, 0x5f, 0x70, 0x6f,
+  0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x00, 0x00, 0x61, 0x5f, 0x63, 0x6f,
+  0x6c, 0x6f, 0x72, 0x00, 0xd0, 0x60, 0x00, 0xe8, 0xd0, 0x60, 0x01, 0x08,
+  0xca, 0x70, 0x01, 0x34, 0xca, 0x70, 0x01, 0x48, 0xca, 0x70, 0x01, 0x58,
+  0x7d, 0x42, 0x4c, 0x4b, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x01, 0x8c, 0xd0, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24,
+  0xd0, 0x60, 0x01, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05,
+  0xd0, 0x60, 0x01, 0x8c, 0x42, 0x4c, 0x4b, 0x7b, 0x00, 0x00, 0x00, 0x20,
+  0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05,
+  0x00, 0x00, 0x01, 0x70, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x09, 0x20, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x34, 0xa0, 0x3c, 0xa0, 0x00, 0x00, 0x88, 0x06, 0x00, 0x94,
+  0x00, 0x40, 0x01, 0x00, 0x88, 0x06, 0x20, 0x14, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0xfd, 0x60, 0x20, 0x00, 0x80, 0x00, 0x00, 0x00,
+  0xfd, 0x64, 0xa0, 0x00, 0x80, 0x00, 0x00, 0x20, 0xfd, 0x68, 0x20, 0x01,
+  0x80, 0x00, 0x00, 0x40, 0xfd, 0x6c, 0xa0, 0x81, 0x80, 0x00, 0x00, 0x60,
+  0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x80, 0x3f,
+  0x00, 0x00, 0x80, 0x3f, 0x01, 0x24, 0x20, 0x00, 0xfe, 0x00, 0xe2, 0x0f,
+  0x01, 0x24, 0xa0, 0x00, 0xfe, 0x04, 0xe2, 0x2f, 0x01, 0x24, 0x20, 0x01,
+  0xfe, 0x08, 0xe2, 0x4f, 0x01, 0x24, 0xa0, 0x81, 0xfe, 0x0c, 0xe2, 0x6f,
+  0x01, 0x00, 0x20, 0x00, 0xfe, 0x00, 0x22, 0x00, 0x01, 0x00, 0xa0, 0x00,
+  0xfe, 0x04, 0x22, 0x20, 0x01, 0x00, 0x20, 0x01, 0xfe, 0x08, 0x22, 0x40,
+  0x01, 0x00, 0xa0, 0x81, 0xfe, 0x0c, 0x22, 0x60, 0x42, 0x4c, 0x4b, 0x7b,
+  0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x01, 0x10, 0x00, 0x00, 0x00, 0x02,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02,
+  0x14, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
+  0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f,
+  0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7d, 0x42, 0x4c, 0x4b,
+  0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe8,
+  0xd0, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd0, 0x60, 0x00, 0xe8,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd0, 0x60, 0x00, 0xe8,
+  0x42, 0x4c, 0x4b, 0x7b, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x01,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x08,
+  0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x88, 0x06, 0x20, 0x94, 0x42, 0x4c, 0x4b, 0x7b, 0x00, 0x00, 0x00, 0x20,
+  0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00
+};
+unsigned int colorShader_gsh_len = 1296;
diff --git a/src/render/wiiu/shaders/colorShader.psh b/src/render/wiiu/shaders/colorShader.psh
new file mode 100644
index 000000000..bd3d9e700
--- /dev/null
+++ b/src/render/wiiu/shaders/colorShader.psh
@@ -0,0 +1,9 @@
+; $MODE = "UniformRegister"
+
+; $NUM_SPI_PS_INPUT_CNTL = 1
+; v_color R0
+; $SPI_PS_INPUT_CNTL[0].SEMANTIC = 0
+; $SPI_PS_INPUT_CNTL[0].DEFAULT_VAL = 1
+
+00 EXP_DONE: PIX0, R0
+END_OF_PROGRAM
diff --git a/src/render/wiiu/shaders/colorShader.vsh b/src/render/wiiu/shaders/colorShader.vsh
new file mode 100644
index 000000000..525f70dcf
--- /dev/null
+++ b/src/render/wiiu/shaders/colorShader.vsh
@@ -0,0 +1,40 @@
+; $MODE = "UniformRegister"
+
+; $SPI_VS_OUT_CONFIG.VS_EXPORT_COUNT = 0
+; $NUM_SPI_VS_OUT_ID = 1
+; vColor
+; $SPI_VS_OUT_ID[0].SEMANTIC_0 = 0
+
+; C0
+; $UNIFORM_VARS[0].name = "u_projection"
+; $UNIFORM_VARS[0].type = "mat4"
+; $UNIFORM_VARS[0].count = 1
+; $UNIFORM_VARS[0].block = -1
+; $UNIFORM_VARS[0].offset = 0
+
+; R1
+; $ATTRIB_VARS[0].name = "a_position"
+; $ATTRIB_VARS[0].type = "vec2"
+; $ATTRIB_VARS[0].location = 0
+; R2
+; $ATTRIB_VARS[1].name = "a_color"
+; $ATTRIB_VARS[1].type = "vec4"
+; $ATTRIB_VARS[1].location = 1
+
+00 CALL_FS NO_BARRIER
+01 ALU: ADDR(32) CNT(14)
+    0  x: MUL    ____,   1.0f, C3.x
+       y: MUL    ____,   1.0f, C3.y
+       z: MUL    ____,   1.0f, C3.z
+       w: MUL    ____,   1.0f, C3.w
+    1  x: MULADD R127.x, R1.y, C1.x, PV0.x
+       y: MULADD R127.y, R1.y, C1.y, PV0.y
+       z: MULADD R127.z, R1.y, C1.z, PV0.z
+       w: MULADD R127.w, R1.y, C1.w, PV0.w
+    2  x: MULADD R1.x,   R1.x, C0.x, PV0.x
+       y: MULADD R1.y,   R1.x, C0.y, PV0.y
+       z: MULADD R1.z,   R1.x, C0.z, PV0.z
+       w: MULADD R1.w,   R1.x, C0.w, PV0.w
+02 EXP_DONE: POS0, R1
+03 EXP_DONE: PARAM0, R2 NO_BARRIER
+END_OF_PROGRAM
diff --git a/src/render/wiiu/shaders/textureShader.inc b/src/render/wiiu/shaders/textureShader.inc
new file mode 100644
index 000000000..a47c11136
--- /dev/null
+++ b/src/render/wiiu/shaders/textureShader.inc
@@ -0,0 +1,149 @@
+unsigned char textureShader_gsh[] = {
+  0x47, 0x66, 0x78, 0x32, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x07,
+  0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x4c, 0x4b, 0x7b,
+  0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x01, 0xe8, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x04, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0x01, 0x00,
+  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+  0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x03,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02,
+  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
+  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
+  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
+  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
+  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
+  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
+  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
+  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
+  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
+  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x01, 0x70,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xd0, 0x60, 0x01, 0x34,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x03, 0xd0, 0x60, 0x01, 0x48, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0xca, 0x70, 0x01, 0x78, 0x00, 0x00, 0x00, 0x1d, 0x00, 0x00, 0x00, 0x01,
+  0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xca, 0x70, 0x01, 0x88,
+  0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0xca, 0x70, 0x01, 0x94, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x01, 0xca, 0x70, 0x01, 0x9c, 0x00, 0x00, 0x00, 0x09,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x75, 0x5f, 0x70, 0x72,
+  0x6f, 0x6a, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x00, 0x00, 0x00, 0x00,
+  0x61, 0x5f, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x00, 0x00,
+  0x61, 0x5f, 0x63, 0x6f, 0x6c, 0x6f, 0x72, 0x00, 0x61, 0x5f, 0x74, 0x65,
+  0x78, 0x63, 0x6f, 0x6f, 0x72, 0x64, 0x00, 0x00, 0xd0, 0x60, 0x00, 0xe8,
+  0xd0, 0x60, 0x01, 0x08, 0xca, 0x70, 0x01, 0x34, 0xca, 0x70, 0x01, 0x48,
+  0xca, 0x70, 0x01, 0x58, 0xca, 0x70, 0x01, 0x68, 0x7d, 0x42, 0x4c, 0x4b,
+  0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xa8,
+  0xd0, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0xd0, 0x60, 0x01, 0x78,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0xd0, 0x60, 0x01, 0xa8,
+  0x42, 0x4c, 0x4b, 0x7b, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x01,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x01, 0x70,
+  0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x80, 0x09, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0xa0,
+  0x3c, 0xa0, 0x00, 0x00, 0x88, 0x06, 0x00, 0x94, 0x00, 0x40, 0x01, 0x00,
+  0x88, 0x06, 0x80, 0x13, 0x01, 0xc0, 0x01, 0x00, 0x08, 0x09, 0x20, 0x14,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0xfd, 0x60, 0x20, 0x00, 0x80, 0x00, 0x00, 0x00, 0xfd, 0x64, 0xa0, 0x00,
+  0x80, 0x00, 0x00, 0x20, 0xfd, 0x68, 0x20, 0x01, 0x80, 0x00, 0x00, 0x40,
+  0xfd, 0x6c, 0xa0, 0x81, 0x80, 0x00, 0x00, 0x60, 0x00, 0x00, 0x80, 0x3f,
+  0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x80, 0x3f,
+  0x01, 0x24, 0x20, 0x00, 0xfe, 0x00, 0xe2, 0x0f, 0x01, 0x24, 0xa0, 0x00,
+  0xfe, 0x04, 0xe2, 0x2f, 0x01, 0x24, 0x20, 0x01, 0xfe, 0x08, 0xe2, 0x4f,
+  0x01, 0x24, 0xa0, 0x81, 0xfe, 0x0c, 0xe2, 0x6f, 0x01, 0x00, 0x20, 0x00,
+  0xfe, 0x00, 0x22, 0x00, 0x01, 0x00, 0xa0, 0x00, 0xfe, 0x04, 0x22, 0x20,
+  0x01, 0x00, 0x20, 0x01, 0xfe, 0x08, 0x22, 0x40, 0x01, 0x00, 0xa0, 0x81,
+  0xfe, 0x0c, 0x22, 0x60, 0x42, 0x4c, 0x4b, 0x7b, 0x00, 0x00, 0x00, 0x20,
+  0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06,
+  0x00, 0x00, 0x01, 0x30, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x14, 0x00, 0x00, 0x02,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x01, 0x00,
+  0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x01,
+  0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x90,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xd0, 0x60, 0x00, 0xe8,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0xca, 0x70, 0x00, 0xf4, 0x00, 0x00, 0x00, 0x01,
+  0x00, 0x00, 0x00, 0x00, 0x75, 0x5f, 0x74, 0x65, 0x78, 0x74, 0x75, 0x72,
+  0x65, 0x00, 0x00, 0x00, 0xd0, 0x60, 0x00, 0xd4, 0xca, 0x70, 0x00, 0xe8,
+  0x7d, 0x42, 0x4c, 0x4b, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x01, 0x00, 0xd0, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c,
+  0xd0, 0x60, 0x00, 0xf4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
+  0xd0, 0x60, 0x01, 0x00, 0x42, 0x4c, 0x4b, 0x7b, 0x00, 0x00, 0x00, 0x20,
+  0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07,
+  0x00, 0x00, 0x01, 0x90, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,
+  0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x80, 0x20, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x0c, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x88, 0x06, 0x20, 0x94,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00,
+  0x00, 0x24, 0x80, 0x00, 0x90, 0x00, 0x00, 0x20, 0x00, 0x28, 0x00, 0x01,
+  0x90, 0x00, 0x00, 0x40, 0x00, 0x2c, 0x80, 0x81, 0x90, 0x00, 0x00, 0x60,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x10, 0x00, 0x01, 0x00, 0x01, 0x10, 0x0d, 0xf0, 0x00, 0x00, 0x80, 0x10,
+  0x00, 0x00, 0x00, 0x00, 0x42, 0x4c, 0x4b, 0x7b, 0x00, 0x00, 0x00, 0x20,
+  0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00
+};
+unsigned int textureShader_gsh_len = 1752;
diff --git a/src/render/wiiu/shaders/textureShader.psh b/src/render/wiiu/shaders/textureShader.psh
new file mode 100644
index 000000000..18e7770f6
--- /dev/null
+++ b/src/render/wiiu/shaders/textureShader.psh
@@ -0,0 +1,23 @@
+; $MODE = "UniformRegister"
+
+; $NUM_SPI_PS_INPUT_CNTL = 2
+; v_color R0
+; $SPI_PS_INPUT_CNTL[0].SEMANTIC = 0
+; $SPI_PS_INPUT_CNTL[0].DEFAULT_VAL = 1
+; v_texCoord R1
+; $SPI_PS_INPUT_CNTL[1].SEMANTIC = 1
+; $SPI_PS_INPUT_CNTL[1].DEFAULT_VAL = 1
+
+; $SAMPLER_VARS[0].name = "u_texture"
+; $SAMPLER_VARS[0].type = "SAMPLER2D"
+; $SAMPLER_VARS[0].location = 0
+
+00 TEX: ADDR(48) CNT(1) VALID_PIX
+    0  SAMPLE R1, R1.xy0x, t0, s0
+01 ALU: ADDR(32) CNT(4)
+    1  x: MUL R0.x, R0.x, R1.x
+       y: MUL R0.y, R0.y, R1.y
+       z: MUL R0.z, R0.z, R1.z
+       w: MUL R0.w, R0.w, R1.w
+02 EXP_DONE: PIX0, R0
+END_OF_PROGRAM
diff --git a/src/render/wiiu/shaders/textureShader.vsh b/src/render/wiiu/shaders/textureShader.vsh
new file mode 100644
index 000000000..86288ff34
--- /dev/null
+++ b/src/render/wiiu/shaders/textureShader.vsh
@@ -0,0 +1,47 @@
+; $MODE = "UniformRegister"
+
+; $SPI_VS_OUT_CONFIG.VS_EXPORT_COUNT = 1
+; $NUM_SPI_VS_OUT_ID = 1
+; v_color
+; $SPI_VS_OUT_ID[0].SEMANTIC_0 = 0
+; v_texCoord
+; $SPI_VS_OUT_ID[0].SEMANTIC_1 = 1
+
+; C0
+; $UNIFORM_VARS[0].name = "u_projection"
+; $UNIFORM_VARS[0].type = "mat4"
+; $UNIFORM_VARS[0].count = 1
+; $UNIFORM_VARS[0].block = -1
+; $UNIFORM_VARS[0].offset = 0
+
+; R1
+; $ATTRIB_VARS[0].name = "a_position"
+; $ATTRIB_VARS[0].type = "vec2"
+; $ATTRIB_VARS[0].location = 0
+; R2
+; $ATTRIB_VARS[1].name = "a_color"
+; $ATTRIB_VARS[1].type = "vec4"
+; $ATTRIB_VARS[1].location = 1
+; R3
+; $ATTRIB_VARS[2].name = "a_texcoord"
+; $ATTRIB_VARS[2].type = "vec2"
+; $ATTRIB_VARS[2].location = 2
+
+00 CALL_FS NO_BARRIER
+01 ALU: ADDR(32) CNT(14)
+    0  x: MUL    ____,   1.0f, C3.x
+       y: MUL    ____,   1.0f, C3.y
+       z: MUL    ____,   1.0f, C3.z
+       w: MUL    ____,   1.0f, C3.w
+    1  x: MULADD R127.x, R1.y, C1.x, PV0.x
+       y: MULADD R127.y, R1.y, C1.y, PV0.y
+       z: MULADD R127.z, R1.y, C1.z, PV0.z
+       w: MULADD R127.w, R1.y, C1.w, PV0.w
+    2  x: MULADD R1.x,   R1.x, C0.x, PV0.x
+       y: MULADD R1.y,   R1.x, C0.y, PV0.y
+       z: MULADD R1.z,   R1.x, C0.z, PV0.z
+       w: MULADD R1.w,   R1.x, C0.w, PV0.w
+02 EXP_DONE: POS0, R1
+03 EXP: PARAM0, R2 NO_BARRIER
+04 EXP_DONE: PARAM1, R3.xy00 NO_BARRIER
+END_OF_PROGRAM
diff --git a/src/thread/wiiu/SDL_systhread.c b/src/thread/wiiu/SDL_systhread.c
index 364255339..9f4e246f1 100644
--- a/src/thread/wiiu/SDL_systhread.c
+++ b/src/thread/wiiu/SDL_systhread.c
@@ -46,7 +46,7 @@ thread_cleanup(OSThread *thread, void *stack)
 {
 }
 
-int SDL_SYS_CreateThread(SDL_Thread *thread, void *args)
+int SDL_SYS_CreateThread(SDL_Thread *thread)
 {
     OSThread *handle = (OSThread *)memalign(16, sizeof(OSThread));
     unsigned int stackSize = thread->stacksize ? thread->stacksize : 0x8000;
@@ -55,7 +55,7 @@ int SDL_SYS_CreateThread(SDL_Thread *thread, void *args)
 
     if (!OSCreateThread(handle,
                         (OSThreadEntryPointFn)SDL_RunThread,
-                        (int32_t)args,
+                        (int32_t)thread,
                         NULL,
                         stackTop,
                         stackSize,
diff --git a/src/timer/wiiu/SDL_systimer.c b/src/timer/wiiu/SDL_systimer.c
index 6c95e1eff..13c5257f2 100644
--- a/src/timer/wiiu/SDL_systimer.c
+++ b/src/timer/wiiu/SDL_systimer.c
@@ -49,8 +49,8 @@ SDL_TicksQuit(void)
     ticks_started = SDL_FALSE;
 }
 
-Uint32
-SDL_GetTicks(void)
+Uint64
+SDL_GetTicks64(void)
 {
     OSTime now;
 
@@ -59,7 +59,7 @@ SDL_GetTicks(void)
     }
 
     now = OSGetSystemTime();
-    return (Uint32)OSTicksToMilliseconds(now - start);
+    return (Uint64)OSTicksToMilliseconds(now - start);
 }
 
 Uint64
diff --git a/src/video/SDL_video.c b/src/video/SDL_video.c
index a22eb1be0..dff775187 100644
--- a/src/video/SDL_video.c
+++ b/src/video/SDL_video.c
@@ -1514,7 +1514,7 @@ static int SDL_UpdateFullscreenMode(SDL_Window *window, SDL_bool fullscreen)
 }
 
 #define CREATE_FLAGS \
-    (SDL_WINDOW_OPENGL | SDL_WINDOW_BORDERLESS | SDL_WINDOW_RESIZABLE | SDL_WINDOW_ALLOW_HIGHDPI | SDL_WINDOW_ALWAYS_ON_TOP | SDL_WINDOW_SKIP_TASKBAR | SDL_WINDOW_POPUP_MENU | SDL_WINDOW_UTILITY | SDL_WINDOW_TOOLTIP | SDL_WINDOW_VULKAN | SDL_WINDOW_MINIMIZED | SDL_WINDOW_METAL)
+    (SDL_WINDOW_OPENGL | SDL_WINDOW_BORDERLESS | SDL_WINDOW_RESIZABLE | SDL_WINDOW_ALLOW_HIGHDPI | SDL_WINDOW_ALWAYS_ON_TOP | SDL_WINDOW_SKIP_TASKBAR | SDL_WINDOW_POPUP_MENU | SDL_WINDOW_UTILITY | SDL_WINDOW_TOOLTIP | SDL_WINDOW_VULKAN | SDL_WINDOW_MINIMIZED | SDL_WINDOW_METAL | SDL_WINDOW_WIIU_GAMEPAD_ONLY | SDL_WINDOW_WIIU_TV_ONLY)
 
 static SDL_INLINE SDL_bool IsAcceptingDragAndDrop(void)
 {
diff --git a/src/video/wiiu/SDL_wiiuvideo.c b/src/video/wiiu/SDL_wiiuvideo.c
index 4efd4e72e..dc734023d 100644
--- a/src/video/wiiu/SDL_wiiuvideo.c
+++ b/src/video/wiiu/SDL_wiiuvideo.c
@@ -48,8 +48,6 @@
 
 #include <proc_ui/procui.h>
 
-#include "wiiu_shaders.h"
-
 static int WIIU_VideoInit(_THIS);
 static int WIIU_SetDisplayMode(_THIS, SDL_VideoDisplay *display, SDL_DisplayMode *mode);
 static void WIIU_VideoQuit(_THIS);
@@ -70,9 +68,6 @@ static int WIIU_VideoInit(_THIS)
 	}
 	WHBGfxInit();
 
-	// setup shader
-	wiiuInitTextureShader();
-
 	// add default mode (1280x720)
 	mode.format = SDL_PIXELFORMAT_RGBA8888;
 	mode.w = SCREEN_WIDTH;
@@ -89,13 +84,14 @@ static int WIIU_VideoInit(_THIS)
 
 static void WIIU_VideoQuit(_THIS)
 {
-	wiiuFreeTextureShader();
 	WHBGfxShutdown();
 	if (using_whb_proc) WHBProcShutdown();
 }
 
-static int WIIU_CreateSDLWindow(_THIS, SDL_Window *window) {
-	SDL_SetKeyboardFocus(window);
+static int WIIU_CreateSDLWindow(_THIS, SDL_Window *window)
+{
+    SDL_SetMouseFocus(window);
+    SDL_SetKeyboardFocus(window);
 	return 0;
 }
 
@@ -108,11 +104,6 @@ static void WIIU_PumpEvents(_THIS)
 {
 }
 
-static int WIIU_Available(void)
-{
-	return 1;
-}
-
 static void WIIU_DeleteDevice(SDL_VideoDevice *device)
 {
 	SDL_free(device);
@@ -141,7 +132,7 @@ static SDL_VideoDevice *WIIU_CreateDevice(int devindex)
 
 VideoBootStrap WIIU_bootstrap = {
 	"WiiU", "Video driver for Nintendo WiiU",
-	WIIU_Available, WIIU_CreateDevice
+	WIIU_CreateDevice
 };
 
 #endif /* SDL_VIDEO_DRIVER_WIIU */
diff --git a/src/video/wiiu/SDL_wiiuvideo.h b/src/video/wiiu/SDL_wiiuvideo.h
index 3cbf3df4c..cca415bb0 100644
--- a/src/video/wiiu/SDL_wiiuvideo.h
+++ b/src/video/wiiu/SDL_wiiuvideo.h
@@ -25,21 +25,10 @@
 #ifndef SDL_wiiuvideo_h
 #define SDL_wiiuvideo_h
 
-#include <gx2/texture.h>
-#include "SDL_surface.h"
-
-#define WIIU_WINDOW_DATA "_SDL_WiiUData"
-typedef struct
-{
-    SDL_Surface *surface;
-    GX2Texture texture;
-} WIIU_WindowData;
-
-typedef struct
-{
-    SDL_bool tv_window_exists;
-    SDL_bool drc_window_exists;
-    SDL_bool mirrored_window_exists;
-} WIIU_VideoDeviceData;
-
-#endif //SDL_wiiuvideo_h
+#if SDL_VIDEO_DRIVER_WIIU
+
+
+
+#endif /* SDL_VIDEO_DRIVER_WIIU */
+
+#endif /* SDL_wiiuvideo_h */
diff --git a/src/video/wiiu/shaders/build_shaders.sh b/src/video/wiiu/shaders/build_shaders.sh
deleted file mode 100755
index 490f82fb9..000000000
--- a/src/video/wiiu/shaders/build_shaders.sh
+++ /dev/null
@@ -1,14 +0,0 @@
-#!/bin/bash
-cd "${0%/*}"
-echo "Regenerating wiiu_shaders.c ..."
-latte-assembler compile colorShader.gsh --vsh colorShader.vsh --psh colorShader.psh
-latte-assembler compile textureShader.gsh --vsh textureShader.vsh --psh textureShader.psh
-xxd -i colorShader.gsh > colorShader.gsh.h
-xxd -i textureShader.gsh > textureShader.gsh.h
-sed -i '/_gsh_len/d' colorShader.gsh.h textureShader.gsh.h
-sed -i 's/colorShader_gsh/wiiuColorShaderData/g' colorShader.gsh.h
-sed -i 's/textureShader_gsh/wiiuTextureShaderData/g' textureShader.gsh.h
-cp wiiu_shaders.c.in ../wiiu_shaders.c
-cat colorShader.gsh.h textureShader.gsh.h >> ../wiiu_shaders.c
-rm -rf colorShader.gsh textureShader.gsh colorShader.gsh.h textureShader.gsh.h
-echo "Done!"
diff --git a/src/video/wiiu/shaders/colorShader.frag b/src/video/wiiu/shaders/colorShader.frag
deleted file mode 100644
index 651c31e11..000000000
--- a/src/video/wiiu/shaders/colorShader.frag
+++ /dev/null
@@ -1,10 +0,0 @@
-/* colorShader: fragment (pixel) shader (GLSL) */
-/* compile with ShaderAnalyzer (rv770) + fix latte-assembler messages */
-
-layout(location = 0) uniform vec4 u_color; /* color */
-
-void main()
-{
-    /* Set fragment color */
-    gl_FragColor = u_color;
-}
diff --git a/src/video/wiiu/shaders/colorShader.psh b/src/video/wiiu/shaders/colorShader.psh
deleted file mode 100644
index 5f821dc95..000000000
--- a/src/video/wiiu/shaders/colorShader.psh
+++ /dev/null
@@ -1,14 +0,0 @@
-; $MODE = "UniformRegister"
-; $UNIFORM_VARS[0].name = "u_color"
-; $UNIFORM_VARS[0].type = "float4"
-; $UNIFORM_VARS[0].count = 1
-; $UNIFORM_VARS[0].offset = 0
-; $UNIFORM_VARS[0].block = -1
-
-00 ALU: ADDR(32) CNT(4) 
-      0  x: MOV         R0.x,  C0.x      
-         y: MOV         R0.y,  C0.y      
-         z: MOV         R0.z,  C0.z      
-         w: MOV         R0.w,  C0.w      
-01 EXP_DONE: PIX0, R0
-END_OF_PROGRAM
diff --git a/src/video/wiiu/shaders/colorShader.vert b/src/video/wiiu/shaders/colorShader.vert
deleted file mode 100644
index 62dbe66c3..000000000
--- a/src/video/wiiu/shaders/colorShader.vert
+++ /dev/null
@@ -1,16 +0,0 @@
-/* colorShader: vertex shader (GLSL) */
-/* compile with ShaderAnalyzer (rv770) + fix latte-assembler messages */
-
-layout(location = 0) uniform vec2 u_viewSize; /* viewport size */
-layout(location = 0) in vec2 a_position;      /* vertex position */
-
-void main()
-{
-    /* Compute relative vertex position */
-    a_position.y = u_viewSize.y - a_position.y;
-    a_position.x = ((a_position.x / u_viewSize.x) * 2.0f) - 1.0f;
-    a_position.y = ((a_position.y / u_viewSize.y) * 2.0f) - 1.0f;
-
-    /* Set vertex position */
-    gl_Position = vec4(a_position, 0.0, 1.0);
-}
diff --git a/src/video/wiiu/shaders/colorShader.vsh b/src/video/wiiu/shaders/colorShader.vsh
deleted file mode 100644
index d8239b94e..000000000
--- a/src/video/wiiu/shaders/colorShader.vsh
+++ /dev/null
@@ -1,27 +0,0 @@
-; $MODE = "UniformRegister"
-; $UNIFORM_VARS[0].name = "u_viewSize"
-; $UNIFORM_VARS[0].type = "float2"
-; $UNIFORM_VARS[0].count = 1
-; $UNIFORM_VARS[0].offset = 0
-; $UNIFORM_VARS[0].block = -1
-; $ATTRIB_VARS[0].name = "a_position"
-; $ATTRIB_VARS[0].type = "float2"
-; $ATTRIB_VARS[0].location = 0
-
-00 CALL_FS NO_BARRIER
-01 ALU: ADDR(32) CNT(9)
-      0  x: ADD         R0.x, -R1.y,  C0.y
-         z: MOV         R2.z,  0.0f
-         w: MOV         R2.w,  (0x3F800000, 1.0f).x
-         t: RCP_e       ____,  C0.x
-      1  z: MUL_e*2     ____,  R1.x,  PS0
-         t: RCP_e       ____,  C0.y
-      2  x: MUL_e*2     ____,  R0.x,  PS1
-         t: ADD         R2.x,  PV1.z, -1.0f
-      3  y: ADD         R2.y,  PV2.x, -1.0f
-02 EXP_DONE: POS0, R2
-03 EXP_DONE: PARAM0, R0.____
-04 ALU: ADDR(41) CNT(1)
-      4  x: NOP         ____
-05 NOP NO_BARRIER
-END_OF_PROGRAM
diff --git a/src/video/wiiu/shaders/textureShader.frag b/src/video/wiiu/shaders/textureShader.frag
deleted file mode 100644
index 502f7aafa..000000000
--- a/src/video/wiiu/shaders/textureShader.frag
+++ /dev/null
@@ -1,13 +0,0 @@
-/* textureShader: fragment (pixel) shader (GLSL) */
-/* compile with ShaderAnalyzer (rv770) + fix latte-assembler messages */
-/* NOTE: Ash knows R600 but not GLSL, so the .psh may have changes not in this
-   file. */
-
-layout(location = 0) uniform sampler2D s_texture; /* texture sampler */
-in vec2 texCoord; /* relative texture postion passed from vertex shader */
-
-void main()
-{
-    /* Compute fragment color for texture/position */
-    gl_FragColor = texture2D(s_texture, texCoord);
-}
diff --git a/src/video/wiiu/shaders/textureShader.psh b/src/video/wiiu/shaders/textureShader.psh
deleted file mode 100644
index faca2f53e..000000000
--- a/src/video/wiiu/shaders/textureShader.psh
+++ /dev/null
@@ -1,22 +0,0 @@
-; $MODE = "UniformRegister"
-; $SAMPLER_VARS[0].name= "s_texture"
-; $SAMPLER_VARS[0].type= "sampler2D"
-; $SAMPLER_VARS[0].location = 0
-; $NUM_SPI_PS_INPUT_CNTL = 1
-; $SPI_PS_INPUT_CNTL[0].semantic = 0
-; $SPI_PS_INPUT_CNTL[0].default_val = 1
-; $UNIFORM_VARS[0].name = "u_mod"
-; $UNIFORM_VARS[0].type = "float4"
-; $UNIFORM_VARS[0].count = 1
-; $UNIFORM_VARS[0].offset = 0
-; $UNIFORM_VARS[0].block = -1
-
-00 TEX: ADDR(48) CNT(1) VALID_PIX
-      0  SAMPLE R0, R0.xy0x, t0, s0
-01 ALU: ADDR(32) CNT(4)
-      1  x: MUL R0.x, R0.x, C0.x
-         y: MUL R0.y, R0.y, C0.y
-         z: MUL R0.z, R0.z, C0.z
-         w: MUL R0.w, R0.w, C0.w
-02 EXP_DONE: PIX0, R0
-END_OF_PROGRAM
diff --git a/src/video/wiiu/shaders/textureShader.vert b/src/video/wiiu/shaders/textureShader.vert
deleted file mode 100644
index d559ca533..000000000
--- a/src/video/wiiu/shaders/textureShader.vert
+++ /dev/null
@@ -1,27 +0,0 @@
-/* textureShader: vertex shader (GLSL) */
-/* compile with ShaderAnalyzer (rv770) + fix latte-assembler messages */
-
-layout(location = 0) uniform vec2 u_viewSize; /* viewport size */
-layout(location = 1) uniform vec2 u_texSize;  /* texture size */
-layout(location = 0) in vec2 a_position;      /* vertex position */
-layout(location = 1) in vec2 a_texCoordIn;    /* texture position */
-out vec2 texCoord; /* relative texture postion passed to pixel shader */
-
-void main()
-{
-    /* Compute relative vertex position */
-    a_position.y = u_viewSize.y - a_position.y;
-    a_position.x = ((a_position.x / u_viewSize.x) * 2.0f) - 1.0f;
-    a_position.y = ((a_position.y / u_viewSize.y) * 2.0f) - 1.0f;
-
-    /* Set vertex position */
-    gl_Position = vec4(a_position, 0.0, 1.0);
-
-    /* Compute relative coordinate position */
-    a_texCoordIn.y = u_texSize.y - a_texCoordIn.y;
-    a_texCoordIn.x = a_texCoordIn.x / u_texSize.x;
-    a_texCoordIn.y = a_texCoordIn.y / u_texSize.y;
-
-    /* Pass texture coordinate to pixel shader */
-    texCoord = a_texCoordIn;
-}
diff --git a/src/video/wiiu/shaders/textureShader.vsh b/src/video/wiiu/shaders/textureShader.vsh
deleted file mode 100644
index 84f047e3e..000000000
--- a/src/video/wiiu/shaders/textureShader.vsh
+++ /dev/null
@@ -1,44 +0,0 @@
-; $MODE = "UniformRegister"
-; $UNIFORM_VARS[0].name = "u_viewSize"
-; $UNIFORM_VARS[0].type = "float2"
-; $UNIFORM_VARS[0].count = 1
-; $UNIFORM_VARS[0].offset = 4
-; $UNIFORM_VARS[0].block = -1
-; $UNIFORM_VARS[1].name = "u_texSize"
-; $UNIFORM_VARS[1].type = "float2"
-; $UNIFORM_VARS[1].count = 1
-; $UNIFORM_VARS[1].offset = 0
-; $UNIFORM_VARS[1].block = -1
-; $ATTRIB_VARS[0].name = "a_position"
-; $ATTRIB_VARS[0].type = "float2"
-; $ATTRIB_VARS[0].location = 0
-; $ATTRIB_VARS[1].name = "a_texCoordIn"
-; $ATTRIB_VARS[1].type = "float2"
-; $ATTRIB_VARS[1].location = 1
-; $NUM_SPI_VS_OUT_ID = 1
-; $SPI_VS_OUT_ID[0].semantic_0 = 0
-
-00 CALL_FS NO_BARRIER
-01 ALU: ADDR(32) CNT(16)
-      0  x: ADD         R127.x, -R2.y,  C0.y
-         z: MOV         R0.z,  0.0f
-         w: ADD         R127.w, -R1.y,  C1.y      VEC_120
-         t: RCP_e       ____,  C1.x
-      1  y: MUL_e*2     ____,  R1.x,  PS0
-         w: MOV         R0.w,  (0x3F800000, 1.0f).x
-         t: RCP_e       ____,  C1.y
-      2  x: MUL_e*2     ____,  R127.w,  PS1
-         t: ADD         R0.x,  PV1.y, -1.0f
-      3  y: ADD         R0.y,  PV2.x, -1.0f
-         t: RCP_e       ____,  C0.x
-      4  x: MUL_e       ____,  R2.x,  PS3
-         t: RCP_e       ____,  C0.y
-      5  x: MOV         R2.x,  PV4.x
-         z: MUL_e       ____,  R127.x,  PS4
-      6  y: MOV         R2.y,  PV5.z
-02 EXP_DONE: POS0, R0
-03 EXP_DONE: PARAM0, R2.xyzz  NO_BARRIER
-04 ALU: ADDR(48) CNT(1)
-      7  x: NOP         ____
-05 NOP NO_BARRIER
-END_OF_PROGRAM
diff --git a/src/video/wiiu/shaders/wiiu_shaders.c.in b/src/video/wiiu/shaders/wiiu_shaders.c.in
deleted file mode 100644
index de2901e32..000000000
--- a/src/video/wiiu/shaders/wiiu_shaders.c.in
+++ /dev/null
@@ -1,8 +0,0 @@
-#include <whb/gfx.h>
-
-WHBGfxShaderGroup wiiuTextureShader;
-int wiiuTextureShaderInit = 0;
-
-WHBGfxShaderGroup wiiuColorShader;
-int wiiuColorShaderInit = 0;
-
diff --git a/src/video/wiiu/wiiu_shaders.c b/src/video/wiiu/wiiu_shaders.c
deleted file mode 100644
index 341cb01f2..000000000
--- a/src/video/wiiu/wiiu_shaders.c
+++ /dev/null
@@ -1,293 +0,0 @@
-#include <whb/gfx.h>
-
-WHBGfxShaderGroup wiiuTextureShader;
-int wiiuTextureShaderInit = 0;
-
-WHBGfxShaderGroup wiiuColorShader;
-int wiiuColorShaderInit = 0;
-
-unsigned char wiiuColorShaderData[] = {
-  0x47, 0x66, 0x78, 0x32, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x07,
-  0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x4c, 0x4b, 0x7b,
-  0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x01, 0xa8, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
-  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-  0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x01,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
-  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
-  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
-  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
-  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
-  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
-  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
-  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
-  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
-  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
-  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x01, 0x50,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xd0, 0x60, 0x01, 0x34,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x01, 0xd0, 0x60, 0x01, 0x48, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0xca, 0x70, 0x01, 0x58, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x01,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xca, 0x70, 0x01, 0x64,
-  0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x75, 0x5f, 0x76, 0x69, 0x65, 0x77, 0x53, 0x69, 0x7a, 0x65, 0x00, 0x00,
-  0x61, 0x5f, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x00, 0x00,
-  0xd0, 0x60, 0x00, 0xe8, 0xd0, 0x60, 0x01, 0x08, 0xca, 0x70, 0x01, 0x34,
-  0xca, 0x70, 0x01, 0x48, 0x7d, 0x42, 0x4c, 0x4b, 0x00, 0x00, 0x00, 0x28,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x70, 0xd0, 0x60, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x18, 0xd0, 0x60, 0x01, 0x58, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x04, 0xd0, 0x60, 0x01, 0x70, 0x42, 0x4c, 0x4b, 0x7b,
-  0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x01, 0x50, 0x00, 0x00, 0x00, 0x01,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x09,
-  0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0xa0, 0x3c, 0x20, 0x01, 0x00,
-  0x88, 0x06, 0x00, 0x94, 0x00, 0x40, 0x00, 0x00, 0xff, 0x0f, 0x00, 0x94,
-  0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x14, 0xa0, 0x00,
-  0x10, 0x00, 0x00, 0x00, 0xf8, 0x08, 0x00, 0x00, 0x90, 0x0c, 0x40, 0x40,
-  0xf9, 0x00, 0x00, 0x00, 0x90, 0x0c, 0x40, 0x60, 0x00, 0x01, 0x00, 0x80,
-  0x00, 0x33, 0x00, 0x00, 0x01, 0xe0, 0x1f, 0x01, 0x20, 0x01, 0x00, 0x40,
-  0x00, 0x05, 0x00, 0x80, 0x00, 0x33, 0x00, 0x00, 0x00, 0xe0, 0x1f, 0x00,
-  0x20, 0x01, 0x00, 0x00, 0xfe, 0x28, 0x1f, 0x82, 0x10, 0x00, 0x40, 0x00,
-  0xfe, 0x20, 0x9f, 0x82, 0x10, 0x00, 0x40, 0x20, 0x00, 0x00, 0x00, 0x80,
-  0x00, 0x0d, 0x00, 0x00, 0x42, 0x4c, 0x4b, 0x7b, 0x00, 0x00, 0x00, 0x20,
-  0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06,
-  0x00, 0x00, 0x01, 0x34, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x14, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x01,
-  0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x20,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xd0, 0x60, 0x00, 0xe8,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0xca, 0x70, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x0b,
-  0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x75, 0x5f, 0x63, 0x6f, 0x6c, 0x6f, 0x72, 0x00, 0xd0, 0x60, 0x00, 0xbc,
-  0xca, 0x70, 0x00, 0xe8, 0x7d, 0x42, 0x4c, 0x4b, 0x00, 0x00, 0x00, 0x28,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x04, 0xd0, 0x60, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x08, 0xd0, 0x60, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x02, 0xd0, 0x60, 0x01, 0x04, 0x42, 0x4c, 0x4b, 0x7b,
-  0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x01, 0x20, 0x00, 0x00, 0x00, 0x03,
-  0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0xa0,
-  0x00, 0x00, 0x00, 0x00, 0x88, 0x06, 0x20, 0x94, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
-  0x90, 0x0c, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x90, 0x0c, 0x00, 0x20,
-  0x00, 0x09, 0x00, 0x00, 0x90, 0x0c, 0x00, 0x40, 0x00, 0x0d, 0x00, 0x80,
-  0x90, 0x0c, 0x00, 0x60, 0x42, 0x4c, 0x4b, 0x7b, 0x00, 0x00, 0x00, 0x20,
-  0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00
-};
-unsigned char wiiuTextureShaderData[] = {
-  0x47, 0x66, 0x78, 0x32, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x07,
-  0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x4c, 0x4b, 0x7b,
-  0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0x00,
-  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-  0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x02,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xff,
-  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
-  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
-  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
-  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
-  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
-  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
-  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
-  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
-  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
-  0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x01, 0x88,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xd0, 0x60, 0x01, 0x34,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x02, 0xd0, 0x60, 0x01, 0x5c, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0xca, 0x70, 0x01, 0x7c, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x01,
-  0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0xca, 0x70, 0x01, 0x88,
-  0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0xca, 0x70, 0x01, 0x94, 0x00, 0x00, 0x00, 0x09,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xca, 0x70, 0x01, 0xa0,
-  0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
-  0x75, 0x5f, 0x76, 0x69, 0x65, 0x77, 0x53, 0x69, 0x7a, 0x65, 0x00, 0x00,
-  0x75, 0x5f, 0x74, 0x65, 0x78, 0x53, 0x69, 0x7a, 0x65, 0x00, 0x00, 0x00,
-  0x61, 0x5f, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x00, 0x00,
-  0x61, 0x5f, 0x74, 0x65, 0x78, 0x43, 0x6f, 0x6f, 0x72, 0x64, 0x49, 0x6e,
-  0x00, 0x00, 0x00, 0x00, 0xd0, 0x60, 0x00, 0xe8, 0xd0, 0x60, 0x01, 0x08,
-  0xca, 0x70, 0x01, 0x34, 0xca, 0x70, 0x01, 0x48, 0xca, 0x70, 0x01, 0x5c,
-  0xca, 0x70, 0x01, 0x6c, 0x7d, 0x42, 0x4c, 0x4b, 0x00, 0x00, 0x00, 0x28,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xb0, 0xd0, 0x60, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x34, 0xd0, 0x60, 0x01, 0x7c, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x06, 0xd0, 0x60, 0x01, 0xb0, 0x42, 0x4c, 0x4b, 0x7b,
-  0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x01, 0x88, 0x00, 0x00, 0x00, 0x01,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x09,
-  0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0xa0, 0x3c, 0x20, 0x00, 0x00,
-  0x88, 0x06, 0x00, 0x94, 0x00, 0x40, 0x01, 0x00, 0x88, 0x04, 0x00, 0x14,
-  0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x14, 0xa0, 0x00,
-  0x10, 0x00, 0xe0, 0x0f, 0xf8, 0x08, 0x00, 0x00, 0x90, 0x0c, 0x00, 0x40,
-  0x01, 0x34, 0xa0, 0x00, 0x10, 0x00, 0xe8, 0x6f, 0x01, 0x01, 0x00, 0x80,
-  0x00, 0x33, 0x00, 0x00, 0x01, 0xe0, 0x9f, 0x00, 0x20, 0x01, 0x00, 0x20,
-  0xf9, 0x00, 0x00, 0x00, 0x90, 0x0c, 0x00, 0x60, 0x01, 0x05, 0x00, 0x80,
-  0x00, 0x33, 0x00, 0x00, 0x7f, 0xec, 0x1f, 0x00, 0x20, 0x01, 0x00, 0x00,
-  0xfe, 0x24, 0x1f, 0x82, 0x10, 0x00, 0x00, 0x00, 0xfe, 0x20, 0x9f, 0x02,
-  0x10, 0x00, 0x00, 0x20, 0x00, 0x01, 0x00, 0x80, 0x00, 0x33, 0x00, 0x00,
-  0x02, 0xe0, 0x1f, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x80,
-  0x00, 0x33, 0x00, 0x00, 0xfe, 0x00, 0x00, 0x00, 0x90, 0x0c, 0x40, 0x00,
-  0x7f, 0xe0, 0x1f, 0x81, 0x00, 0x01, 0x00, 0x40, 0xfe, 0x08, 0x00, 0x80,
-  0x90, 0x0c, 0x40, 0x20, 0x00, 0x00, 0x00, 0x80, 0x00, 0x0d, 0x00, 0x00,
-  0x42, 0x4c, 0x4b, 0x7b, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x01,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x01, 0x54,
-  0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
-  0x00, 0x00, 0x00, 0x02, 0x14, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x10,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x90, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x01, 0xd0, 0x60, 0x00, 0xe8, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x01, 0xd0, 0x60, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0xca, 0x70, 0x01, 0x08, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x01,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xca, 0x70, 0x01, 0x10,
-  0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x75, 0x5f, 0x6d, 0x6f,
-  0x64, 0x00, 0x00, 0x00, 0x73, 0x5f, 0x74, 0x65, 0x78, 0x74, 0x75, 0x72,
-  0x65, 0x00, 0x00, 0x00, 0xd0, 0x60, 0x00, 0xbc, 0xd0, 0x60, 0x00, 0xd4,
-  0xca, 0x70, 0x00, 0xe8, 0xca, 0x70, 0x00, 0xfc, 0x7d, 0x42, 0x4c, 0x4b,
-  0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x1c,
-  0xd0, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0xd0, 0x60, 0x01, 0x08,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xd0, 0x60, 0x01, 0x1c,
-  0x42, 0x4c, 0x4b, 0x7b, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x01,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x01, 0x90,
-  0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0xc0, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0xa0,
-  0x00, 0x00, 0x00, 0x00, 0x88, 0x06, 0x20, 0x94, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x20, 0x00, 0x90, 0x00, 0x00, 0x00, 0x00, 0x04, 0xa0, 0x00,
-  0x90, 0x00, 0x00, 0x20, 0x00, 0x08, 0x20, 0x01, 0x90, 0x00, 0x00, 0x40,
-  0x00, 0x0c, 0xa0, 0x81, 0x90, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
-  0x00, 0x10, 0x0d, 0xf0, 0x00, 0x00, 0x80, 0x10, 0x00, 0x00, 0x00, 0x00,
-  0x42, 0x4c, 0x4b, 0x7b, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x01,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00
-};
diff --git a/src/video/wiiu/wiiu_shaders.h b/src/video/wiiu/wiiu_shaders.h
deleted file mode 100644
index 0f9b98ca9..000000000
--- a/src/video/wiiu/wiiu_shaders.h
+++ /dev/null
@@ -1,83 +0,0 @@
-/*
-  Simple DirectMedia Layer
-  Copyright (C) 2018-2018 Ash Logan <ash@heyquark.com>
-  Copyright (C) 2018-2018 Roberto Van Eeden <r.r.qwertyuiop.r.r@gmail.com>
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the authors be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-*/
-
-#include "../../SDL_internal.h"
-
-#ifndef _WIIU_shaders_h
-#define _WIIU_shaders_h
-
-#include <whb/gfx.h>
-#include <gx2/shaders.h>
-
-extern unsigned char wiiuTextureShaderData[];
-extern unsigned char wiiuColorShaderData[];
-
-extern WHBGfxShaderGroup wiiuTextureShader;
-extern int wiiuTextureShaderInit;
-
-static inline void wiiuInitTextureShader() {
-    if (!wiiuTextureShaderInit) {
-        WHBGfxLoadGFDShaderGroup(&wiiuTextureShader, 0, wiiuTextureShaderData);
-	    WHBGfxInitShaderAttribute(&wiiuTextureShader, "a_position", 0, 0, GX2_ATTRIB_FORMAT_FLOAT_32_32);
-	    WHBGfxInitShaderAttribute(&wiiuTextureShader, "a_texCoordIn", 1, 0, GX2_ATTRIB_FORMAT_FLOAT_32_32);
-        WHBGfxInitFetchShader(&wiiuTextureShader);
-    }
-    wiiuTextureShaderInit++;
-}
-
-static inline void wiiuFreeTextureShader() {
-    if (wiiuTextureShaderInit)
-        if (!--wiiuTextureShaderInit)
-            WHBGfxFreeShaderGroup(&wiiuTextureShader);
-}
-
-static inline void wiiuSetTextureShader() {
-    GX2SetFetchShader(&wiiuTextureShader.fetchShader);
-    GX2SetVertexShader(wiiuTextureShader.vertexShader);
-    GX2SetPixelShader(wiiuTextureShader.pixelShader);
-}
-
-extern WHBGfxShaderGroup wiiuColorShader;
-extern int wiiuColorShaderInit;
-
-static inline void wiiuInitColorShader() {
-    if (!wiiuColorShaderInit) {
-        WHBGfxLoadGFDShaderGroup(&wiiuColorShader, 0, wiiuColorShaderData);
-        WHBGfxInitShaderAttribute(&wiiuColorShader, "a_position", 0, 0, GX2_ATTRIB_FORMAT_FLOAT_32_32);
-        WHBGfxInitFetchShader(&wiiuColorShader);
-    }
-    wiiuColorShaderInit++;
-}
-
-static inline void wiiuFreeColorShader() {
-    if (wiiuColorShaderInit)
-        if (!--wiiuColorShaderInit)
-            WHBGfxFreeShaderGroup(&wiiuColorShader);
-}
-
-static inline void wiiuSetColorShader() {
-    GX2SetFetchShader(&wiiuColorShader.fetchShader);
-    GX2SetVertexShader(wiiuColorShader.vertexShader);
-    GX2SetPixelShader(wiiuColorShader.pixelShader);
-}
-
-#endif //_WIIU_shaders_h
-- 
2.20.1


From 5b526cc458a7a0195649510fbe228ac52689e33b Mon Sep 17 00:00:00 2001
From: GaryOderNichts <12049776+GaryOderNichts@users.noreply.github.com>
Date: Tue, 23 Aug 2022 11:57:31 +0200
Subject: [PATCH 03/28] wiiu/render: Fix projection matrix

---
 src/render/wiiu/SDL_render_wiiu.c | 1 -
 src/render/wiiu/SDL_rqueue_wiiu.c | 3 ++-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/render/wiiu/SDL_render_wiiu.c b/src/render/wiiu/SDL_render_wiiu.c
index 06f2917ad..f758a3405 100644
--- a/src/render/wiiu/SDL_render_wiiu.c
+++ b/src/render/wiiu/SDL_render_wiiu.c
@@ -98,7 +98,6 @@ SDL_Renderer *WIIU_SDL_CreateRenderer(SDL_Window * window, Uint32 flags)
     data->drawState.blendMode = SDL_BLENDMODE_INVALID;
     data->drawState.shader = SHADER_INVALID;
     data->drawState.projectionMatrix[3][0] = -1.0f;
-    data->drawState.projectionMatrix[3][1] = 1.0f;
     data->drawState.projectionMatrix[3][3] = 1.0f;
 
     /* Make a texture for the window */
diff --git a/src/render/wiiu/SDL_rqueue_wiiu.c b/src/render/wiiu/SDL_rqueue_wiiu.c
index d4140d545..b8b7ee1f2 100644
--- a/src/render/wiiu/SDL_rqueue_wiiu.c
+++ b/src/render/wiiu/SDL_rqueue_wiiu.c
@@ -274,7 +274,8 @@ static int WIIU_SDL_SetDrawState(WIIU_RenderData * data, const SDL_RenderCommand
 
         if (viewport->w && viewport->h) {
             data->drawState.projectionMatrix[0][0] = 2.0f / viewport->w;
-            data->drawState.projectionMatrix[1][1] = 2.0f / viewport->h;
+            data->drawState.projectionMatrix[1][1] = (data->drawState.target ? 2.0f : -2.0f) / viewport->h;
+            data->drawState.projectionMatrix[3][1] = data->drawState.target ? -1.0f : 1.0f;
             matrixUpdated = SDL_TRUE;
         }
 
-- 
2.20.1


From 4d04202dfc97c8b0957c74f5b6a670170791b42d Mon Sep 17 00:00:00 2001
From: GaryOderNichts <12049776+GaryOderNichts@users.noreply.github.com>
Date: Tue, 23 Aug 2022 13:05:52 +0200
Subject: [PATCH 04/28] wiiu: replace WhbGfx

---
 src/render/wiiu/SDL_render_wiiu.c       |  19 +-
 src/render/wiiu/SDL_render_wiiu.h       |  10 +-
 src/render/wiiu/SDL_rpresent_wiiu.c     |  71 ++++---
 src/render/wiiu/SDL_rqueue_wiiu.c       |   6 +-
 src/render/wiiu/SDL_rtexture_wiiu.c     |   7 +
 src/render/wiiu/SDL_shaders_wiiu.c      |   2 +-
 src/render/wiiu/shaders/colorShader.vsh |   2 +-
 src/video/wiiu/SDL_wiiu_gfx_heap.c      | 203 ++++++++++++++++++
 src/video/wiiu/SDL_wiiu_gfx_heap.h      |  53 +++++
 src/video/wiiu/SDL_wiiuvideo.c          | 263 +++++++++++++++++++++---
 src/video/wiiu/SDL_wiiuvideo.h          |  23 +++
 11 files changed, 584 insertions(+), 75 deletions(-)
 create mode 100644 src/video/wiiu/SDL_wiiu_gfx_heap.c
 create mode 100644 src/video/wiiu/SDL_wiiu_gfx_heap.h

diff --git a/src/render/wiiu/SDL_render_wiiu.c b/src/render/wiiu/SDL_render_wiiu.c
index f758a3405..1cd5485d7 100644
--- a/src/render/wiiu/SDL_render_wiiu.c
+++ b/src/render/wiiu/SDL_render_wiiu.c
@@ -167,6 +167,13 @@ void WIIU_SDL_CreateWindowTex(SDL_Renderer * renderer, SDL_Window * window)
     WIIU_SDL_CreateTexture(renderer, &data->windowTex);
 }
 
+void WIIU_SDL_DestroyWindowTex(SDL_Renderer * renderer, SDL_Window * window)
+{
+    WIIU_RenderData *data = (WIIU_RenderData *) renderer->driverdata;
+
+    WIIU_SDL_DestroyTexture(renderer, &data->windowTex);
+}
+
 int WIIU_SDL_SetRenderTarget(SDL_Renderer * renderer, SDL_Texture * texture)
 {
     WIIU_RenderData *data = (WIIU_RenderData *) renderer->driverdata;
@@ -175,6 +182,9 @@ int WIIU_SDL_SetRenderTarget(SDL_Renderer * renderer, SDL_Texture * texture)
     WIIU_TextureData *tdata = (WIIU_TextureData *)((texture) ? texture->driverdata
                                                              : data->windowTex.driverdata);
 
+    /* make sure we're using the correct renderer ctx */
+    GX2SetContextState(data->ctx);
+
     /* Wait for the texture rendering to finish */
     WIIU_TextureCheckWaitRendering(data, tdata);
 
@@ -189,11 +199,14 @@ int WIIU_SDL_SetRenderTarget(SDL_Renderer * renderer, SDL_Texture * texture)
 void WIIU_SDL_DestroyRenderer(SDL_Renderer * renderer)
 {
     WIIU_RenderData *data = (WIIU_RenderData *) renderer->driverdata;
+    WIIU_VideoData *videodata = (WIIU_VideoData *) SDL_GetVideoDevice()->driverdata;
 
-    GX2DrawDone();
+    if (videodata->hasForeground) {
+        GX2DrawDone();
 
-    WIIU_FreeRenderData(data);
-    WIIU_TextureDoneRendering(data);
+        WIIU_FreeRenderData(data);
+        WIIU_TextureDoneRendering(data);
+    }
 
     free(data->ctx);
 
diff --git a/src/render/wiiu/SDL_render_wiiu.h b/src/render/wiiu/SDL_render_wiiu.h
index f8b24f235..bb047f55d 100644
--- a/src/render/wiiu/SDL_render_wiiu.h
+++ b/src/render/wiiu/SDL_render_wiiu.h
@@ -31,6 +31,9 @@
 #include "SDL_pixels.h"
 #include "SDL_shaders_wiiu.h"
 
+#include "../../video/SDL_sysvideo.h"
+#include "../../video/wiiu/SDL_wiiuvideo.h"
+
 #include <gx2r/buffer.h>
 #include <gx2/context.h>
 #include <gx2/sampler.h>
@@ -99,7 +102,7 @@ struct WIIU_TextureData
     GX2Sampler sampler;
     GX2Texture texture;
     GX2ColorBuffer cbuf;
-    int isRendering;
+    SDL_bool isRendering;
 };
 
 /* Ask texture driver to allocate texture's memory from MEM1 */
@@ -136,6 +139,7 @@ void WIIU_SDL_DestroyRenderer(SDL_Renderer * renderer);
 
 /* Driver internal functions */
 void WIIU_SDL_CreateWindowTex(SDL_Renderer * renderer, SDL_Window * window);
+void WIIU_SDL_DestroyWindowTex(SDL_Renderer * renderer, SDL_Window * window);
 
 /* Utility/helper functions */
 static inline GX2RBuffer * WIIU_AllocRenderData(WIIU_RenderData *r, GX2RBuffer buffer)
@@ -166,7 +170,7 @@ static inline void WIIU_FreeRenderData(WIIU_RenderData *r)
 static inline void WIIU_TextureStartRendering(WIIU_RenderData *r, WIIU_TextureData *t)
 {
     WIIU_TextureDrawData *d = SDL_malloc(sizeof(WIIU_TextureDrawData));
-    t->isRendering = 1;
+    t->isRendering = SDL_TRUE;
     d->texdata = t;
     d->next = r->listdraw;
     r->listdraw = d;
@@ -177,7 +181,7 @@ static inline void WIIU_TextureDoneRendering(WIIU_RenderData *r)
     while (r->listdraw) {
         WIIU_TextureDrawData *d = r->listdraw;
         r->listdraw = r->listdraw->next;
-        d->texdata->isRendering = 0;
+        d->texdata->isRendering = SDL_FALSE;
         SDL_free(d);
     }
 }
diff --git a/src/render/wiiu/SDL_rpresent_wiiu.c b/src/render/wiiu/SDL_rpresent_wiiu.c
index 52fc71a97..d1a4839df 100644
--- a/src/render/wiiu/SDL_rpresent_wiiu.c
+++ b/src/render/wiiu/SDL_rpresent_wiiu.c
@@ -31,60 +31,63 @@
 #include <gx2/registers.h>
 #include <gx2/state.h>
 #include <gx2/draw.h>
+#include <gx2/swap.h>
+#include <gx2/display.h>
 #include <gx2r/buffer.h>
 #include <gx2r/draw.h>
 
-#define SCREEN_WIDTH    1280
-#define SCREEN_HEIGHT   720
-
 void WIIU_SDL_RenderPresent(SDL_Renderer * renderer)
 {
     WIIU_RenderData *data = (WIIU_RenderData *) renderer->driverdata;
     WIIU_TextureData *tdata = (WIIU_TextureData *) data->windowTex.driverdata;
     Uint32 flags = SDL_GetWindowFlags(renderer->window);
-    int win_x, win_y, win_w, win_h;
-
-    if (renderer->info.flags & SDL_RENDERER_PRESENTVSYNC) {
-    /*  NOTE watch libwhb's source to ensure this call only does vsync */
-        WHBGfxBeginRender();
-    }
-
-    /* Calculate and save positions TODO: make use of the window position */
-    if (flags & SDL_WINDOW_FULLSCREEN) {
-        win_x = 0;
-        win_y = 0;
-        win_w = SCREEN_WIDTH;
-        win_h = SCREEN_HEIGHT;
-    } else {
-        /* Center */
-        SDL_GetWindowSize(renderer->window, &win_w, &win_h);
-        win_x = (SCREEN_WIDTH - win_w) / 2;
-        win_y = (SCREEN_HEIGHT - win_h) / 2;
-    }
 
     /* Only render to TV if the window is *not* drc-only */
     if (!(flags & SDL_WINDOW_WIIU_GAMEPAD_ONLY)) {
-        WHBGfxBeginRenderTV();
-        GX2CopySurface(&tdata->texture.surface, 0, 0, &WHBGfxGetTVColourBuffer()->surface, 0, 0);
-        GX2SetContextState(data->ctx);
-        WHBGfxFinishRenderTV();
+        GX2CopyColorBufferToScanBuffer(&tdata->cbuf, GX2_SCAN_TARGET_TV);
     }
 
     if (!(flags & SDL_WINDOW_WIIU_TV_ONLY)) {
-        WHBGfxBeginRenderDRC();
-        GX2CopySurface(&tdata->texture.surface, 0, 0, &WHBGfxGetDRCColourBuffer()->surface, 0, 0);
-        GX2SetContextState(data->ctx);
-        WHBGfxFinishRenderDRC();
+        GX2CopyColorBufferToScanBuffer(&tdata->cbuf, GX2_SCAN_TARGET_DRC);
     }
 
-    WHBGfxFinishRender();
+    /* Swap buffers */
+    GX2SwapScanBuffers();
+    GX2Flush();
+
+    /* Restore SDL context state */
+    GX2SetContextState(data->ctx);
+
+    /* TV and DRC can now be enabled after the first frame was drawn */
+    GX2SetTVEnable(TRUE);
+    GX2SetDRCEnable(TRUE);
+
+    /* Wait for buffer flip */
+    uint32_t swap_count, flip_count;
+    OSTime last_flip, last_vsync;
+    uint32_t wait_count = 0;
+
+    while (true) {
+        GX2GetSwapStatus(&swap_count, &flip_count, &last_flip, &last_vsync);
+
+        if (flip_count >= swap_count) {
+            break;
+        }
+
+        if (wait_count >= 10) {
+            /* GPU timed out */
+            break;
+        }
+
+        wait_count++;
+        if (renderer->info.flags & SDL_RENDERER_PRESENTVSYNC) {
+            GX2WaitForVsync();
+        }
+        else {
+            GX2WaitForFlip();
+        }
+    }
 
     /* Free the list of render and draw data */
     WIIU_FreeRenderData(data);
     WIIU_TextureDoneRendering(data);
-
-    /* Restore SDL context state */
-    GX2SetContextState(data->ctx);
 }
 
 #endif /* SDL_VIDEO_RENDER_WIIU */
diff --git a/src/render/wiiu/SDL_rqueue_wiiu.c b/src/render/wiiu/SDL_rqueue_wiiu.c
index b8b7ee1f2..ce9bf9b29 100644
--- a/src/render/wiiu/SDL_rqueue_wiiu.c
+++ b/src/render/wiiu/SDL_rqueue_wiiu.c
@@ -351,12 +351,16 @@ int WIIU_SDL_RunCommandQueue(SDL_Renderer * renderer, SDL_RenderCommand *cmd, vo
 {
     WIIU_RenderData* data = (WIIU_RenderData*) renderer->driverdata;
 
+    /* make sure we're using the correct renderer ctx */
+    WIIU_SDL_SetRenderTarget(renderer, renderer->target);
+
     data->drawState.target = renderer->target;
     if (!data->drawState.target) {
         int w, h;
         SDL_GL_GetDrawableSize(renderer->window, &w, &h);
         if ((w != data->drawState.drawableWidth) || (h != data->drawState.drawableHeight)) {
-            data->drawState.viewportDirty = SDL_TRUE;  // if the window dimensions changed, invalidate the current viewport, etc.
+            /* if the window dimensions changed, invalidate the current viewport, etc. */
+            data->drawState.viewportDirty = SDL_TRUE;
             data->drawState.cliprectDirty = SDL_TRUE;
             data->drawState.drawableWidth = w;
             data->drawState.drawableHeight = h;
diff --git a/src/render/wiiu/SDL_rtexture_wiiu.c b/src/render/wiiu/SDL_rtexture_wiiu.c
index 7b507f6b8..eee69604a 100644
--- a/src/render/wiiu/SDL_rtexture_wiiu.c
+++ b/src/render/wiiu/SDL_rtexture_wiiu.c
@@ -198,6 +198,13 @@ void WIIU_SDL_DestroyTexture(SDL_Renderer * renderer, SDL_Texture * texture)
     /* Wait for the texture rendering to finish */
     WIIU_TextureCheckWaitRendering(data, tdata);
 
+    if (data->drawState.texture == texture) {
+        data->drawState.texture = NULL;
+    }
+    if (data->drawState.target == texture) {
+        data->drawState.target = NULL;
+    }
+
     GX2RDestroySurfaceEx(&tdata->cbuf.surface, 0);
     GX2RDestroySurfaceEx(&tdata->texture.surface, 0);
 
diff --git a/src/render/wiiu/SDL_shaders_wiiu.c b/src/render/wiiu/SDL_shaders_wiiu.c
index 858410c0b..99814440f 100644
--- a/src/render/wiiu/SDL_shaders_wiiu.c
+++ b/src/render/wiiu/SDL_shaders_wiiu.c
@@ -38,7 +38,7 @@ void WIIU_SDL_CreateShaders(void)
 
         WHBGfxLoadGFDShaderGroup(colorShader, 0, colorShader_gsh);
         WHBGfxInitShaderAttribute(colorShader, "a_position", 0, 0, GX2_ATTRIB_FORMAT_FLOAT_32_32);
-        WHBGfxInitShaderAttribute(colorShader, "a_color", 0, 8, GX2_ATTRIB_FORMAT_FLOAT_32_32_32_32);
+        WHBGfxInitShaderAttribute(colorShader, "a_color", 0, 8, GX2_ATTRIB_FORMAT_UNORM_8_8_8_8);
         WHBGfxInitFetchShader(colorShader);
 
         WHBGfxLoadGFDShaderGroup(textureShader, 0, textureShader_gsh);
diff --git a/src/render/wiiu/shaders/colorShader.vsh b/src/render/wiiu/shaders/colorShader.vsh
index 525f70dcf..ee69cbd3a 100644
--- a/src/render/wiiu/shaders/colorShader.vsh
+++ b/src/render/wiiu/shaders/colorShader.vsh
@@ -2,7 +2,7 @@
 
 ; $SPI_VS_OUT_CONFIG.VS_EXPORT_COUNT = 0
 ; $NUM_SPI_VS_OUT_ID = 1
-; vColor
+; v_color
 ; $SPI_VS_OUT_ID[0].SEMANTIC_0 = 0
 
 ; C0
diff --git a/src/video/wiiu/SDL_wiiu_gfx_heap.c b/src/video/wiiu/SDL_wiiu_gfx_heap.c
new file mode 100644
index 000000000..5e77367c7
--- /dev/null
+++ b/src/video/wiiu/SDL_wiiu_gfx_heap.c
@@ -0,0 +1,203 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (c) 2015-present devkitPro, wut Authors
+  Copyright (C) 2022 GaryOderNichts <garyodernichts@gmail.com>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#if SDL_VIDEO_DRIVER_WIIU
+
+#include "SDL_wiiu_gfx_heap.h"
+
+#include <stdio.h>
+#include <malloc.h>
+
+#include <coreinit/memheap.h>
+#include <coreinit/memdefaultheap.h>
+#include <coreinit/memexpheap.h>
+#include <coreinit/memfrmheap.h>
+
+#define FRM_HEAP_STATE_TAG 0x53444C32 // 'SDL2'
+
+static MEMHeapHandle GfxHeap_MEM1 = NULL;
+static MEMHeapHandle GfxHeap_Foreground = NULL;
+
+int WIIU_GfxHeap_MEM1Init(void)
+{
+    MEMHeapHandle heap = MEMGetBaseHeapHandle(MEM_BASE_HEAP_MEM1);
+    uint32_t size;
+    void *base;
+
+    if (!MEMRecordStateForFrmHeap(heap, FRM_HEAP_STATE_TAG)) {
+        printf("%s: MEMRecordStateForFrmHeap failed\n", __FUNCTION__);
+        return -1;
+    }
+
+    size = MEMGetAllocatableSizeForFrmHeapEx(heap, 4);
+    if (!size) {
+        printf("%s: MEMGetAllocatableSizeForFrmHeapEx == 0\n", __FUNCTION__);
+        return -1;
+    }
+
+    base = MEMAllocFromFrmHeapEx(heap, size, 4);
+    if (!base) {
+        printf("%s: MEMAllocFromFrmHeapEx(heap, 0x%X, 4) failed\n", __FUNCTION__, size);
+        return -1;
+    }
+
+    GfxHeap_MEM1 = MEMCreateExpHeapEx(base, size, 0);
+    if (!GfxHeap_MEM1) {
+        printf("%s: MEMCreateExpHeapEx(%p, 0x%X, 0) failed\n", __FUNCTION__, base, size);
+        return -1;
+    }
+
+   return 0;
+}
+
+int WIIU_GfxHeap_MEM1Destroy(void)
+{
+    MEMHeapHandle heap = MEMGetBaseHeapHandle(MEM_BASE_HEAP_MEM1);
+
+    if (GfxHeap_MEM1) {
+        MEMDestroyExpHeap(GfxHeap_MEM1);
+        GfxHeap_MEM1 = NULL;
+    }
+
+    MEMFreeByStateToFrmHeap(heap, FRM_HEAP_STATE_TAG);
+    return 0;
+}
+
+int WIIU_GfxHeap_ForegroundInit(void)
+{
+    MEMHeapHandle heap = MEMGetBaseHeapHandle(MEM_BASE_HEAP_FG);
+    uint32_t size;
+    void *base;
+
+    size = MEMGetAllocatableSizeForFrmHeapEx(heap, 4);
+    if (!size) {
+        printf("%s: MEMAllocFromFrmHeapEx(heap, 0x%X, 4)\n", __FUNCTION__, size);
+        return -1;
+    }
+
+    base = MEMAllocFromFrmHeapEx(heap, size, 4);
+    if (!base) {
+        printf("%s: MEMGetAllocatableSizeForFrmHeapEx == 0\n", __FUNCTION__);
+        return -1;
+    }
+
+    GfxHeap_Foreground = MEMCreateExpHeapEx(base, size, 0);
+    if (!GfxHeap_Foreground) {
+        printf("%s: MEMCreateExpHeapEx(%p, 0x%X, 0)\n", __FUNCTION__, base, size);
+        return -1;
+    }
+
+    return 0;
+}
+
+int WIIU_GfxHeap_ForegroundDestroy(void)
+{
+    MEMHeapHandle foreground = MEMGetBaseHeapHandle(MEM_BASE_HEAP_FG);
+
+    if (GfxHeap_Foreground) {
+        MEMDestroyExpHeap(GfxHeap_Foreground);
+        GfxHeap_Foreground = NULL;
+    }
+
+    MEMFreeToFrmHeap(foreground, MEM_FRM_HEAP_FREE_ALL);
+    return 0;
+}
+
+void *WIIU_GfxHeap_MEM1Alloc(uint32_t align, uint32_t size)
+{
+    void *block;
+
+    if (!GfxHeap_MEM1) {
+        return NULL;
+    }
+
+    if (align < 4) {
+        align = 4;
+    }
+
+    block = MEMAllocFromExpHeapEx(GfxHeap_MEM1, size, align);
+    return block;
+}
+
+void WIIU_GfxHeap_MEM1Free(void *block)
+{
+    if (!GfxHeap_MEM1) {
+        return;
+    }
+
+    MEMFreeToExpHeap(GfxHeap_MEM1, block);
+}
+
+void *WIIU_GfxHeap_ForegroundAlloc(uint32_t align, uint32_t size)
+{
+    void *block;
+
+    if (!GfxHeap_Foreground) {
+        return NULL;
+    }
+
+    if (align < 4) {
+        align = 4;
+    }
+
+    block = MEMAllocFromExpHeapEx(GfxHeap_Foreground, size, align);
+    return block;
+}
+
+void WIIU_GfxHeap_ForegroundFree(void *block)
+{
+    if (!GfxHeap_Foreground) {
+        return;
+    }
+
+    MEMFreeToExpHeap(GfxHeap_Foreground, block);
+}
+
+void *WIIU_GfxHeap_GX2RAlloc(GX2RResourceFlags flags, uint32_t size, uint32_t alignment)
+{
+    // Color, depth, scan buffers all belong in MEM1
+    if ((flags & (GX2R_RESOURCE_BIND_COLOR_BUFFER
+                | GX2R_RESOURCE_BIND_DEPTH_BUFFER
+                | GX2R_RESOURCE_BIND_SCAN_BUFFER
+                | GX2R_RESOURCE_USAGE_FORCE_MEM1))
+        && !(flags & GX2R_RESOURCE_USAGE_FORCE_MEM2)) {
+        return WIIU_GfxHeap_MEM1Alloc(alignment, size);
+    } else {
+        return memalign(alignment, size);
+    }
+}
+
+void WIIU_GfxHeap_GX2RFree(GX2RResourceFlags flags, void *block)
+{
+    if ((flags & (GX2R_RESOURCE_BIND_COLOR_BUFFER
+                | GX2R_RESOURCE_BIND_DEPTH_BUFFER
+                | GX2R_RESOURCE_BIND_SCAN_BUFFER
+                | GX2R_RESOURCE_USAGE_FORCE_MEM1))
+        && !(flags & GX2R_RESOURCE_USAGE_FORCE_MEM2)) {
+        return WIIU_GfxHeap_MEM1Free(block);
+    } else {
+        return free(block);
+    }
+}
+
+#endif /* SDL_VIDEO_DRIVER_WIIU */
diff --git a/src/video/wiiu/SDL_wiiu_gfx_heap.h b/src/video/wiiu/SDL_wiiu_gfx_heap.h
new file mode 100644
index 000000000..373913ada
--- /dev/null
+++ b/src/video/wiiu/SDL_wiiu_gfx_heap.h
@@ -0,0 +1,53 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (c) 2015-present devkitPro, wut Authors
+  Copyright (C) 2022 GaryOderNichts <garyodernichts@gmail.com>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#ifndef SDL_wiiu_gfx_heap_h
+#define SDL_wiiu_gfx_heap_h
+
+#if SDL_VIDEO_DRIVER_WIIU
+
+#include <gx2r/mem.h>
+
+int WIIU_GfxHeap_MEM1Init(void);
+
+int WIIU_GfxHeap_MEM1Destroy(void);
+
+int WIIU_GfxHeap_ForegroundInit(void);
+
+int WIIU_GfxHeap_ForegroundDestroy(void);
+
+void *WIIU_GfxHeap_MEM1Alloc(uint32_t align, uint32_t size);
+
+void WIIU_GfxHeap_MEM1Free(void *block);
+
+void *WIIU_GfxHeap_ForegroundAlloc(uint32_t align, uint32_t size);
+
+void WIIU_GfxHeap_ForegroundFree(void *block);
+
+void *WIIU_GfxHeap_GX2RAlloc(GX2RResourceFlags flags, uint32_t size, uint32_t alignment);
+
+void WIIU_GfxHeap_GX2RFree(GX2RResourceFlags flags, void *block);
+
+#endif /* SDL_VIDEO_DRIVER_WIIU */
+
+#endif /* SDL_wiiu_gfx_heap_h */
diff --git a/src/video/wiiu/SDL_wiiuvideo.c b/src/video/wiiu/SDL_wiiuvideo.c
index dc734023d..1edf51942 100644
--- a/src/video/wiiu/SDL_wiiuvideo.c
+++ b/src/video/wiiu/SDL_wiiuvideo.c
@@ -2,6 +2,7 @@
   Simple DirectMedia Layer
   Copyright (C) 2018-2018 Ash Logan <ash@heyquark.com>
   Copyright (C) 2018-2018 rw-r-r-0644 <r.r.qwertyuiop.r.r@gmail.com>
+  Copyright (C) 2022 GaryOderNichts <garyodernichts@gmail.com>
 
   This software is provided 'as-is', without any express or implied
   warranty.  In no event will the authors be held liable for any damages
@@ -20,13 +21,6 @@
   3. This notice may not be removed or altered from any source distribution.
 */
 
-/* This is basically just a stub at this point - all the magic happens in
- * SDL_Render, and the textureframebuffer stuff in SDL_video.c.
- * Potentially more could/should be done here, video modes and things.
- * Some design work will need to go into the responsibilities of render
- * vs video.
- */
-
 #include "../../SDL_internal.h"
 
 #if SDL_VIDEO_DRIVER_WIIU
@@ -37,81 +31,275 @@
 #include "SDL_syswm.h"
 #include "SDL_loadso.h"
 #include "SDL_events.h"
+#include "SDL_render.h"
 #include "../../events/SDL_mouse_c.h"
 #include "../../events/SDL_keyboard_c.h"
+#include "../../events/SDL_events_c.h"
 #include "SDL_wiiuvideo.h"
+#include "SDL_wiiu_gfx_heap.h"
+
+#include "../../render/wiiu/SDL_render_wiiu.h"
 
 #include <whb/proc.h>
-#include <whb/gfx.h>
+#include <stdio.h>
+#include <malloc.h>
 #include <string.h>
 #include <stdint.h>
 
 #include <proc_ui/procui.h>
 
-static int WIIU_VideoInit(_THIS);
-static int WIIU_SetDisplayMode(_THIS, SDL_VideoDisplay *display, SDL_DisplayMode *mode);
-static void WIIU_VideoQuit(_THIS);
-static void WIIU_PumpEvents(_THIS);
+#include <gx2/context.h>
+#include <gx2/display.h>
+#include <gx2/event.h>
+#include <gx2/mem.h>
+#include <gx2/state.h>
+#include <gx2r/mem.h>
+#include <gx2r/surface.h>
+
+#define DRC_SCREEN_WIDTH    854
+#define DRC_SCREEN_HEIGHT   480
+
+static int WIIU_ForegroundAcquired(_THIS)
+{
+	WIIU_VideoData *videodata = (WIIU_VideoData *) _this->driverdata;
+	SDL_Window* window = _this->windows;
+
+	videodata->hasForeground = SDL_TRUE;
+
+	// initialize gfx heaps once in forground
+	if (WIIU_GfxHeap_ForegroundInit() != 0) {
+		return -1;
+	}
+
+	if (WIIU_GfxHeap_MEM1Init() != 0) {
+		return -1;
+	}
+
+	// allocate and set scanbuffers
+	videodata->tvScanBuffer = WIIU_GfxHeap_ForegroundAlloc(GX2_SCAN_BUFFER_ALIGNMENT, videodata->tvScanBufferSize);
+	if (!videodata->tvScanBuffer) {
+		return -1;
+	}
+
+	GX2Invalidate(GX2_INVALIDATE_MODE_CPU, videodata->tvScanBuffer, videodata->tvScanBufferSize);
+	GX2SetTVBuffer(videodata->tvScanBuffer, videodata->tvScanBufferSize, videodata->tvRenderMode, GX2_SURFACE_FORMAT_UNORM_R8_G8_B8_A8, GX2_BUFFERING_MODE_DOUBLE);
+
+	videodata->drcScanBuffer = WIIU_GfxHeap_ForegroundAlloc(GX2_SCAN_BUFFER_ALIGNMENT, videodata->drcScanBufferSize);
+	if (!videodata->drcScanBuffer) {
+		return -1;
+	}
+
+	GX2Invalidate(GX2_INVALIDATE_MODE_CPU, videodata->drcScanBuffer, videodata->drcScanBufferSize);
+	GX2SetDRCBuffer(videodata->drcScanBuffer, videodata->drcScanBufferSize, videodata->drcRenderMode, GX2_SURFACE_FORMAT_UNORM_R8_G8_B8_A8, GX2_BUFFERING_MODE_DOUBLE);
 
-static int using_whb_proc = 0;
+	// TODO recreate MEM1 surfaces for all windows
+	while (window) {
+		SDL_Renderer* renderer = SDL_GetRenderer(window);
+		//WIIU_SDL_CreateWindowTex(renderer, window);
 
-#define SCREEN_WIDTH    1280
-#define SCREEN_HEIGHT   720
+		window = window->next;
+	}
+
+	return 0;
+}
+
+static int WIIU_ForegroundReleased(_THIS)
+{
+	WIIU_VideoData *videodata = (WIIU_VideoData *) _this->driverdata;
+	SDL_Window* window = _this->windows;
+
+	// make sure the GPU is done drawing
+	GX2DrawDone();
+
+	if (videodata->tvScanBuffer) {
+		WIIU_GfxHeap_ForegroundFree(videodata->tvScanBuffer);
+		videodata->tvScanBuffer = NULL;
+	}
+
+	if (videodata->drcScanBuffer) {
+		WIIU_GfxHeap_ForegroundFree(videodata->drcScanBuffer);
+		videodata->drcScanBuffer = NULL;
+	}
+
+	// TODO destroy MEM1 surfaces for all windows
+	while (window) {
+		SDL_Renderer* renderer = SDL_GetRenderer(window);
+		//WIIU_SDL_DestroyWindowTex(renderer, window);
+
+		window = window->next;
+	}
+
+	WIIU_GfxHeap_MEM1Destroy();
+	WIIU_GfxHeap_ForegroundDestroy();
+	videodata->hasForeground = SDL_FALSE;
+
+	return 0;
+}
 
 static int WIIU_VideoInit(_THIS)
 {
+	WIIU_VideoData *videodata = (WIIU_VideoData *) _this->driverdata;
+	uint32_t unk;
 	SDL_DisplayMode mode;
+	uint32_t* initAttribs;
 
+	// check if the user already set up procui or if we should handle it
 	if (!ProcUIIsRunning()) {
 		WHBProcInit();
-		using_whb_proc = 1;
+		
+		videodata->handleProcUI = SDL_TRUE;
+	}
+
+	// allocate command buffer pool
+	videodata->commandBufferPool = memalign(GX2_COMMAND_BUFFER_ALIGNMENT, GX2_COMMAND_BUFFER_SIZE);
+	if (!videodata->commandBufferPool) {
+		return SDL_OutOfMemory();
 	}
-	WHBGfxInit();
 
-	// add default mode (1280x720)
+	// initialize GX2
+	initAttribs = (uint32_t[]) {
+		GX2_INIT_CMD_BUF_BASE, (uintptr_t) videodata->commandBufferPool,
+		GX2_INIT_CMD_BUF_POOL_SIZE, GX2_COMMAND_BUFFER_SIZE,
+		GX2_INIT_ARGC, 0,
+		GX2_INIT_ARGV, 0,
+		GX2_INIT_END
+	};
+	GX2Init(initAttribs);
+
+	// figure out the TV render mode and size
+	switch(GX2GetSystemTVScanMode()) {
+	case GX2_TV_SCAN_MODE_480I:
+	case GX2_TV_SCAN_MODE_480P:
+		videodata->tvRenderMode = GX2_TV_RENDER_MODE_WIDE_480P;
+		videodata->tvWidth = 854;
+		videodata->tvHeight = 480;
+		break;
+	case GX2_TV_SCAN_MODE_1080I:
+	case GX2_TV_SCAN_MODE_1080P:
+		videodata->tvRenderMode = GX2_TV_RENDER_MODE_WIDE_1080P;
+		videodata->tvWidth = 1920;
+		videodata->tvHeight = 1080;
+		break;
+	case GX2_TV_SCAN_MODE_720P:
+	default:
+		videodata->tvRenderMode = GX2_TV_RENDER_MODE_WIDE_720P;
+		videodata->tvWidth = 1280;
+		videodata->tvHeight = 720;
+		break;
+	}
+
+	videodata->drcRenderMode = GX2GetSystemDRCScanMode();
+
+	// calculate the scanbuffer sizes
+	GX2CalcTVSize(videodata->tvRenderMode, GX2_SURFACE_FORMAT_UNORM_R8_G8_B8_A8, GX2_BUFFERING_MODE_DOUBLE, &videodata->tvScanBufferSize, &unk);
+	GX2CalcDRCSize(videodata->drcRenderMode, GX2_SURFACE_FORMAT_UNORM_R8_G8_B8_A8, GX2_BUFFERING_MODE_DOUBLE, &videodata->drcScanBufferSize, &unk);
+
+	// set GX2R allocator for the gfx heap
+	GX2RSetAllocator(&WIIU_GfxHeap_GX2RAlloc, &WIIU_GfxHeap_GX2RFree);
+
+	// register callbacks for acquiring and releasing foreground
+	ProcUIRegisterCallback(PROCUI_CALLBACK_ACQUIRE, (ProcUICallback) WIIU_ForegroundAcquired, _this, 100);
+	ProcUIRegisterCallback(PROCUI_CALLBACK_RELEASE, (ProcUICallback) WIIU_ForegroundReleased, _this, 100);
+
+	// if this is running, the application is already in foreground so call the callback
+	if (WIIU_ForegroundAcquired(_this) != 0) {
+		free(videodata->commandBufferPool);
+		videodata->commandBufferPool = NULL;
+		return SDL_OutOfMemory();
+	}
+
+    GX2SetTVScale(videodata->tvWidth, videodata->tvHeight);
+    GX2SetDRCScale(DRC_SCREEN_WIDTH, DRC_SCREEN_HEIGHT);
+
+	// add tv display
+	SDL_zero(mode);
 	mode.format = SDL_PIXELFORMAT_RGBA8888;
-	mode.w = SCREEN_WIDTH;
-	mode.h = SCREEN_HEIGHT;
+	mode.w = videodata->tvWidth;
+	mode.h = videodata->tvHeight;
 	mode.refresh_rate = 60;
-	mode.driverdata = NULL;
-	if (SDL_AddBasicVideoDisplay(&mode) < 0) {
-		return -1;
-	}
-	SDL_AddDisplayMode(&_this->displays[0], &mode);
+	SDL_AddBasicVideoDisplay(&mode);
+
+	// add drc display
+	SDL_zero(mode);
+	mode.format = SDL_PIXELFORMAT_RGBA8888;
+	mode.w = DRC_SCREEN_WIDTH;
+	mode.h = DRC_SCREEN_HEIGHT;
+	mode.refresh_rate = 60;
+	SDL_AddBasicVideoDisplay(&mode);
 
 	return 0;
 }
 
 static void WIIU_VideoQuit(_THIS)
 {
-	WHBGfxShutdown();
-	if (using_whb_proc) WHBProcShutdown();
+	WIIU_VideoData *videodata = (WIIU_VideoData *) _this->driverdata;
+
+	// if we're in foreground, destroy foreground data
+	if (videodata->hasForeground) {
+		WIIU_ForegroundReleased(_this);
+	}
+
+	// shutdown GX2 and free command buffer
+	GX2Shutdown();
+
+	if (videodata->commandBufferPool) {
+		free(videodata->commandBufferPool);
+		videodata->commandBufferPool = NULL;
+	}
+
+	if (videodata->handleProcUI) {
+		WHBProcShutdown();
+	}
 }
 
-static int WIIU_CreateSDLWindow(_THIS, SDL_Window *window)
+static int WIIU_CreateSDLWindow(_THIS, SDL_Window * window)
 {
-    SDL_SetMouseFocus(window);
-    SDL_SetKeyboardFocus(window);
+	// focus the window
+	SDL_SetMouseFocus(window);
+	SDL_SetKeyboardFocus(window);
 	return 0;
 }
 
-static int WIIU_SetDisplayMode(_THIS, SDL_VideoDisplay *display, SDL_DisplayMode *mode)
+static void WIIU_SetWindowSize(_THIS, SDL_Window * window)
+{
+}
+
+static void WIIU_DestroyWindow(_THIS, SDL_Window * window)
+{
+}
+
+static void WIIU_GetDisplayModes(_THIS, SDL_VideoDisplay * display)
+{
+	// we currently only have one mode per display, which is the current one
+	SDL_AddDisplayMode(display, &display->current_mode);
+}
+
+static int WIIU_SetDisplayMode(_THIS, SDL_VideoDisplay * display, SDL_DisplayMode * mode)
 {
 	return 0;
 }
 
 static void WIIU_PumpEvents(_THIS)
 {
+	WIIU_VideoData *videodata = (WIIU_VideoData *) _this->driverdata;
+
+	if (videodata->handleProcUI) {
+		if (!WHBProcIsRunning()) {
+			SDL_SendQuit();
+		}
+	}
 }
 
 static void WIIU_DeleteDevice(SDL_VideoDevice *device)
 {
+	SDL_free(device->driverdata);
 	SDL_free(device);
 }
 
 static SDL_VideoDevice *WIIU_CreateDevice(int devindex)
 {
 	SDL_VideoDevice *device;
+	WIIU_VideoData *videodata;
 
 	device = (SDL_VideoDevice*) SDL_calloc(1, sizeof(SDL_VideoDevice));
 	if(!device) {
@@ -119,11 +307,22 @@ static SDL_VideoDevice *WIIU_CreateDevice(int devindex)
 		return NULL;
 	}
 
+	videodata = (WIIU_VideoData*) SDL_calloc(1, sizeof(WIIU_VideoData));
+	if(!videodata) {
+		SDL_OutOfMemory();
+		return NULL;
+	}
+
+	device->driverdata = videodata;
+
 	device->VideoInit = WIIU_VideoInit;
 	device->VideoQuit = WIIU_VideoQuit;
+	device->CreateSDLWindow = WIIU_CreateSDLWindow;
+	device->SetWindowSize = WIIU_SetWindowSize;
+	device->DestroyWindow = WIIU_DestroyWindow;
+	device->GetDisplayModes = WIIU_GetDisplayModes;
 	device->SetDisplayMode = WIIU_SetDisplayMode;
 	device->PumpEvents = WIIU_PumpEvents;
-	device->CreateSDLWindow = WIIU_CreateSDLWindow;
 
 	device->free = WIIU_DeleteDevice;
 
diff --git a/src/video/wiiu/SDL_wiiuvideo.h b/src/video/wiiu/SDL_wiiuvideo.h
index cca415bb0..a635012d9 100644
--- a/src/video/wiiu/SDL_wiiuvideo.h
+++ b/src/video/wiiu/SDL_wiiuvideo.h
@@ -2,6 +2,7 @@
   Simple DirectMedia Layer
   Copyright (C) 2018-2018 Ash Logan <ash@heyquark.com>
   Copyright (C) 2018-2018 Roberto Van Eeden <r.r.qwertyuiop.r.r@gmail.com>
+  Copyright (C) 2022 GaryOderNichts <garyodernichts@gmail.com>
 
   This software is provided 'as-is', without any express or implied
   warranty.  In no event will the authors be held liable for any damages
@@ -27,7 +28,29 @@
 
 #if SDL_VIDEO_DRIVER_WIIU
 
+#include <gx2/surface.h>
 
+typedef struct WIIU_VideoData WIIU_VideoData;
+
+struct WIIU_VideoData
+{
+	// indicate if we're handling procui in SDL's events
+	SDL_bool handleProcUI;
+
+	SDL_bool hasForeground;
+
+	void *commandBufferPool;
+
+	GX2TVRenderMode tvRenderMode;
+	uint32_t tvWidth;
+	uint32_t tvHeight;
+	void *tvScanBuffer;
+	uint32_t tvScanBufferSize;
+
+	GX2DrcRenderMode drcRenderMode;
+	void *drcScanBuffer;
+	uint32_t drcScanBufferSize;
+};
 
 #endif /* SDL_VIDEO_DRIVER_WIIU */
 
-- 
2.20.1


From 7d3405e88675751dfba62ff0a9bf6c6d605e6958 Mon Sep 17 00:00:00 2001
From: Clownacy <clownacy@yahoo.com>
Date: Fri, 26 Aug 2022 14:11:25 +0100
Subject: [PATCH 05/28] wiiu: support SDL_GAMECONTROLLER_USE_BUTTON_LABELS

This way, SDL2's A/B/X/Y buttons are bound to the Wii U gamepad's A/B/X/Y buttons, instead of A being swapped with B, and X being swapped with Y.

Software that wants the button mappings to match an Xbox controller can set the `SDL_GAMECONTROLLER_USE_BUTTON_LABELS` hint to 0, as any other SDL2 software would.
---
 src/joystick/SDL_gamecontrollerdb.h | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/src/joystick/SDL_gamecontrollerdb.h b/src/joystick/SDL_gamecontrollerdb.h
index bb38d0455..37b130b72 100644
--- a/src/joystick/SDL_gamecontrollerdb.h
+++ b/src/joystick/SDL_gamecontrollerdb.h
@@ -993,7 +993,8 @@ static const char *s_ControllerMappings[] = {
     "000000004e696e74656e646f20334400,Nintendo 3DS,crc:3210,a:b0,b:b1,back:b2,dpdown:b7,dpleft:b5,dpright:b4,dpup:b6,leftshoulder:b9,lefttrigger:b14,leftx:a0,lefty:a1,rightshoulder:b8,righttrigger:b15,rightx:a2,righty:a3,start:b3,x:b10,y:b11,",
 #endif
 #if defined(SDL_JOYSTICK_WIIU)
-    "576969552047616d6570616400000000,Wii U Gamepad,a:b1,b:b0,back:b11,dpdown:b15,dpleft:b12,dpright:b14,dpup:b13,leftshoulder:b6,leftstick:b4,lefttrigger:b8,leftx:a0,lefty:a1,rightshoulder:b7,rightstick:b5,righttrigger:b9,rightx:a2,righty:a3,start:b10,x:b3,y:b2,",
+    "576969552047616d6570616400000000,Wii U Gamepad,a:b0,b:b1,back:b11,dpdown:b15,dpleft:b12,dpright:b14,dpup:b13,leftshoulder:b6,leftstick:b4,lefttrigger:b8,leftx:a0,lefty:a1,rightshoulder:b7,rightstick:b5,righttrigger:b9,rightx:a2,righty:a3,start:b10,x:b2,y:b3,hint:SDL_GAMECONTROLLER_USE_BUTTON_LABELS:=1,",
+    "576969552047616d6570616400000000,Wii U Gamepad,a:b1,b:b0,back:b11,dpdown:b15,dpleft:b12,dpright:b14,dpup:b13,leftshoulder:b6,leftstick:b4,lefttrigger:b8,leftx:a0,lefty:a1,rightshoulder:b7,rightstick:b5,righttrigger:b9,rightx:a2,righty:a3,start:b10,x:b3,y:b2,hint:!SDL_GAMECONTROLLER_USE_BUTTON_LABELS:=1,",
 #endif
     "hidapi,*,a:b0,b:b1,back:b4,dpdown:b12,dpleft:b13,dpright:b14,dpup:b11,guide:b5,leftshoulder:b9,leftstick:b7,lefttrigger:a4,leftx:a0,lefty:a1,rightshoulder:b10,rightstick:b8,righttrigger:a5,rightx:a2,righty:a3,start:b6,x:b2,y:b3,",
     NULL
-- 
2.20.1


From e2e7f27d37fc3efc370751fe227a1bc2b00898d9 Mon Sep 17 00:00:00 2001
From: Clownacy <Clownacy@users.noreply.github.com>
Date: Thu, 1 Sep 2022 20:40:09 +0100
Subject: [PATCH 06/28] Wii U: Add more Game Controllers.

Now SDL2's Game Controller API supports the Wii U Pro Controller,
the Wii Classic Controller, the Wii Remote with a Nunchuk, and the
Wii Remote without a Nunchuk (sideways).

I've tested this with everything but the Classic Controller, as I do
not own one to test with.
---
 src/joystick/SDL_gamecontrollerdb.h  | 10 ++++-
 src/joystick/wiiu/SDL_wiiujoystick.c | 60 ++++++++++++++++++++++++----
 src/joystick/wiiu/SDL_wiiujoystick.h | 23 ++++++++---
 3 files changed, 78 insertions(+), 15 deletions(-)

diff --git a/src/joystick/SDL_gamecontrollerdb.h b/src/joystick/SDL_gamecontrollerdb.h
index 37b130b72..6c86e94f6 100644
--- a/src/joystick/SDL_gamecontrollerdb.h
+++ b/src/joystick/SDL_gamecontrollerdb.h
@@ -993,8 +993,14 @@ static const char *s_ControllerMappings[] = {
     "000000004e696e74656e646f20334400,Nintendo 3DS,crc:3210,a:b0,b:b1,back:b2,dpdown:b7,dpleft:b5,dpright:b4,dpup:b6,leftshoulder:b9,lefttrigger:b14,leftx:a0,lefty:a1,rightshoulder:b8,righttrigger:b15,rightx:a2,righty:a3,start:b3,x:b10,y:b11,",
 #endif
 #if defined(SDL_JOYSTICK_WIIU)
-    "576969552047616d6570616400000000,Wii U Gamepad,a:b0,b:b1,back:b11,dpdown:b15,dpleft:b12,dpright:b14,dpup:b13,leftshoulder:b6,leftstick:b4,lefttrigger:b8,leftx:a0,lefty:a1,rightshoulder:b7,rightstick:b5,righttrigger:b9,rightx:a2,righty:a3,start:b10,x:b2,y:b3,hint:SDL_GAMECONTROLLER_USE_BUTTON_LABELS:=1,",
-    "576969552047616d6570616400000000,Wii U Gamepad,a:b1,b:b0,back:b11,dpdown:b15,dpleft:b12,dpright:b14,dpup:b13,leftshoulder:b6,leftstick:b4,lefttrigger:b8,leftx:a0,lefty:a1,rightshoulder:b7,rightstick:b5,righttrigger:b9,rightx:a2,righty:a3,start:b10,x:b3,y:b2,hint:!SDL_GAMECONTROLLER_USE_BUTTON_LABELS:=1,",
+    "49dcab4b72e942a1ad938e4aeb88d868,Wii U Gamepad,a:b0,b:b1,back:b11,dpdown:b15,dpleft:b12,dpright:b14,dpup:b13,leftshoulder:b6,leftstick:b4,lefttrigger:b8,leftx:a0,lefty:a1,rightshoulder:b7,rightstick:b5,righttrigger:b9,rightx:a2,righty:a3,start:b10,x:b2,y:b3,hint:SDL_GAMECONTROLLER_USE_BUTTON_LABELS:=1,",
+    "49dcab4b72e942a1ad938e4aeb88d868,Wii U Gamepad,a:b1,b:b0,back:b11,dpdown:b15,dpleft:b12,dpright:b14,dpup:b13,leftshoulder:b6,leftstick:b4,lefttrigger:b8,leftx:a0,lefty:a1,rightshoulder:b7,rightstick:b5,righttrigger:b9,rightx:a2,righty:a3,start:b10,x:b3,y:b2,hint:!SDL_GAMECONTROLLER_USE_BUTTON_LABELS:=1,",
+    "6972c1586f704c4e9d80cc8957abb814,Wii U Pro Controller,a:b0,b:b1,back:b11,dpdown:b15,dpleft:b12,dpright:b14,dpup:b13,leftshoulder:b6,leftstick:b4,lefttrigger:b8,leftx:a0,lefty:a1,rightshoulder:b7,rightstick:b5,righttrigger:b9,rightx:a2,righty:a3,start:b10,x:b2,y:b3,hint:SDL_GAMECONTROLLER_USE_BUTTON_LABELS:=1,",
+    "6972c1586f704c4e9d80cc8957abb814,Wii U Pro Controller,a:b1,b:b0,back:b11,dpdown:b15,dpleft:b12,dpright:b14,dpup:b13,leftshoulder:b6,leftstick:b4,lefttrigger:b8,leftx:a0,lefty:a1,rightshoulder:b7,rightstick:b5,righttrigger:b9,rightx:a2,righty:a3,start:b10,x:b3,y:b2,hint:!SDL_GAMECONTROLLER_USE_BUTTON_LABELS:=1,",
+    "fc547396886d4f55add913767f0f511c,Wii Classic Controller,a:b0,b:b1,back:b11,dpdown:b15,dpleft:b12,dpright:b14,dpup:b13,leftshoulder:b6,leftstick:b4,lefttrigger:b8,leftx:a0,lefty:a1,rightshoulder:b7,rightstick:b5,righttrigger:b9,rightx:a2,righty:a3,start:b10,x:b2,y:b3,hint:SDL_GAMECONTROLLER_USE_BUTTON_LABELS:=1,",
+    "fc547396886d4f55add913767f0f511c,Wii Classic Controller,a:b1,b:b0,back:b11,dpdown:b15,dpleft:b12,dpright:b14,dpup:b13,leftshoulder:b6,leftstick:b4,lefttrigger:b8,leftx:a0,lefty:a1,rightshoulder:b7,rightstick:b5,righttrigger:b9,rightx:a2,righty:a3,start:b10,x:b3,y:b2,hint:!SDL_GAMECONTROLLER_USE_BUTTON_LABELS:=1,",
+    "cb9d4bbb6936494d891719af55b27e4d,Wii Remote + Nunchuk,a:b0,b:b1,back:b11,dpdown:b15,dpleft:b12,dpright:b14,dpup:b13,leftshoulder:b6,leftstick:b4,lefttrigger:b8,leftx:a0,lefty:a1,rightshoulder:b7,rightstick:b5,righttrigger:b9,rightx:a2,righty:a3,start:b10,x:b2,y:b3,",
+    "88aa88b54e2742d2b4bbe04284a5a7a1,Wii Remote,a:b7,b:b6,back:b11,dpdown:b12,dpleft:b13,dpright:b15,dpup:b14,start:b10,x:b1,y:b0,",
 #endif
     "hidapi,*,a:b0,b:b1,back:b4,dpdown:b12,dpleft:b13,dpright:b14,dpup:b11,guide:b5,leftshoulder:b9,leftstick:b7,lefttrigger:a4,leftx:a0,lefty:a1,rightshoulder:b10,rightstick:b8,righttrigger:a5,rightx:a2,righty:a3,start:b6,x:b2,y:b3,",
     NULL
diff --git a/src/joystick/wiiu/SDL_wiiujoystick.c b/src/joystick/wiiu/SDL_wiiujoystick.c
index 4a7dfcc9f..93c262957 100644
--- a/src/joystick/wiiu/SDL_wiiujoystick.c
+++ b/src/joystick/wiiu/SDL_wiiujoystick.c
@@ -264,11 +264,57 @@ static void WIIU_JoystickSetDevicePlayerIndex(int device_index, int player_index
 /* Function to return the stable GUID for a plugged in device */
 static SDL_JoystickGUID WIIU_JoystickGetDeviceGUID(int device_index)
 {
+	/* These are random GUIDs that were generated with http://guid.one/ . */
 	SDL_JoystickGUID guid;
-	/* the GUID is just the first 16 chars of the name for now */
-	const char *name = WIIU_JoystickGetDeviceName(device_index);
-	SDL_zero(guid);
-	SDL_memcpy(&guid, name, SDL_min(sizeof(guid), SDL_strlen(name)));
+
+	const int wiiu_device = WIIU_GetDeviceForIndex(device_index);
+
+	switch (wiiu_device)
+	{
+		case WIIU_DEVICE_GAMEPAD:
+			guid = (SDL_JoystickGUID){{0x49, 0xdc, 0xab, 0x4b, 0x72, 0xe9, 0x42, 0xa1, 0xad, 0x93, 0x8e, 0x4a, 0xeb, 0x88, 0xd8, 0x68}};
+			break;
+
+		case WIIU_DEVICE_WPAD(0):
+		case WIIU_DEVICE_WPAD(1):
+		case WIIU_DEVICE_WPAD(2):
+		case WIIU_DEVICE_WPAD(3):
+			switch (lastKnownExts[WIIU_WPAD_CHAN(wiiu_device)])
+			{
+				case WPAD_EXT_CORE:
+				case WPAD_EXT_MPLUS:
+				default:
+					/* Wii Remote */
+					guid = (SDL_JoystickGUID){{0x88, 0xaa, 0x88, 0xb5, 0x4e, 0x27, 0x42, 0xd2, 0xb4, 0xbb, 0xe0, 0x42, 0x84, 0xa5, 0xa7, 0xa1}};
+					break;
+
+				case WPAD_EXT_NUNCHUK:
+				case WPAD_EXT_MPLUS_NUNCHUK:
+					/* Wii Remote + Nunchuk */
+					guid = (SDL_JoystickGUID){{0xcb, 0x9d, 0x4b, 0xbb, 0x69, 0x36, 0x49, 0x4d, 0x89, 0x17, 0x19, 0xaf, 0x55, 0xb2, 0x7e, 0x4d}};
+					break;
+
+				case WPAD_EXT_CLASSIC:
+				case WPAD_EXT_MPLUS_CLASSIC:
+					/* Wii Classic Controller */
+					guid = (SDL_JoystickGUID){{0xfc, 0x54, 0x73, 0x96, 0x88, 0x6d, 0x4f, 0x55, 0xad, 0xd9, 0x13, 0x76, 0x7f, 0x0f, 0x51, 0x1c}};
+					break;
+
+				case WPAD_EXT_PRO_CONTROLLER:
+					/* Wii U Pro Controller */
+					guid = (SDL_JoystickGUID){{0x69, 0x72, 0xc1, 0x58, 0x6f, 0x70, 0x4c, 0x4e, 0x9d, 0x80, 0xcc, 0x89, 0x57, 0xab, 0xb8, 0x14}};
+					break;
+			}
+
+			break;
+
+		default:
+			/* Unknown */
+			/* The iPhone backend for SDL2 does this if it can't get a GUID. */
+			SDL_zero(guid);
+			break;
+	}
+
 	return guid;
 }
 
@@ -319,7 +365,7 @@ static int WIIU_JoystickOpen(SDL_Joystick *joystick, int device_index)
 				}
 				case WPAD_EXT_NUNCHUK:
 				case WPAD_EXT_MPLUS_NUNCHUK: {
-					joystick->nbuttons = SIZEOF_ARR(wiimote_button_map);
+					joystick->nbuttons = SIZEOF_ARR(nunchuk_button_map);
 					joystick->naxes = 2;
 					joystick->nhats = 0;
 					break;
@@ -504,10 +550,10 @@ static void WIIU_JoystickUpdate(SDL_Joystick *joystick)
 		case WPAD_EXT_NUNCHUK:
 		case WPAD_EXT_MPLUS_NUNCHUK: {
 			for(int i = 0; i < joystick->nbuttons; i++)
-				if (kpad.trigger & wiimote_button_map[i])
+				if ((kpad.trigger | (kpad.nunchuck.trigger << 16)) & nunchuk_button_map[i])
 					SDL_PrivateJoystickButton(joystick, (Uint8)i, SDL_PRESSED);
 			for(int i = 0; i < joystick->nbuttons; i++)
-				if (kpad.release & wiimote_button_map[i])
+				if ((kpad.release | (kpad.nunchuck.release << 16)) & nunchuk_button_map[i])
 					SDL_PrivateJoystickButton(joystick, (Uint8)i, SDL_RELEASED);
 
 			x1 = (int16_t) ((kpad.nunchuck.stick.x) * 0x7ff0);
diff --git a/src/joystick/wiiu/SDL_wiiujoystick.h b/src/joystick/wiiu/SDL_wiiujoystick.h
index 7e26ef22e..24f79ca76 100644
--- a/src/joystick/wiiu/SDL_wiiujoystick.h
+++ b/src/joystick/wiiu/SDL_wiiujoystick.h
@@ -31,7 +31,7 @@
 
 #define SIZEOF_ARR(arr) (sizeof(arr) / sizeof(arr[0]))
 
-static VPADButtons vpad_button_map[] =
+static uint32_t vpad_button_map[] =
 {
     VPAD_BUTTON_A, VPAD_BUTTON_B, VPAD_BUTTON_X, VPAD_BUTTON_Y,
     VPAD_BUTTON_STICK_L, VPAD_BUTTON_STICK_R,
@@ -43,27 +43,38 @@ static VPADButtons vpad_button_map[] =
     VPAD_STICK_R_EMULATION_LEFT, VPAD_STICK_R_EMULATION_UP, VPAD_STICK_R_EMULATION_RIGHT, VPAD_STICK_R_EMULATION_DOWN
 };
 
-static WPADButton wiimote_button_map[] = {
+static uint32_t wiimote_button_map[] = {
+    WPAD_BUTTON_A, WPAD_BUTTON_B, 0, 0,
+    0, 0,
+    WPAD_BUTTON_1, WPAD_BUTTON_2,
+    0, 0,
+    WPAD_BUTTON_PLUS, WPAD_BUTTON_MINUS,
+    WPAD_BUTTON_LEFT, WPAD_BUTTON_UP, WPAD_BUTTON_RIGHT, WPAD_BUTTON_DOWN,
+};
+
+static uint32_t nunchuk_button_map[] = {
     WPAD_BUTTON_A, WPAD_BUTTON_B, WPAD_BUTTON_Z, WPAD_BUTTON_C,
     0, 0,
     WPAD_BUTTON_1, WPAD_BUTTON_2,
     0, 0,
     WPAD_BUTTON_PLUS, WPAD_BUTTON_MINUS,
     WPAD_BUTTON_LEFT, WPAD_BUTTON_UP, WPAD_BUTTON_RIGHT, WPAD_BUTTON_DOWN,
+    WPAD_NUNCHUK_STICK_EMULATION_LEFT << 16, WPAD_NUNCHUK_STICK_EMULATION_UP << 16, WPAD_NUNCHUK_STICK_EMULATION_RIGHT << 16, WPAD_NUNCHUK_STICK_EMULATION_DOWN << 16,
 };
 
-static WPADClassicButton classic_button_map[] = {
+static uint32_t classic_button_map[] = {
     WPAD_CLASSIC_BUTTON_A, WPAD_CLASSIC_BUTTON_B, WPAD_CLASSIC_BUTTON_X,
     WPAD_CLASSIC_BUTTON_Y,
     0, 0,
     WPAD_CLASSIC_BUTTON_L, WPAD_CLASSIC_BUTTON_R,
     WPAD_CLASSIC_BUTTON_ZL, WPAD_CLASSIC_BUTTON_ZR,
     WPAD_CLASSIC_BUTTON_PLUS, WPAD_CLASSIC_BUTTON_MINUS,
-    WPAD_CLASSIC_BUTTON_LEFT, WPAD_CLASSIC_BUTTON_UP, WPAD_CLASSIC_BUTTON_RIGHT,
-    WPAD_CLASSIC_BUTTON_DOWN,
+    WPAD_CLASSIC_BUTTON_LEFT, WPAD_CLASSIC_BUTTON_UP, WPAD_CLASSIC_BUTTON_RIGHT, WPAD_CLASSIC_BUTTON_DOWN,
+    WPAD_CLASSIC_STICK_L_EMULATION_LEFT, WPAD_CLASSIC_STICK_L_EMULATION_UP, WPAD_CLASSIC_STICK_L_EMULATION_RIGHT, WPAD_CLASSIC_STICK_L_EMULATION_DOWN,
+    WPAD_CLASSIC_STICK_R_EMULATION_LEFT, WPAD_CLASSIC_STICK_R_EMULATION_UP, WPAD_CLASSIC_STICK_R_EMULATION_RIGHT, WPAD_CLASSIC_STICK_R_EMULATION_DOWN,
 };
 
-static WPADProButton pro_button_map[] = {
+static uint32_t pro_button_map[] = {
     WPAD_PRO_BUTTON_A, WPAD_PRO_BUTTON_B, WPAD_PRO_BUTTON_X, WPAD_PRO_BUTTON_Y,
     WPAD_PRO_BUTTON_STICK_L, WPAD_PRO_BUTTON_STICK_R,
     WPAD_PRO_TRIGGER_L, WPAD_PRO_TRIGGER_R,
-- 
2.20.1


From bd755159a8ac8ef6380bad4a1083e7891abca1ff Mon Sep 17 00:00:00 2001
From: Clownacy <Clownacy@users.noreply.github.com>
Date: Thu, 1 Sep 2022 20:42:18 +0100
Subject: [PATCH 07/28] Wii U: Fix `WIIU_JoystickGetDevicePlayerIndex`.

Was using the wrong WPAD IDs.
---
 src/joystick/wiiu/SDL_wiiujoystick.c | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/src/joystick/wiiu/SDL_wiiujoystick.c b/src/joystick/wiiu/SDL_wiiujoystick.c
index 93c262957..7bf4adad4 100644
--- a/src/joystick/wiiu/SDL_wiiujoystick.c
+++ b/src/joystick/wiiu/SDL_wiiujoystick.c
@@ -248,10 +248,10 @@ static int WIIU_JoystickGetDevicePlayerIndex(int device_index)
 	int wiiu_device = WIIU_GetDeviceForIndex(device_index);
 	switch (wiiu_device) {
 		case WIIU_DEVICE_GAMEPAD: { return 0; }
-		case WIIU_DEVICE_WPAD(1): { return 1; }
-		case WIIU_DEVICE_WPAD(2): { return 2; }
-		case WIIU_DEVICE_WPAD(3): { return 3; }
-		case WIIU_DEVICE_WPAD(4): { return 4; }
+		case WIIU_DEVICE_WPAD(0): { return 1; }
+		case WIIU_DEVICE_WPAD(1): { return 2; }
+		case WIIU_DEVICE_WPAD(2): { return 3; }
+		case WIIU_DEVICE_WPAD(3): { return 4; }
 		default: { return -1; }
 	}
 
-- 
2.20.1


From 6b2475ce84baab3d6b18828eb765377165f47beb Mon Sep 17 00:00:00 2001
From: GaryOderNichts <12049776+GaryOderNichts@users.noreply.github.com>
Date: Wed, 7 Sep 2022 22:27:40 +0200
Subject: [PATCH 08/28] wiiu/render: Fix clip rect

---
 src/render/wiiu/SDL_rqueue_wiiu.c | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/src/render/wiiu/SDL_rqueue_wiiu.c b/src/render/wiiu/SDL_rqueue_wiiu.c
index ce9bf9b29..28e33d71d 100644
--- a/src/render/wiiu/SDL_rqueue_wiiu.c
+++ b/src/render/wiiu/SDL_rqueue_wiiu.c
@@ -289,10 +289,10 @@ static int WIIU_SDL_SetDrawState(WIIU_RenderData * data, const SDL_RenderCommand
 
         if (data->drawState.cliprectEnabled) {
             // make sure scissor is never larger than the colorbuffer to prevent memory corruption
-            scissor.x = SDL_min(viewport->w, rect->x);
-            scissor.y = SDL_min(viewport->h, rect->h);
-            scissor.w = SDL_min(viewport->w, rect->w);
-            scissor.h = SDL_min(viewport->w, rect->h);
+            scissor.x = SDL_clamp(rect->x, 0, viewport->w);
+            scissor.y = SDL_clamp(rect->y, 0, viewport->h);
+            scissor.w = SDL_clamp(rect->w, 0, viewport->w);
+            scissor.h = SDL_clamp(rect->h, 0, viewport->h);
         } else {
             scissor = *viewport;
         }
-- 
2.20.1


From a9e8d281c9be6ddb8b9ad2bbd895aed877bd2083 Mon Sep 17 00:00:00 2001
From: GaryOderNichts <12049776+GaryOderNichts@users.noreply.github.com>
Date: Thu, 8 Sep 2022 00:51:51 +0200
Subject: [PATCH 09/28] wiiu: make sure nothing gets drawn while in background

---
 src/render/SDL_render.c             |  6 ++++--
 src/render/wiiu/SDL_render_wiiu.c   |  6 +++---
 src/render/wiiu/SDL_rqueue_wiiu.c   |  7 +++++++
 src/render/wiiu/SDL_rtexture_wiiu.c | 17 ++++++++++++++---
 src/video/wiiu/SDL_wiiuvideo.c      | 25 +++++++++++++++++++++----
 5 files changed, 49 insertions(+), 12 deletions(-)

diff --git a/src/render/SDL_render.c b/src/render/SDL_render.c
index 979a711da..846b97b88 100644
--- a/src/render/SDL_render.c
+++ b/src/render/SDL_render.c
@@ -38,8 +38,10 @@ that will crash the app. However, these apps _should_ have used
 SDL_AddEventWatch to catch SDL_APP_WILLENTERBACKGROUND events and stopped
 drawing themselves. Other platforms still draw, as the compositor can use it,
 and more importantly: drawing to render targets isn't lost. But I still think
-this should probably be removed at some point in the future.  --ryan. */
-#if defined(__IPHONEOS__) || defined(__TVOS__) || defined(__ANDROID__)
+this should probably be removed at some point in the future.  --ryan.*/
+/* Same goes for Wii U. If you draw things while not in foreground the app
+will just crash. --gary*/
+#if defined(__IPHONEOS__) || defined(__TVOS__) || defined(__ANDROID__) || defined(__WIIU__)
 #define DONT_DRAW_WHILE_HIDDEN 1
 #else
 #define DONT_DRAW_WHILE_HIDDEN 0
diff --git a/src/render/wiiu/SDL_render_wiiu.c b/src/render/wiiu/SDL_render_wiiu.c
index 1cd5485d7..a81029dc4 100644
--- a/src/render/wiiu/SDL_render_wiiu.c
+++ b/src/render/wiiu/SDL_render_wiiu.c
@@ -203,11 +203,11 @@ void WIIU_SDL_DestroyRenderer(SDL_Renderer * renderer)
 
     if (videodata->hasForeground) {
         GX2DrawDone();
-
-        WIIU_FreeRenderData(data);
-        WIIU_TextureDoneRendering(data);
     }
 
+    WIIU_FreeRenderData(data);
+    WIIU_TextureDoneRendering(data);
+
     free(data->ctx);
 
     WIIU_SDL_DestroyShaders();
diff --git a/src/render/wiiu/SDL_rqueue_wiiu.c b/src/render/wiiu/SDL_rqueue_wiiu.c
index 28e33d71d..e6123cc84 100644
--- a/src/render/wiiu/SDL_rqueue_wiiu.c
+++ b/src/render/wiiu/SDL_rqueue_wiiu.c
@@ -350,6 +350,13 @@ static int WIIU_SDL_SetDrawState(WIIU_RenderData * data, const SDL_RenderCommand
 int WIIU_SDL_RunCommandQueue(SDL_Renderer * renderer, SDL_RenderCommand *cmd, void *vertices, size_t vertsize)
 {
     WIIU_RenderData* data = (WIIU_RenderData*) renderer->driverdata;
+    WIIU_VideoData *videodata = (WIIU_VideoData *) SDL_GetVideoDevice()->driverdata;
+
+    /* The command queue is still ran, even with DONT_DRAW_WHILE_HIDDEN
+       So check manually for foreground here */
+    if (!videodata->hasForeground) {
+        return 0;
+    }
 
     /* make sure we're using the correct renderer ctx */
     WIIU_SDL_SetRenderTarget(renderer, renderer->target);
diff --git a/src/render/wiiu/SDL_rtexture_wiiu.c b/src/render/wiiu/SDL_rtexture_wiiu.c
index eee69604a..828c33a17 100644
--- a/src/render/wiiu/SDL_rtexture_wiiu.c
+++ b/src/render/wiiu/SDL_rtexture_wiiu.c
@@ -122,13 +122,16 @@ int WIIU_SDL_CreateTexture(SDL_Renderer * renderer, SDL_Texture * texture)
 int WIIU_SDL_LockTexture(SDL_Renderer * renderer, SDL_Texture * texture,
                          const SDL_Rect * rect, void **pixels, int *pitch)
 {
+    WIIU_VideoData *videodata = (WIIU_VideoData *) SDL_GetVideoDevice()->driverdata;
     WIIU_RenderData *data = (WIIU_RenderData *) renderer->driverdata;
     WIIU_TextureData *tdata = (WIIU_TextureData *) texture->driverdata;
     Uint32 BytesPerPixel = SDL_BYTESPERPIXEL(texture->format);
     void* pixel_buffer;
 
-    /* Wait for the texture rendering to finish */
-    WIIU_TextureCheckWaitRendering(data, tdata);
+    if (videodata->hasForeground) {
+        /* Wait for the texture rendering to finish */
+        WIIU_TextureCheckWaitRendering(data, tdata);
+    }
 
     pixel_buffer = GX2RLockSurfaceEx(&tdata->texture.surface, 0, 0);
 
@@ -164,11 +167,16 @@ void WIIU_SDL_SetTextureScaleMode(SDL_Renderer * renderer, SDL_Texture * texture
 int WIIU_SDL_UpdateTexture(SDL_Renderer * renderer, SDL_Texture * texture,
                            const SDL_Rect * rect, const void *pixels, int pitch)
 {
+    WIIU_VideoData *videodata = (WIIU_VideoData *) SDL_GetVideoDevice()->driverdata;
     Uint32 BytesPerPixel = SDL_BYTESPERPIXEL(texture->format);
     size_t length = rect->w * BytesPerPixel;
     Uint8 *src = (Uint8 *) pixels, *dst;
     int row, dst_pitch;
 
+    if (!videodata->hasForeground) {
+        return 0;
+    }
+
     /* We write the rules, and we say all textures are streaming */
     WIIU_SDL_LockTexture(renderer, texture, rect, (void**)&dst, &dst_pitch);
 
@@ -185,6 +193,7 @@ int WIIU_SDL_UpdateTexture(SDL_Renderer * renderer, SDL_Texture * texture,
 
 void WIIU_SDL_DestroyTexture(SDL_Renderer * renderer, SDL_Texture * texture)
 {
+    WIIU_VideoData *videodata = (WIIU_VideoData *) SDL_GetVideoDevice()->driverdata;
     WIIU_RenderData *data;
     WIIU_TextureData *tdata;
 
@@ -196,7 +205,9 @@ void WIIU_SDL_DestroyTexture(SDL_Renderer * renderer, SDL_Texture * texture)
     tdata = (WIIU_TextureData *) texture->driverdata;
 
     /* Wait for the texture rendering to finish */
-    WIIU_TextureCheckWaitRendering(data, tdata);
+    if (videodata->hasForeground) {
+        WIIU_TextureCheckWaitRendering(data, tdata);
+    }
 
     if (data->drawState.texture == texture) {
         data->drawState.texture = NULL;
diff --git a/src/video/wiiu/SDL_wiiuvideo.c b/src/video/wiiu/SDL_wiiuvideo.c
index 1edf51942..04f010ba5 100644
--- a/src/video/wiiu/SDL_wiiuvideo.c
+++ b/src/video/wiiu/SDL_wiiuvideo.c
@@ -92,10 +92,17 @@ static int WIIU_ForegroundAcquired(_THIS)
 	GX2Invalidate(GX2_INVALIDATE_MODE_CPU, videodata->drcScanBuffer, videodata->drcScanBufferSize);
 	GX2SetDRCBuffer(videodata->drcScanBuffer, videodata->drcScanBufferSize, videodata->drcRenderMode, GX2_SURFACE_FORMAT_UNORM_R8_G8_B8_A8, GX2_BUFFERING_MODE_DOUBLE);
 
-	// TODO recreate MEM1 surfaces for all windows
 	while (window) {
 		SDL_Renderer* renderer = SDL_GetRenderer(window);
-		//WIIU_SDL_CreateWindowTex(renderer, window);
+
+		// Recreate the window texture, now that we have foreground memory available
+		if (renderer) {
+			// TODO
+			//WIIU_SDL_CreateWindowTex(renderer, window);
+		}
+
+		// We're now in foreground, window is visible
+		SDL_SendWindowEvent(window, SDL_WINDOWEVENT_SHOWN, 0, 0);
 
 		window = window->next;
 	}
@@ -121,10 +128,17 @@ static int WIIU_ForegroundReleased(_THIS)
 		videodata->drcScanBuffer = NULL;
 	}
 
-	// TODO destroy MEM1 surfaces for all windows
 	while (window) {
 		SDL_Renderer* renderer = SDL_GetRenderer(window);
-		//WIIU_SDL_DestroyWindowTex(renderer, window);
+
+		// No longer in foreground, window is no longer visible
+		SDL_SendWindowEvent(window, SDL_WINDOWEVENT_HIDDEN, 0, 0);
+
+		// Destroy window texture, we no longer have access to foreground memory
+		if (renderer) {
+			// TODO
+			//WIIU_SDL_DestroyWindowTex(renderer, window);
+		}
 
 		window = window->next;
 	}
@@ -315,6 +329,9 @@ static SDL_VideoDevice *WIIU_CreateDevice(int devindex)
 
 	device->driverdata = videodata;
 
+    // Setup amount of available displays
+    device->num_displays = 0;
+
 	device->VideoInit = WIIU_VideoInit;
 	device->VideoQuit = WIIU_VideoQuit;
 	device->CreateSDLWindow = WIIU_CreateSDLWindow;
-- 
2.20.1


From 2a6c2caeabc1c333cbff3a903ad4184e6d1acee2 Mon Sep 17 00:00:00 2001
From: GaryOderNichts <12049776+GaryOderNichts@users.noreply.github.com>
Date: Thu, 8 Sep 2022 22:54:03 +0200
Subject: [PATCH 10/28] wiiu/render: discard empty draw calls Causes a GPU hang
 otherwise

---
 src/render/wiiu/SDL_rqueue_wiiu.c | 5 +++++
 src/video/wiiu/SDL_wiiuvideo.c    | 4 ++--
 2 files changed, 7 insertions(+), 2 deletions(-)

diff --git a/src/render/wiiu/SDL_rqueue_wiiu.c b/src/render/wiiu/SDL_rqueue_wiiu.c
index e6123cc84..aa242abcb 100644
--- a/src/render/wiiu/SDL_rqueue_wiiu.c
+++ b/src/render/wiiu/SDL_rqueue_wiiu.c
@@ -145,6 +145,11 @@ int WIIU_SDL_QueueGeometry(SDL_Renderer * renderer, SDL_RenderCommand * cmd, SDL
     GX2RBuffer *vertexBuffer;
 
     int count = indices ? num_indices : num_vertices;
+    // discard empty draws or GX2 will crash
+    if (count < 1) {
+        return -1;
+    }
+
     cmd->data.draw.count = count;
 
     size_indices = indices ? size_indices : 0;
diff --git a/src/video/wiiu/SDL_wiiuvideo.c b/src/video/wiiu/SDL_wiiuvideo.c
index 04f010ba5..50327f58b 100644
--- a/src/video/wiiu/SDL_wiiuvideo.c
+++ b/src/video/wiiu/SDL_wiiuvideo.c
@@ -329,8 +329,8 @@ static SDL_VideoDevice *WIIU_CreateDevice(int devindex)
 
 	device->driverdata = videodata;
 
-    // Setup amount of available displays
-    device->num_displays = 0;
+	// Setup amount of available displays
+	device->num_displays = 0;
 
 	device->VideoInit = WIIU_VideoInit;
 	device->VideoQuit = WIIU_VideoQuit;
-- 
2.20.1


From 32777c470a57969164a3ac20d41b8578195acfaf Mon Sep 17 00:00:00 2001
From: GaryOderNichts <12049776+GaryOderNichts@users.noreply.github.com>
Date: Sun, 2 Oct 2022 17:36:09 +0200
Subject: [PATCH 11/28] wiiu/render: Don't hardcode vertex offsets

---
 src/render/wiiu/SDL_shaders_wiiu.c | 12 +++++++-----
 1 file changed, 7 insertions(+), 5 deletions(-)

diff --git a/src/render/wiiu/SDL_shaders_wiiu.c b/src/render/wiiu/SDL_shaders_wiiu.c
index 99814440f..679bded96 100644
--- a/src/render/wiiu/SDL_shaders_wiiu.c
+++ b/src/render/wiiu/SDL_shaders_wiiu.c
@@ -23,6 +23,8 @@
 #if SDL_VIDEO_RENDER_WIIU
 
 #include "SDL_shaders_wiiu.h"
+#include "SDL_render.h"
+#include "../SDL_sysrender.h"
 
 #include "shaders/colorShader.inc"
 #include "shaders/textureShader.inc"
@@ -37,14 +39,14 @@ void WIIU_SDL_CreateShaders(void)
         WHBGfxShaderGroup* textureShader = &shaderGroups[SHADER_TEXTURE];
 
         WHBGfxLoadGFDShaderGroup(colorShader, 0, colorShader_gsh);
-        WHBGfxInitShaderAttribute(colorShader, "a_position", 0, 0, GX2_ATTRIB_FORMAT_FLOAT_32_32);
-        WHBGfxInitShaderAttribute(colorShader, "a_color", 0, 8, GX2_ATTRIB_FORMAT_UNORM_8_8_8_8);
+        WHBGfxInitShaderAttribute(colorShader, "a_position", 0, offsetof(SDL_VertexSolid, position), GX2_ATTRIB_FORMAT_FLOAT_32_32);
+        WHBGfxInitShaderAttribute(colorShader, "a_color", 0, offsetof(SDL_VertexSolid, color), GX2_ATTRIB_FORMAT_UNORM_8_8_8_8);
         WHBGfxInitFetchShader(colorShader);
 
         WHBGfxLoadGFDShaderGroup(textureShader, 0, textureShader_gsh);
-        WHBGfxInitShaderAttribute(textureShader, "a_position", 0, 0, GX2_ATTRIB_FORMAT_FLOAT_32_32);
-        WHBGfxInitShaderAttribute(textureShader, "a_color", 0, 8, GX2_ATTRIB_FORMAT_UNORM_8_8_8_8);
-        WHBGfxInitShaderAttribute(textureShader, "a_texcoord", 0, 12, GX2_ATTRIB_FORMAT_FLOAT_32_32);
+        WHBGfxInitShaderAttribute(textureShader, "a_position", 0, offsetof(SDL_Vertex, position), GX2_ATTRIB_FORMAT_FLOAT_32_32);
+        WHBGfxInitShaderAttribute(textureShader, "a_color", 0, offsetof(SDL_Vertex, color), GX2_ATTRIB_FORMAT_UNORM_8_8_8_8);
+        WHBGfxInitShaderAttribute(textureShader, "a_texcoord", 0, offsetof(SDL_Vertex, tex_coord), GX2_ATTRIB_FORMAT_FLOAT_32_32);
         WHBGfxInitFetchShader(textureShader);
     }
 }
-- 
2.20.1


From a63e0d188d0c0db466a6e4eea4be549f3a15dfab Mon Sep 17 00:00:00 2001
From: GaryOderNichts <12049776+GaryOderNichts@users.noreply.github.com>
Date: Sun, 2 Oct 2022 17:36:38 +0200
Subject: [PATCH 12/28] wiiu/render: Don't allow updating render target while
 in background

---
 src/render/wiiu/SDL_render_wiiu.c | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/src/render/wiiu/SDL_render_wiiu.c b/src/render/wiiu/SDL_render_wiiu.c
index a81029dc4..c93fb958d 100644
--- a/src/render/wiiu/SDL_render_wiiu.c
+++ b/src/render/wiiu/SDL_render_wiiu.c
@@ -177,11 +177,16 @@ void WIIU_SDL_DestroyWindowTex(SDL_Renderer * renderer, SDL_Window * window)
 int WIIU_SDL_SetRenderTarget(SDL_Renderer * renderer, SDL_Texture * texture)
 {
     WIIU_RenderData *data = (WIIU_RenderData *) renderer->driverdata;
+    WIIU_VideoData *videodata = (WIIU_VideoData *) SDL_GetVideoDevice()->driverdata;
 
     /* Set window or texture as target */
     WIIU_TextureData *tdata = (WIIU_TextureData *)((texture) ? texture->driverdata
                                                              : data->windowTex.driverdata);
 
+    if (!videodata->hasForeground) {
+        return 0;
+    }
+
     /* make sure we're using the correct renderer ctx */
     GX2SetContextState(data->ctx);
 
-- 
2.20.1


From 2b0fd8fa1c8135f0d3629ba48033e4ec70ebb782 Mon Sep 17 00:00:00 2001
From: GaryOderNichts <12049776+GaryOderNichts@users.noreply.github.com>
Date: Sun, 2 Oct 2022 17:37:04 +0200
Subject: [PATCH 13/28] wiiu/render: Fix projection matrix for render targets

---
 src/render/wiiu/SDL_render_wiiu.c | 1 +
 src/render/wiiu/SDL_rqueue_wiiu.c | 3 +--
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/render/wiiu/SDL_render_wiiu.c b/src/render/wiiu/SDL_render_wiiu.c
index c93fb958d..9b92d7411 100644
--- a/src/render/wiiu/SDL_render_wiiu.c
+++ b/src/render/wiiu/SDL_render_wiiu.c
@@ -98,6 +98,7 @@ SDL_Renderer *WIIU_SDL_CreateRenderer(SDL_Window * window, Uint32 flags)
     data->drawState.blendMode = SDL_BLENDMODE_INVALID;
     data->drawState.shader = SHADER_INVALID;
     data->drawState.projectionMatrix[3][0] = -1.0f;
+    data->drawState.projectionMatrix[3][1] = 1.0f;
     data->drawState.projectionMatrix[3][3] = 1.0f;
 
     /* Make a texture for the window */
diff --git a/src/render/wiiu/SDL_rqueue_wiiu.c b/src/render/wiiu/SDL_rqueue_wiiu.c
index aa242abcb..166c1b7e5 100644
--- a/src/render/wiiu/SDL_rqueue_wiiu.c
+++ b/src/render/wiiu/SDL_rqueue_wiiu.c
@@ -279,8 +279,7 @@ static int WIIU_SDL_SetDrawState(WIIU_RenderData * data, const SDL_RenderCommand
 
         if (viewport->w && viewport->h) {
             data->drawState.projectionMatrix[0][0] = 2.0f / viewport->w;
-            data->drawState.projectionMatrix[1][1] = (data->drawState.target ? 2.0f : -2.0f) / viewport->h;
-            data->drawState.projectionMatrix[3][1] = data->drawState.target ? -1.0f : 1.0f;
+            data->drawState.projectionMatrix[1][1] = -2.0f / viewport->h;
             matrixUpdated = SDL_TRUE;
         }
 
-- 
2.20.1


From e236fb5d2ee0996db825239bd01871a68ae649f8 Mon Sep 17 00:00:00 2001
From: GaryOderNichts <12049776+GaryOderNichts@users.noreply.github.com>
Date: Thu, 6 Oct 2022 22:51:42 +0200
Subject: [PATCH 14/28] wiiu/render: Fix SDL_BLENDFACTOR_ONE_MINUS_DST_ALPHA

---
 src/render/wiiu/SDL_render_wiiu.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/render/wiiu/SDL_render_wiiu.h b/src/render/wiiu/SDL_render_wiiu.h
index bb047f55d..823c8022e 100644
--- a/src/render/wiiu/SDL_render_wiiu.h
+++ b/src/render/wiiu/SDL_render_wiiu.h
@@ -339,7 +339,7 @@ static inline GX2BlendMode WIIU_SDL_GetBlendMode(SDL_BlendFactor factor)
         case SDL_BLENDFACTOR_DST_ALPHA:
             return GX2_BLEND_MODE_DST_ALPHA;
         case SDL_BLENDFACTOR_ONE_MINUS_DST_ALPHA:
-            return GX2_BLEND_MODE_INV_DST_COLOR;
+            return GX2_BLEND_MODE_INV_DST_ALPHA;
         default:
             return -1;
     }
-- 
2.20.1


From af4d033d210787b5881f642d66ea0b3ba10f96f6 Mon Sep 17 00:00:00 2001
From: IntriguingTiles <jnickw@outlook.com>
Date: Mon, 12 Dec 2022 13:41:08 -0700
Subject: [PATCH 15/28] wiiu: Don't do anything in the ProcUI handlers if Video
 isn't running

---
 src/video/wiiu/SDL_wiiuvideo.c | 27 +++++++++++++++++++++++----
 1 file changed, 23 insertions(+), 4 deletions(-)

diff --git a/src/video/wiiu/SDL_wiiuvideo.c b/src/video/wiiu/SDL_wiiuvideo.c
index 50327f58b..b55ed7c63 100644
--- a/src/video/wiiu/SDL_wiiuvideo.c
+++ b/src/video/wiiu/SDL_wiiuvideo.c
@@ -59,11 +59,19 @@
 #define DRC_SCREEN_WIDTH    854
 #define DRC_SCREEN_HEIGHT   480
 
+static SDL_bool running = SDL_FALSE;
+
 static int WIIU_ForegroundAcquired(_THIS)
 {
-	WIIU_VideoData *videodata = (WIIU_VideoData *) _this->driverdata;
-	SDL_Window* window = _this->windows;
+	WIIU_VideoData *videodata;
+	SDL_Window* window;
 
+	if (!running) {
+		return 0;
+	}
+
+	videodata = (WIIU_VideoData *) _this->driverdata;
+	window = _this->windows;
 	videodata->hasForeground = SDL_TRUE;
 
 	// initialize gfx heaps once in forground
@@ -112,8 +120,15 @@ static int WIIU_ForegroundAcquired(_THIS)
 
 static int WIIU_ForegroundReleased(_THIS)
 {
-	WIIU_VideoData *videodata = (WIIU_VideoData *) _this->driverdata;
-	SDL_Window* window = _this->windows;
+	WIIU_VideoData *videodata;
+	SDL_Window* window;
+
+	if (!running) {
+		return 0;
+	}
+
+	videodata = (WIIU_VideoData *) _this->driverdata;
+	window = _this->windows;
 
 	// make sure the GPU is done drawing
 	GX2DrawDone();
@@ -215,6 +230,8 @@ static int WIIU_VideoInit(_THIS)
 	ProcUIRegisterCallback(PROCUI_CALLBACK_ACQUIRE, (ProcUICallback) WIIU_ForegroundAcquired, _this, 100);
 	ProcUIRegisterCallback(PROCUI_CALLBACK_RELEASE, (ProcUICallback) WIIU_ForegroundReleased, _this, 100);
 
+	running = SDL_TRUE;
+
 	// if this is running, the application is already in foreground so call the callback
 	if (WIIU_ForegroundAcquired(_this) != 0) {
 		free(videodata->commandBufferPool);
@@ -264,6 +281,8 @@ static void WIIU_VideoQuit(_THIS)
 	if (videodata->handleProcUI) {
 		WHBProcShutdown();
 	}
+
+	running = SDL_FALSE;
 }
 
 static int WIIU_CreateSDLWindow(_THIS, SDL_Window * window)
-- 
2.20.1


From 48e2bcd73a29c4a5b4279d84ebc49d07a0136670 Mon Sep 17 00:00:00 2001
From: GaryOderNichts <12049776+GaryOderNichts@users.noreply.github.com>
Date: Wed, 5 Apr 2023 18:14:19 +0200
Subject: [PATCH 16/28] wiiu/joystick: Fix touch holding detection

---
 src/joystick/wiiu/SDL_wiiujoystick.c | 10 ++++++----
 1 file changed, 6 insertions(+), 4 deletions(-)

diff --git a/src/joystick/wiiu/SDL_wiiujoystick.c b/src/joystick/wiiu/SDL_wiiujoystick.c
index 7bf4adad4..d448231a2 100644
--- a/src/joystick/wiiu/SDL_wiiujoystick.c
+++ b/src/joystick/wiiu/SDL_wiiujoystick.c
@@ -465,10 +465,12 @@ static void WIIU_JoystickUpdate(SDL_Joystick *joystick)
 		/* touchscreen */
 		VPADGetTPCalibratedPoint(VPAD_CHAN_0, &tpdata, &vpad.tpNormal);
 		if (tpdata.touched) {
-			/* Send an initial touch */
-			SDL_SendTouch(0, 0, NULL, SDL_TRUE,
-					(float) tpdata.x / 1280.0f,
-					(float) tpdata.y / 720.0f, 1);
+			if (!last_touched) {
+				/* Send an initial touch */
+				SDL_SendTouch(0, 0, NULL, SDL_TRUE,
+						(float) tpdata.x / 1280.0f,
+						(float) tpdata.y / 720.0f, 1);
+			}
 
 			/* Always send the motion */
 			SDL_SendTouchMotion(0, 0, NULL,
-- 
2.20.1


From f5f0de3afce6bdedf6e60faf7f151a0843229d54 Mon Sep 17 00:00:00 2001
From: GaryOderNichts <12049776+GaryOderNichts@users.noreply.github.com>
Date: Thu, 6 Apr 2023 17:34:01 +0200
Subject: [PATCH 17/28] wiiu/systhread: implement thread names

---
 src/thread/wiiu/SDL_systhread.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/thread/wiiu/SDL_systhread.c b/src/thread/wiiu/SDL_systhread.c
index 9f4e246f1..e2904e119 100644
--- a/src/thread/wiiu/SDL_systhread.c
+++ b/src/thread/wiiu/SDL_systhread.c
@@ -74,7 +74,7 @@ int SDL_SYS_CreateThread(SDL_Thread *thread)
 
 void SDL_SYS_SetupThread(const char *name)
 {
-    /* Do nothing. */
+    OSSetThreadName(OSGetCurrentThread(), name);
 }
 
 SDL_threadID SDL_ThreadID(void)
-- 
2.20.1


From c57900ca16e04f6b98eb0e398d47b8458573d7c6 Mon Sep 17 00:00:00 2001
From: GaryOderNichts <12049776+GaryOderNichts@users.noreply.github.com>
Date: Thu, 6 Apr 2023 23:52:57 +0200
Subject: [PATCH 18/28] wiiu: Use coreinit atomics / memory barriers

---
 CMakeLists.txt            |  5 +++++
 include/SDL_atomic.h      |  6 +++++-
 src/atomic/SDL_atomic.c   | 22 ++++++++++++++++++----
 src/atomic/SDL_spinlock.c | 10 +++++++---
 4 files changed, 35 insertions(+), 8 deletions(-)

diff --git a/CMakeLists.txt b/CMakeLists.txt
index d1dea4432..013dab9ee 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -237,6 +237,11 @@ if(USE_GCC OR USE_CLANG OR USE_INTELCC OR USE_QCC)
   set(OPT_DEF_GCC_ATOMICS ON)
 endif()
 
+if(WIIU)
+  # Prefer coreinit atomics on Wii U due to a hardware bug in load-exclusive and store-exclusive instructions
+  set(OPT_DEF_GCC_ATOMICS OFF)
+endif()
+
 # Default option knobs
 if(UNIX OR MINGW OR MSYS OR (USE_CLANG AND NOT WINDOWS) OR VITA OR PSP OR PS2 OR N3DS OR WIIU)
   set(OPT_DEF_LIBC ON)
diff --git a/include/SDL_atomic.h b/include/SDL_atomic.h
index 1dd816a38..26b5fd2ef 100644
--- a/include/SDL_atomic.h
+++ b/include/SDL_atomic.h
@@ -230,6 +230,10 @@ typedef void (*SDL_KernelMemoryBarrierFunc)();
 #include <mbarrier.h>
 #define SDL_MemoryBarrierRelease()  __machine_rel_barrier()
 #define SDL_MemoryBarrierAcquire()  __machine_acq_barrier()
+#elif defined(__WIIU__)
+#include <coreinit/cache.h>
+#define SDL_MemoryBarrierRelease()  OSMemoryBarrier()
+#define SDL_MemoryBarrierAcquire()  OSMemoryBarrier()
 #else
 /* This is correct for the x86 and x64 CPUs, and we'll expand this over time. */
 #define SDL_MemoryBarrierRelease()  SDL_CompilerBarrier()
@@ -242,7 +246,7 @@ typedef void (*SDL_KernelMemoryBarrierFunc)();
     #define SDL_CPUPauseInstruction() __asm__ __volatile__("pause\n")  /* Some assemblers can't do REP NOP, so go with PAUSE. */
 #elif (defined(__arm__) && defined(__ARM_ARCH) && __ARM_ARCH >= 7) || defined(__aarch64__)
     #define SDL_CPUPauseInstruction() __asm__ __volatile__("yield" ::: "memory")
-#elif (defined(__powerpc__) || defined(__powerpc64__))
+#elif (defined(__powerpc__) || defined(__powerpc64__) || defined(__WIIU__))
     #define SDL_CPUPauseInstruction() __asm__ __volatile__("or 27,27,27");
 #elif defined(_MSC_VER) && (defined(_M_IX86) || defined(_M_X64))
     #define SDL_CPUPauseInstruction() _mm_pause()  /* this is actually "rep nop" and not a SIMD instruction. No inline asm in MSVC x86-64! */
diff --git a/src/atomic/SDL_atomic.c b/src/atomic/SDL_atomic.c
index 4e10d52db..0a3c85dd2 100644
--- a/src/atomic/SDL_atomic.c
+++ b/src/atomic/SDL_atomic.c
@@ -35,6 +35,10 @@
 #include <atomic.h>
 #endif
 
+#if defined(__WIIU__)
+#include <coreinit/atomic.h>
+#endif
+
 /* The __atomic_load_n() intrinsic showed up in different times for different compilers. */
 #if defined(__clang__)
 #if __has_builtin(__atomic_load_n) || defined(HAVE_GCC_ATOMICS)
@@ -45,9 +49,9 @@
 #endif
 #endif
 #elif defined(__GNUC__)
-#if (__GNUC__ >= 5)
-#define HAVE_ATOMIC_LOAD_N 1
-#endif
+#   if (__GNUC__ >= 5) && defined(HAVE_GCC_ATOMICS)
+#     define HAVE_ATOMIC_LOAD_N 1
+#   endif
 #endif
 
 /* *INDENT-OFF* */ /* clang-format off */
@@ -102,7 +106,7 @@ extern __inline int _SDL_xadd_watcom(volatile int *a, int v);
   Contributed by Bob Pendleton, bob@pendleton.com
 */
 
-#if !defined(HAVE_MSC_ATOMICS) && !defined(HAVE_GCC_ATOMICS) && !defined(__MACOSX__) && !defined(__SOLARIS__) && !defined(HAVE_WATCOM_ATOMICS)
+#if !defined(HAVE_MSC_ATOMICS) && !defined(HAVE_GCC_ATOMICS) && !defined(__MACOSX__) && !defined(__SOLARIS__) && !defined(HAVE_WATCOM_ATOMICS) && !defined(__WIIU__)
 #define EMULATE_CAS 1
 #endif
 
@@ -131,6 +135,8 @@ SDL_bool SDL_AtomicCAS(SDL_atomic_t *a, int oldval, int newval)
     return _InterlockedCompareExchange((long *)&a->value, (long)newval, (long)oldval) == (long)oldval;
 #elif defined(HAVE_WATCOM_ATOMICS)
     return (SDL_bool)_SDL_cmpxchg_watcom(&a->value, newval, oldval);
+#elif defined(__WIIU__)
+    return OSCompareAndSwapAtomic((volatile uint32_t *)&a->value, (uint32_t)oldval, (uint32_t)newval);
 #elif defined(HAVE_GCC_ATOMICS)
     return (SDL_bool) __sync_bool_compare_and_swap(&a->value, oldval, newval);
 #elif defined(__MACOSX__)  /* this is deprecated in 10.12 sdk; favor gcc atomics. */
@@ -159,6 +165,8 @@ SDL_bool SDL_AtomicCASPtr(void **a, void *oldval, void *newval)
     return _InterlockedCompareExchangePointer(a, newval, oldval) == oldval;
 #elif defined(HAVE_WATCOM_ATOMICS)
     return (SDL_bool)_SDL_cmpxchg_watcom((int *)a, (long)newval, (long)oldval);
+#elif defined(__WIIU__)
+    return OSCompareAndSwapAtomic((volatile uint32_t *)a, (uint32_t)oldval, (uint32_t)newval);
 #elif defined(HAVE_GCC_ATOMICS)
     return __sync_bool_compare_and_swap(a, oldval, newval);
 #elif defined(__MACOSX__) && defined(__LP64__)  /* this is deprecated in 10.12 sdk; favor gcc atomics. */
@@ -190,6 +198,8 @@ int SDL_AtomicSet(SDL_atomic_t *a, int v)
     return _InterlockedExchange((long *)&a->value, v);
 #elif defined(HAVE_WATCOM_ATOMICS)
     return _SDL_xchg_watcom(&a->value, v);
+#elif defined(__WIIU__)
+    return (int) OSSwapAtomic((volatile uint32_t *)&a->value, (uint32_t)v);
 #elif defined(HAVE_GCC_ATOMICS)
     return __sync_lock_test_and_set(&a->value, v);
 #elif defined(__SOLARIS__)
@@ -209,6 +219,8 @@ void *SDL_AtomicSetPtr(void **a, void *v)
     return _InterlockedExchangePointer(a, v);
 #elif defined(HAVE_WATCOM_ATOMICS)
     return (void *)_SDL_xchg_watcom((int *)a, (long)v);
+#elif defined(__WIIU__)
+    return (void *) OSSwapAtomic((volatile uint32_t *)a, (uint32_t)v);
 #elif defined(HAVE_GCC_ATOMICS)
     return __sync_lock_test_and_set(a, v);
 #elif defined(__SOLARIS__)
@@ -229,6 +241,8 @@ int SDL_AtomicAdd(SDL_atomic_t *a, int v)
     return _InterlockedExchangeAdd((long *)&a->value, v);
 #elif defined(HAVE_WATCOM_ATOMICS)
     return _SDL_xadd_watcom(&a->value, v);
+#elif defined(__WIIU__)
+    return OSAddAtomic((volatile int32_t *)&a->value, v);
 #elif defined(HAVE_GCC_ATOMICS)
     return __sync_fetch_and_add(&a->value, v);
 #elif defined(__SOLARIS__)
diff --git a/src/atomic/SDL_spinlock.c b/src/atomic/SDL_spinlock.c
index 420d49623..4fdc1024c 100644
--- a/src/atomic/SDL_spinlock.c
+++ b/src/atomic/SDL_spinlock.c
@@ -37,7 +37,8 @@
 #endif
 
 #if defined(__WIIU__)
-#include <stdatomic.h>
+#include <coreinit/cache.h>
+#include <coreinit/atomic.h>
 #endif
 
 #if defined(_MSC_VER) && (defined(_M_IX86) || defined(_M_X64))
@@ -168,8 +169,7 @@ SDL_bool SDL_AtomicTryLock(SDL_SpinLock *lock)
     }
     return res;
 #elif defined(__WIIU__)
-    uint64_t val = 0;
-    return (SDL_bool) atomic_compare_exchange_strong((volatile _Atomic uint64_t*)lock, &val, 1);
+    return OSCompareAndSwapAtomic((volatile uint32_t *)lock, 0u, 1u);
 
 #else
 #error Please implement for your platform.
@@ -213,6 +213,10 @@ void SDL_AtomicUnlock(SDL_SpinLock *lock)
     *lock = 0;
     membar_producer();
 
+#elif defined(__WIIU__)
+    *lock = 0;
+    OSMemoryBarrier();
+
 #else
     *lock = 0;
 #endif
-- 
2.20.1


From d044179298c1f83ca805f9055441f8382b8ea3dc Mon Sep 17 00:00:00 2001
From: GaryOderNichts <12049776+GaryOderNichts@users.noreply.github.com>
Date: Fri, 7 Apr 2023 13:24:27 +0200
Subject: [PATCH 19/28] wiiu/render: only call GX2SetTV/DRCEnable once

---
 src/render/wiiu/SDL_rpresent_wiiu.c | 10 +++++++---
 1 file changed, 7 insertions(+), 3 deletions(-)

diff --git a/src/render/wiiu/SDL_rpresent_wiiu.c b/src/render/wiiu/SDL_rpresent_wiiu.c
index d1a4839df..bcd82adcd 100644
--- a/src/render/wiiu/SDL_rpresent_wiiu.c
+++ b/src/render/wiiu/SDL_rpresent_wiiu.c
@@ -27,7 +27,6 @@
 #include "../SDL_sysrender.h"
 #include "SDL_render_wiiu.h"
 
-#include <whb/gfx.h>
 #include <gx2/registers.h>
 #include <gx2/state.h>
 #include <gx2/draw.h>
@@ -36,6 +35,8 @@
 #include <gx2r/buffer.h>
 #include <gx2r/draw.h>
 
+static SDL_bool tvDrcEnabled = SDL_FALSE;
+
 void WIIU_SDL_RenderPresent(SDL_Renderer * renderer)
 {
     WIIU_RenderData *data = (WIIU_RenderData *) renderer->driverdata;
@@ -59,8 +60,11 @@ void WIIU_SDL_RenderPresent(SDL_Renderer * renderer)
     GX2SetContextState(data->ctx);
 
     /* TV and DRC can now be enabled after the first frame was drawn */
-    GX2SetTVEnable(TRUE);
-    GX2SetDRCEnable(TRUE);
+    if (!tvDrcEnabled) {
+        GX2SetTVEnable(TRUE);
+        GX2SetDRCEnable(TRUE);
+        tvDrcEnabled = SDL_TRUE;
+    }
 
     /* Wait for vsync */
     if (renderer->info.flags & SDL_RENDERER_PRESENTVSYNC) {
-- 
2.20.1


From 85759f257921b5132264d4faf19014800665fae5 Mon Sep 17 00:00:00 2001
From: GaryOderNichts <12049776+GaryOderNichts@users.noreply.github.com>
Date: Fri, 7 Apr 2023 13:42:27 +0200
Subject: [PATCH 20/28] wiiu/video: Replace WHBProc with custom ProcUI
 implementation

---
 src/video/wiiu/SDL_wiiuvideo.c | 27 ++++++++++++++++++---------
 1 file changed, 18 insertions(+), 9 deletions(-)

diff --git a/src/video/wiiu/SDL_wiiuvideo.c b/src/video/wiiu/SDL_wiiuvideo.c
index b55ed7c63..13f90452e 100644
--- a/src/video/wiiu/SDL_wiiuvideo.c
+++ b/src/video/wiiu/SDL_wiiuvideo.c
@@ -40,12 +40,12 @@
 
 #include "../../render/wiiu/SDL_render_wiiu.h"
 
-#include <whb/proc.h>
 #include <stdio.h>
 #include <malloc.h>
 #include <string.h>
 #include <stdint.h>
 
+#include <coreinit/foreground.h>
 #include <proc_ui/procui.h>
 
 #include <gx2/context.h>
@@ -105,8 +105,7 @@ static int WIIU_ForegroundAcquired(_THIS)
 
 		// Recreate the window texture, now that we have foreground memory available
 		if (renderer) {
-			// TODO
-			//WIIU_SDL_CreateWindowTex(renderer, window);
+			WIIU_SDL_CreateWindowTex(renderer, window);
 		}
 
 		// We're now in foreground, window is visible
@@ -151,7 +150,8 @@ static int WIIU_ForegroundReleased(_THIS)
 
 		// Destroy window texture, we no longer have access to foreground memory
 		if (renderer) {
-			// TODO
+			// TODO this causes crashes on exit for some reason?
+			// Doesn't matter since we destroy the heap anyways ¯\_(ツ)_/¯
 			//WIIU_SDL_DestroyWindowTex(renderer, window);
 		}
 
@@ -165,6 +165,12 @@ static int WIIU_ForegroundReleased(_THIS)
 	return 0;
 }
 
+static uint32_t WiiU_SaveCallback(void * arg)
+{
+	OSSavesDone_ReadyToRelease();
+	return 0;
+}
+
 static int WIIU_VideoInit(_THIS)
 {
 	WIIU_VideoData *videodata = (WIIU_VideoData *) _this->driverdata;
@@ -174,7 +180,7 @@ static int WIIU_VideoInit(_THIS)
 
 	// check if the user already set up procui or if we should handle it
 	if (!ProcUIIsRunning()) {
-		WHBProcInit();
+		ProcUIInitEx(WiiU_SaveCallback, NULL);
 		
 		videodata->handleProcUI = SDL_TRUE;
 	}
@@ -239,8 +245,8 @@ static int WIIU_VideoInit(_THIS)
 		return SDL_OutOfMemory();
 	}
 
-    GX2SetTVScale(videodata->tvWidth, videodata->tvHeight);
-    GX2SetDRCScale(DRC_SCREEN_WIDTH, DRC_SCREEN_HEIGHT);
+	GX2SetTVScale(videodata->tvWidth, videodata->tvHeight);
+	GX2SetDRCScale(DRC_SCREEN_WIDTH, DRC_SCREEN_HEIGHT);
 
 	// add tv display
 	SDL_zero(mode);
@@ -279,7 +285,7 @@ static void WIIU_VideoQuit(_THIS)
 	}
 
 	if (videodata->handleProcUI) {
-		WHBProcShutdown();
+		ProcUIShutdown();
 	}
 
 	running = SDL_FALSE;
@@ -317,8 +323,11 @@ static void WIIU_PumpEvents(_THIS)
 	WIIU_VideoData *videodata = (WIIU_VideoData *) _this->driverdata;
 
 	if (videodata->handleProcUI) {
-		if (!WHBProcIsRunning()) {
+		ProcUIStatus status = ProcUIProcessMessages(TRUE);
+		if (status == PROCUI_STATUS_EXITING) {
 			SDL_SendQuit();
+		} else if (status == PROCUI_STATUS_RELEASE_FOREGROUND) {
+			ProcUIDrawDoneRelease();
 		}
 	}
 }
-- 
2.20.1


From f42bf16f714817f2567fe24cb8cb16c8f1f43d43 Mon Sep 17 00:00:00 2001
From: GaryOderNichts <12049776+GaryOderNichts@users.noreply.github.com>
Date: Fri, 7 Apr 2023 13:44:09 +0200
Subject: [PATCH 21/28] wiiu/render: Replace WHBGfx shader loading

---
 src/render/wiiu/SDL_rqueue_wiiu.c  |   2 +-
 src/render/wiiu/SDL_shaders_wiiu.c | 213 ++++++++++++++++++++++++++---
 src/render/wiiu/SDL_shaders_wiiu.h |  11 +-
 3 files changed, 207 insertions(+), 19 deletions(-)

diff --git a/src/render/wiiu/SDL_rqueue_wiiu.c b/src/render/wiiu/SDL_rqueue_wiiu.c
index 166c1b7e5..382212f4f 100644
--- a/src/render/wiiu/SDL_rqueue_wiiu.c
+++ b/src/render/wiiu/SDL_rqueue_wiiu.c
@@ -269,7 +269,7 @@ static int WIIU_SDL_SetDrawState(WIIU_RenderData * data, const SDL_RenderCommand
     SDL_bool shaderUpdated = SDL_FALSE;
     const SDL_BlendMode blendMode = cmd->data.draw.blend;
     WIIU_ShaderType shader = cmd->data.draw.texture ? SHADER_TEXTURE : SHADER_COLOR;
-    WHBGfxShaderGroup* shaderGroup = WIIU_SDL_GetShaderGroup(shader);
+    WiiU_ShaderGroup* shaderGroup = WIIU_SDL_GetShaderGroup(shader);
     SDL_Texture *texture = cmd->data.draw.texture;
 
     if (data->drawState.viewportDirty) {
diff --git a/src/render/wiiu/SDL_shaders_wiiu.c b/src/render/wiiu/SDL_shaders_wiiu.c
index 679bded96..f06aa3efc 100644
--- a/src/render/wiiu/SDL_shaders_wiiu.c
+++ b/src/render/wiiu/SDL_shaders_wiiu.c
@@ -26,49 +26,230 @@
 #include "SDL_render.h"
 #include "../SDL_sysrender.h"
 
+#include <malloc.h>
+#include <gfd.h>
+#include <gx2/utils.h>
+#include <gx2/mem.h>
+
 #include "shaders/colorShader.inc"
 #include "shaders/textureShader.inc"
 
-static WHBGfxShaderGroup shaderGroups[NUM_SHADERS];
+static WiiU_ShaderGroup shaderGroups[NUM_SHADERS];
 static int shaderRefCount = 0;
 
+static GX2VertexShader* WiiU_LoadGFDVertexShader(uint32_t index, const void* file)
+{
+    uint32_t headerSize, programSize;
+    GX2VertexShader* shader = NULL;
+    void* program = NULL;
+
+    if (index >= GFDGetVertexShaderCount(file)) {
+        return NULL;
+    }
+
+    if ((headerSize = GFDGetVertexShaderHeaderSize(index, file)) == 0) {
+        return NULL;
+    }
+
+    if ((programSize = GFDGetVertexShaderProgramSize(index, file)) == 0) {
+        return NULL;
+    }
+
+    if (!(shader = memalign(0x40, headerSize))) {
+        return NULL;
+    }
+
+    shader->gx2rBuffer.flags = GX2R_RESOURCE_BIND_SHADER_PROGRAM |
+                                GX2R_RESOURCE_USAGE_CPU_READ |
+                                GX2R_RESOURCE_USAGE_CPU_WRITE |
+                                GX2R_RESOURCE_USAGE_GPU_READ;
+    shader->gx2rBuffer.elemSize = programSize;
+    shader->gx2rBuffer.elemCount = 1;
+    shader->gx2rBuffer.buffer = NULL;
+    if (!GX2RCreateBuffer(&shader->gx2rBuffer)) {
+        free(shader);
+        return NULL;
+    }
+
+    program = GX2RLockBufferEx(&shader->gx2rBuffer, GX2R_RESOURCE_BIND_NONE);
+    if (!GFDGetVertexShader(shader, program, index, file)) {
+        GX2RUnlockBufferEx(&shader->gx2rBuffer, GX2R_RESOURCE_DISABLE_CPU_INVALIDATE |
+                                                GX2R_RESOURCE_DISABLE_GPU_INVALIDATE);
+        GX2RDestroyBufferEx(&shader->gx2rBuffer, GX2R_RESOURCE_BIND_NONE);
+        free(shader);
+        return NULL;
+    }
+
+    GX2RUnlockBufferEx(&shader->gx2rBuffer, 0);
+    // according to wut this needs to be invalidated again for some reason
+    GX2Invalidate(GX2_INVALIDATE_MODE_CPU_SHADER, shader->program, shader->size);
+    return shader;
+}
+
+static GX2PixelShader* WiiU_LoadGFDPixelShader(uint32_t index, const void* file)
+{
+    uint32_t headerSize, programSize;
+    GX2PixelShader* shader = NULL;
+    void* program = NULL;
+
+    if (index >= GFDGetPixelShaderCount(file)) {
+        return NULL;
+    }
+
+    if ((headerSize = GFDGetPixelShaderHeaderSize(index, file)) == 0) {
+        return NULL;
+    }
+
+    if ((programSize = GFDGetPixelShaderProgramSize(index, file)) == 0) {
+        return NULL;
+    }
+
+    if (!(shader = memalign(0x40, headerSize))) {
+        return NULL;
+    }
+
+    shader->gx2rBuffer.flags = GX2R_RESOURCE_BIND_SHADER_PROGRAM |
+                                GX2R_RESOURCE_USAGE_CPU_READ |
+                                GX2R_RESOURCE_USAGE_CPU_WRITE |
+                                GX2R_RESOURCE_USAGE_GPU_READ;
+    shader->gx2rBuffer.elemSize = programSize;
+    shader->gx2rBuffer.elemCount = 1;
+    shader->gx2rBuffer.buffer = NULL;
+    if (!GX2RCreateBuffer(&shader->gx2rBuffer)) {
+        free(shader);
+        return NULL;
+    }
+
+    program = GX2RLockBufferEx(&shader->gx2rBuffer, GX2R_RESOURCE_BIND_NONE);
+    if (!GFDGetPixelShader(shader, program, index, file)) {
+        GX2RUnlockBufferEx(&shader->gx2rBuffer, GX2R_RESOURCE_DISABLE_CPU_INVALIDATE |
+                                                GX2R_RESOURCE_DISABLE_GPU_INVALIDATE);
+        GX2RDestroyBufferEx(&shader->gx2rBuffer, GX2R_RESOURCE_BIND_NONE);
+        free(shader);
+        return NULL;
+    }
+
+    GX2RUnlockBufferEx(&shader->gx2rBuffer, 0);
+    // according to wut this needs to be invalidated again for some reason
+    GX2Invalidate(GX2_INVALIDATE_MODE_CPU_SHADER, shader->program, shader->size);
+    return shader;
+}
+
+static int WiiU_LoadGFDShaderGroup(WiiU_ShaderGroup* group, uint32_t index, const void* file)
+{
+    group->vertexShader = WiiU_LoadGFDVertexShader(index, file);
+    if (!group->vertexShader) {
+        return -1;
+    }
+
+    group->pixelShader = WiiU_LoadGFDPixelShader(index, file);
+    if (!group->pixelShader) {
+        return -1;
+    }
+
+    return 0;
+}
+
+static int WiiU_CreateFetchShader(WiiU_ShaderGroup* group, GX2AttribStream* attributes, uint32_t numAttributes)
+{
+    uint32_t size = GX2CalcFetchShaderSizeEx(numAttributes, GX2_FETCH_SHADER_TESSELLATION_NONE, GX2_TESSELLATION_MODE_DISCRETE);
+    if (!size) {
+        return -1;
+    }
+
+    group->fetchShaderProgram = memalign(GX2_SHADER_PROGRAM_ALIGNMENT, size);
+    if (!group->fetchShaderProgram) {
+        return -1;
+    }
+
+    GX2InitFetchShaderEx(&group->fetchShader,
+                         group->fetchShaderProgram,
+                         numAttributes,
+                         attributes,
+                         GX2_FETCH_SHADER_TESSELLATION_NONE,
+                         GX2_TESSELLATION_MODE_DISCRETE);
+
+    GX2Invalidate(GX2_INVALIDATE_MODE_CPU_SHADER, group->fetchShaderProgram, size);
+    return 0;
+}
+
+static void WiiU_FreeShaderGroup(WiiU_ShaderGroup* group)
+{
+    GX2RDestroyBufferEx(&group->vertexShader->gx2rBuffer, GX2R_RESOURCE_BIND_NONE);
+    free(group->vertexShader);
+
+    GX2RDestroyBufferEx(&group->pixelShader->gx2rBuffer, GX2R_RESOURCE_BIND_NONE);
+    free(group->pixelShader);
+
+    free(group->fetchShaderProgram);
+}
+
 void WIIU_SDL_CreateShaders(void)
 {
     if (!shaderRefCount++) {
-        WHBGfxShaderGroup* colorShader = &shaderGroups[SHADER_COLOR];
-        WHBGfxShaderGroup* textureShader = &shaderGroups[SHADER_TEXTURE];
+        GX2AttribStream attributes[3];
 
-        WHBGfxLoadGFDShaderGroup(colorShader, 0, colorShader_gsh);
-        WHBGfxInitShaderAttribute(colorShader, "a_position", 0, offsetof(SDL_VertexSolid, position), GX2_ATTRIB_FORMAT_FLOAT_32_32);
-        WHBGfxInitShaderAttribute(colorShader, "a_color", 0, offsetof(SDL_VertexSolid, color), GX2_ATTRIB_FORMAT_UNORM_8_8_8_8);
-        WHBGfxInitFetchShader(colorShader);
+        // a_position
+        attributes[0] = (GX2AttribStream) { 
+            0, 0, offsetof(SDL_VertexSolid, position),
+            GX2_ATTRIB_FORMAT_FLOAT_32_32, GX2_ATTRIB_INDEX_PER_VERTEX, 0,
+            GX2_SEL_MASK(GX2_SQ_SEL_X, GX2_SQ_SEL_Y, GX2_SQ_SEL_0, GX2_SQ_SEL_1),
+            GX2_ENDIAN_SWAP_DEFAULT
+        };
+        // a_color
+        attributes[1] = (GX2AttribStream) { 
+            1, 0, offsetof(SDL_VertexSolid, color),
+            GX2_ATTRIB_FORMAT_UNORM_8_8_8_8, GX2_ATTRIB_INDEX_PER_VERTEX, 0,
+            GX2_SEL_MASK(GX2_SQ_SEL_X, GX2_SQ_SEL_Y, GX2_SQ_SEL_Z, GX2_SQ_SEL_W),
+            GX2_ENDIAN_SWAP_DEFAULT
+        };
+        WiiU_LoadGFDShaderGroup(&shaderGroups[SHADER_COLOR], 0, colorShader_gsh);
+        WiiU_CreateFetchShader(&shaderGroups[SHADER_COLOR], attributes, 2);
 
-        WHBGfxLoadGFDShaderGroup(textureShader, 0, textureShader_gsh);
-        WHBGfxInitShaderAttribute(textureShader, "a_position", 0, offsetof(SDL_Vertex, position), GX2_ATTRIB_FORMAT_FLOAT_32_32);
-        WHBGfxInitShaderAttribute(textureShader, "a_color", 0, offsetof(SDL_Vertex, color), GX2_ATTRIB_FORMAT_UNORM_8_8_8_8);
-        WHBGfxInitShaderAttribute(textureShader, "a_texcoord", 0, offsetof(SDL_Vertex, tex_coord), GX2_ATTRIB_FORMAT_FLOAT_32_32);
-        WHBGfxInitFetchShader(textureShader);
+        // a_position
+        attributes[0] = (GX2AttribStream) { 
+            0, 0, offsetof(SDL_Vertex, position),
+            GX2_ATTRIB_FORMAT_FLOAT_32_32, GX2_ATTRIB_INDEX_PER_VERTEX, 0,
+            GX2_SEL_MASK(GX2_SQ_SEL_X, GX2_SQ_SEL_Y, GX2_SQ_SEL_0, GX2_SQ_SEL_1),
+            GX2_ENDIAN_SWAP_DEFAULT
+        };
+        // a_color
+        attributes[1] = (GX2AttribStream) { 
+            1, 0, offsetof(SDL_Vertex, color),
+            GX2_ATTRIB_FORMAT_UNORM_8_8_8_8, GX2_ATTRIB_INDEX_PER_VERTEX, 0,
+            GX2_SEL_MASK(GX2_SQ_SEL_X, GX2_SQ_SEL_Y, GX2_SQ_SEL_Z, GX2_SQ_SEL_W),
+            GX2_ENDIAN_SWAP_DEFAULT
+        };
+        // a_texcoord
+        attributes[2] = (GX2AttribStream) { 
+            2, 0, offsetof(SDL_Vertex, tex_coord),
+            GX2_ATTRIB_FORMAT_FLOAT_32_32, GX2_ATTRIB_INDEX_PER_VERTEX, 0,
+            GX2_SEL_MASK(GX2_SQ_SEL_X, GX2_SQ_SEL_Y, GX2_SQ_SEL_0, GX2_SQ_SEL_1),
+            GX2_ENDIAN_SWAP_DEFAULT
+        };
+        WiiU_LoadGFDShaderGroup(&shaderGroups[SHADER_TEXTURE], 0, textureShader_gsh);
+        WiiU_CreateFetchShader(&shaderGroups[SHADER_TEXTURE], attributes, 3);
     }
 }
 
 void WIIU_SDL_DestroyShaders(void)
 {
     if (!--shaderRefCount) {
-        WHBGfxFreeShaderGroup(&shaderGroups[SHADER_COLOR]);
-        WHBGfxFreeShaderGroup(&shaderGroups[SHADER_TEXTURE]);
+        WiiU_FreeShaderGroup(&shaderGroups[SHADER_COLOR]);
+        WiiU_FreeShaderGroup(&shaderGroups[SHADER_TEXTURE]);
     }
 }
 
 void WIIU_SDL_SelectShader(WIIU_ShaderType shader)
 {
-    WHBGfxShaderGroup* shaderGroup = &shaderGroups[shader];
+    WiiU_ShaderGroup* shaderGroup = &shaderGroups[shader];
 
     GX2SetFetchShader(&shaderGroup->fetchShader);
     GX2SetVertexShader(shaderGroup->vertexShader);
     GX2SetPixelShader(shaderGroup->pixelShader);
 }
 
-WHBGfxShaderGroup* WIIU_SDL_GetShaderGroup(WIIU_ShaderType shader)
+WiiU_ShaderGroup* WIIU_SDL_GetShaderGroup(WIIU_ShaderType shader)
 {
     return &shaderGroups[shader];
 }
diff --git a/src/render/wiiu/SDL_shaders_wiiu.h b/src/render/wiiu/SDL_shaders_wiiu.h
index f4b19c90d..fbb7903af 100644
--- a/src/render/wiiu/SDL_shaders_wiiu.h
+++ b/src/render/wiiu/SDL_shaders_wiiu.h
@@ -25,7 +25,7 @@
 
 #if SDL_VIDEO_RENDER_WIIU
 
-#include <whb/gfx.h>
+#include <gx2/shaders.h>
 
 typedef enum {
     SHADER_INVALID = -1,
@@ -34,10 +34,17 @@ typedef enum {
     NUM_SHADERS
 } WIIU_ShaderType;
 
+typedef struct {
+   GX2FetchShader fetchShader;
+   void* fetchShaderProgram;
+   GX2VertexShader* vertexShader;
+   GX2PixelShader* pixelShader;
+} WiiU_ShaderGroup;
+
 void WIIU_SDL_CreateShaders(void);
 void WIIU_SDL_DestroyShaders(void);
 void WIIU_SDL_SelectShader(WIIU_ShaderType shader);
-WHBGfxShaderGroup* WIIU_SDL_GetShaderGroup(WIIU_ShaderType shader);
+WiiU_ShaderGroup* WIIU_SDL_GetShaderGroup(WIIU_ShaderType shader);
 
 #endif /* SDL_VIDEO_RENDER_WIIU */
 
-- 
2.20.1


From 642f98b6e36347f9f77fba1e8ebd27180263688a Mon Sep 17 00:00:00 2001
From: GaryOderNichts <12049776+GaryOderNichts@users.noreply.github.com>
Date: Fri, 7 Apr 2023 14:33:42 +0200
Subject: [PATCH 22/28] wiiu: update drivers for 2.26

---
 src/joystick/wiiu/SDL_wiiujoystick.c |  6 ++++++
 src/render/wiiu/SDL_render_wiiu.h    |  2 +-
 src/render/wiiu/SDL_rpresent_wiiu.c  |  4 +++-
 src/render/wiiu/SDL_shaders_wiiu.c   | 16 ++++++++--------
 src/video/SDL_video.c                |  9 ++++++---
 src/video/wiiu/SDL_wiiuvideo.c       |  2 +-
 6 files changed, 25 insertions(+), 14 deletions(-)

diff --git a/src/joystick/wiiu/SDL_wiiujoystick.c b/src/joystick/wiiu/SDL_wiiujoystick.c
index d448231a2..bb449c573 100644
--- a/src/joystick/wiiu/SDL_wiiujoystick.c
+++ b/src/joystick/wiiu/SDL_wiiujoystick.c
@@ -242,6 +242,11 @@ static const char *WIIU_JoystickGetDeviceName(int device_index)
 	return "Unknown";
 }
 
+static const char * WIIU_JoystickGetDevicePath(int device_index)
+{
+    return NULL;
+}
+
 /* Function to get the player index of a joystick */
 static int WIIU_JoystickGetDevicePlayerIndex(int device_index)
 {
@@ -627,6 +632,7 @@ SDL_JoystickDriver SDL_WIIU_JoystickDriver =
 	WIIU_JoystickGetCount,
 	WIIU_JoystickDetect,
 	WIIU_JoystickGetDeviceName,
+	WIIU_JoystickGetDevicePath,
 	WIIU_JoystickGetDevicePlayerIndex,
 	WIIU_JoystickSetDevicePlayerIndex,
 	WIIU_JoystickGetDeviceGUID,
diff --git a/src/render/wiiu/SDL_render_wiiu.h b/src/render/wiiu/SDL_render_wiiu.h
index 823c8022e..648f8a8f7 100644
--- a/src/render/wiiu/SDL_render_wiiu.h
+++ b/src/render/wiiu/SDL_render_wiiu.h
@@ -133,7 +133,7 @@ int WIIU_SDL_QueueGeometry(SDL_Renderer * renderer, SDL_RenderCommand * cmd, SDL
 int WIIU_SDL_RunCommandQueue(SDL_Renderer * renderer, SDL_RenderCommand *cmd, void *vertices, size_t vertsize);
 int WIIU_SDL_RenderReadPixels(SDL_Renderer * renderer, const SDL_Rect * rect,
                           Uint32 format, void * pixels, int pitch);
-void WIIU_SDL_RenderPresent(SDL_Renderer * renderer);
+int WIIU_SDL_RenderPresent(SDL_Renderer * renderer);
 void WIIU_SDL_DestroyTexture(SDL_Renderer * renderer, SDL_Texture * texture);
 void WIIU_SDL_DestroyRenderer(SDL_Renderer * renderer);
 
diff --git a/src/render/wiiu/SDL_rpresent_wiiu.c b/src/render/wiiu/SDL_rpresent_wiiu.c
index bcd82adcd..d71a941c4 100644
--- a/src/render/wiiu/SDL_rpresent_wiiu.c
+++ b/src/render/wiiu/SDL_rpresent_wiiu.c
@@ -37,7 +37,7 @@
 
 static SDL_bool tvDrcEnabled = SDL_FALSE;
 
-void WIIU_SDL_RenderPresent(SDL_Renderer * renderer)
+int WIIU_SDL_RenderPresent(SDL_Renderer * renderer)
 {
     WIIU_RenderData *data = (WIIU_RenderData *) renderer->driverdata;
     WIIU_TextureData *tdata = (WIIU_TextureData *) data->windowTex.driverdata;
@@ -92,6 +92,8 @@ void WIIU_SDL_RenderPresent(SDL_Renderer * renderer)
     /* Free the list of render and draw data */
     WIIU_FreeRenderData(data);
     WIIU_TextureDoneRendering(data);
+
+    return 0;
 }
 
 #endif /* SDL_VIDEO_RENDER_WIIU */
diff --git a/src/render/wiiu/SDL_shaders_wiiu.c b/src/render/wiiu/SDL_shaders_wiiu.c
index f06aa3efc..03a35c769 100644
--- a/src/render/wiiu/SDL_shaders_wiiu.c
+++ b/src/render/wiiu/SDL_shaders_wiiu.c
@@ -60,9 +60,9 @@ static GX2VertexShader* WiiU_LoadGFDVertexShader(uint32_t index, const void* fil
     }
 
     shader->gx2rBuffer.flags = GX2R_RESOURCE_BIND_SHADER_PROGRAM |
-                                GX2R_RESOURCE_USAGE_CPU_READ |
-                                GX2R_RESOURCE_USAGE_CPU_WRITE |
-                                GX2R_RESOURCE_USAGE_GPU_READ;
+                               GX2R_RESOURCE_USAGE_CPU_READ |
+                               GX2R_RESOURCE_USAGE_CPU_WRITE |
+                               GX2R_RESOURCE_USAGE_GPU_READ;
     shader->gx2rBuffer.elemSize = programSize;
     shader->gx2rBuffer.elemCount = 1;
     shader->gx2rBuffer.buffer = NULL;
@@ -80,7 +80,7 @@ static GX2VertexShader* WiiU_LoadGFDVertexShader(uint32_t index, const void* fil
         return NULL;
     }
 
-    GX2RUnlockBufferEx(&shader->gx2rBuffer, 0);
+    GX2RUnlockBufferEx(&shader->gx2rBuffer, GX2R_RESOURCE_BIND_NONE);
     // according to wut this needs to be invalidated again for some reason
     GX2Invalidate(GX2_INVALIDATE_MODE_CPU_SHADER, shader->program, shader->size);
     return shader;
@@ -109,9 +109,9 @@ static GX2PixelShader* WiiU_LoadGFDPixelShader(uint32_t index, const void* file)
     }
 
     shader->gx2rBuffer.flags = GX2R_RESOURCE_BIND_SHADER_PROGRAM |
-                                GX2R_RESOURCE_USAGE_CPU_READ |
-                                GX2R_RESOURCE_USAGE_CPU_WRITE |
-                                GX2R_RESOURCE_USAGE_GPU_READ;
+                               GX2R_RESOURCE_USAGE_CPU_READ |
+                               GX2R_RESOURCE_USAGE_CPU_WRITE |
+                               GX2R_RESOURCE_USAGE_GPU_READ;
     shader->gx2rBuffer.elemSize = programSize;
     shader->gx2rBuffer.elemCount = 1;
     shader->gx2rBuffer.buffer = NULL;
@@ -129,7 +129,7 @@ static GX2PixelShader* WiiU_LoadGFDPixelShader(uint32_t index, const void* file)
         return NULL;
     }
 
-    GX2RUnlockBufferEx(&shader->gx2rBuffer, 0);
+    GX2RUnlockBufferEx(&shader->gx2rBuffer, GX2R_RESOURCE_BIND_NONE);
     // according to wut this needs to be invalidated again for some reason
     GX2Invalidate(GX2_INVALIDATE_MODE_CPU_SHADER, shader->program, shader->size);
     return shader;
diff --git a/src/video/SDL_video.c b/src/video/SDL_video.c
index dff775187..929fd231a 100644
--- a/src/video/SDL_video.c
+++ b/src/video/SDL_video.c
@@ -132,15 +132,18 @@ static VideoBootStrap *bootstrap[] = {
     &OS2DIVE_bootstrap,
     &OS2VMAN_bootstrap,
 #endif
+#if SDL_VIDEO_DRIVER_WIIU
+    &WIIU_bootstrap,
+#endif
+#if SDL_VIDEO_DRIVER_OFFSCREEN
+    &OFFSCREEN_bootstrap,
+#endif
 #if SDL_VIDEO_DRIVER_NGAGE
     &NGAGE_bootstrap,
 #endif
 #if SDL_VIDEO_DRIVER_OFFSCREEN
     &OFFSCREEN_bootstrap,
 #endif
-#if SDL_VIDEO_DRIVER_WIIU
-    &WIIU_bootstrap,
-#endif
 #if SDL_VIDEO_DRIVER_DUMMY
     &DUMMY_bootstrap,
 #if SDL_INPUT_LINUXEV
diff --git a/src/video/wiiu/SDL_wiiuvideo.c b/src/video/wiiu/SDL_wiiuvideo.c
index 13f90452e..dd89c4e29 100644
--- a/src/video/wiiu/SDL_wiiuvideo.c
+++ b/src/video/wiiu/SDL_wiiuvideo.c
@@ -338,7 +338,7 @@ static void WIIU_DeleteDevice(SDL_VideoDevice *device)
 	SDL_free(device);
 }
 
-static SDL_VideoDevice *WIIU_CreateDevice(int devindex)
+static SDL_VideoDevice *WIIU_CreateDevice(void)
 {
 	SDL_VideoDevice *device;
 	WIIU_VideoData *videodata;
-- 
2.20.1


From 746622ced78e6c0d8eebab4fd5608689cbf5ed8f Mon Sep 17 00:00:00 2001
From: GaryOderNichts <12049776+GaryOderNichts@users.noreply.github.com>
Date: Fri, 7 Apr 2023 23:36:19 +0200
Subject: [PATCH 23/28] wiiu/joystick: Fix UUID generation for SDL 2.26 This
 broke with https://github.com/libsdl-org/SDL/pull/6111

---
 src/joystick/SDL_gamecontrollerdb.h  | 16 ++++++++--------
 src/joystick/wiiu/SDL_wiiujoystick.c | 16 +++++-----------
 2 files changed, 13 insertions(+), 19 deletions(-)

diff --git a/src/joystick/SDL_gamecontrollerdb.h b/src/joystick/SDL_gamecontrollerdb.h
index 6c86e94f6..cc5c44474 100644
--- a/src/joystick/SDL_gamecontrollerdb.h
+++ b/src/joystick/SDL_gamecontrollerdb.h
@@ -993,14 +993,14 @@ static const char *s_ControllerMappings[] = {
     "000000004e696e74656e646f20334400,Nintendo 3DS,crc:3210,a:b0,b:b1,back:b2,dpdown:b7,dpleft:b5,dpright:b4,dpup:b6,leftshoulder:b9,lefttrigger:b14,leftx:a0,lefty:a1,rightshoulder:b8,righttrigger:b15,rightx:a2,righty:a3,start:b3,x:b10,y:b11,",
 #endif
 #if defined(SDL_JOYSTICK_WIIU)
-    "49dcab4b72e942a1ad938e4aeb88d868,Wii U Gamepad,a:b0,b:b1,back:b11,dpdown:b15,dpleft:b12,dpright:b14,dpup:b13,leftshoulder:b6,leftstick:b4,lefttrigger:b8,leftx:a0,lefty:a1,rightshoulder:b7,rightstick:b5,righttrigger:b9,rightx:a2,righty:a3,start:b10,x:b2,y:b3,hint:SDL_GAMECONTROLLER_USE_BUTTON_LABELS:=1,",
-    "49dcab4b72e942a1ad938e4aeb88d868,Wii U Gamepad,a:b1,b:b0,back:b11,dpdown:b15,dpleft:b12,dpright:b14,dpup:b13,leftshoulder:b6,leftstick:b4,lefttrigger:b8,leftx:a0,lefty:a1,rightshoulder:b7,rightstick:b5,righttrigger:b9,rightx:a2,righty:a3,start:b10,x:b3,y:b2,hint:!SDL_GAMECONTROLLER_USE_BUTTON_LABELS:=1,",
-    "6972c1586f704c4e9d80cc8957abb814,Wii U Pro Controller,a:b0,b:b1,back:b11,dpdown:b15,dpleft:b12,dpright:b14,dpup:b13,leftshoulder:b6,leftstick:b4,lefttrigger:b8,leftx:a0,lefty:a1,rightshoulder:b7,rightstick:b5,righttrigger:b9,rightx:a2,righty:a3,start:b10,x:b2,y:b3,hint:SDL_GAMECONTROLLER_USE_BUTTON_LABELS:=1,",
-    "6972c1586f704c4e9d80cc8957abb814,Wii U Pro Controller,a:b1,b:b0,back:b11,dpdown:b15,dpleft:b12,dpright:b14,dpup:b13,leftshoulder:b6,leftstick:b4,lefttrigger:b8,leftx:a0,lefty:a1,rightshoulder:b7,rightstick:b5,righttrigger:b9,rightx:a2,righty:a3,start:b10,x:b3,y:b2,hint:!SDL_GAMECONTROLLER_USE_BUTTON_LABELS:=1,",
-    "fc547396886d4f55add913767f0f511c,Wii Classic Controller,a:b0,b:b1,back:b11,dpdown:b15,dpleft:b12,dpright:b14,dpup:b13,leftshoulder:b6,leftstick:b4,lefttrigger:b8,leftx:a0,lefty:a1,rightshoulder:b7,rightstick:b5,righttrigger:b9,rightx:a2,righty:a3,start:b10,x:b2,y:b3,hint:SDL_GAMECONTROLLER_USE_BUTTON_LABELS:=1,",
-    "fc547396886d4f55add913767f0f511c,Wii Classic Controller,a:b1,b:b0,back:b11,dpdown:b15,dpleft:b12,dpright:b14,dpup:b13,leftshoulder:b6,leftstick:b4,lefttrigger:b8,leftx:a0,lefty:a1,rightshoulder:b7,rightstick:b5,righttrigger:b9,rightx:a2,righty:a3,start:b10,x:b3,y:b2,hint:!SDL_GAMECONTROLLER_USE_BUTTON_LABELS:=1,",
-    "cb9d4bbb6936494d891719af55b27e4d,Wii Remote + Nunchuk,a:b0,b:b1,back:b11,dpdown:b15,dpleft:b12,dpright:b14,dpup:b13,leftshoulder:b6,leftstick:b4,lefttrigger:b8,leftx:a0,lefty:a1,rightshoulder:b7,rightstick:b5,righttrigger:b9,rightx:a2,righty:a3,start:b10,x:b2,y:b3,",
-    "88aa88b54e2742d2b4bbe04284a5a7a1,Wii Remote,a:b7,b:b6,back:b11,dpdown:b12,dpleft:b13,dpright:b15,dpup:b14,start:b10,x:b1,y:b0,",
+    "0000000057696920552047616d657000,Wii U Gamepad,crc:e2e7,a:b0,b:b1,back:b11,dpdown:b15,dpleft:b12,dpright:b14,dpup:b13,leftshoulder:b6,leftstick:b4,lefttrigger:b8,leftx:a0,lefty:a1,rightshoulder:b7,rightstick:b5,righttrigger:b9,rightx:a2,righty:a3,start:b10,x:b2,y:b3,hint:SDL_GAMECONTROLLER_USE_BUTTON_LABELS:=1,",
+    "0000000057696920552047616d657000,Wii U Gamepad,crc:e2e7,a:b1,b:b0,back:b11,dpdown:b15,dpleft:b12,dpright:b14,dpup:b13,leftshoulder:b6,leftstick:b4,lefttrigger:b8,leftx:a0,lefty:a1,rightshoulder:b7,rightstick:b5,righttrigger:b9,rightx:a2,righty:a3,start:b10,x:b3,y:b2,hint:!SDL_GAMECONTROLLER_USE_BUTTON_LABELS:=1,",
+    "0000000057696920552050726f204300,Wii U Pro Controller,crc:e45c,a:b0,b:b1,back:b11,dpdown:b15,dpleft:b12,dpright:b14,dpup:b13,leftshoulder:b6,leftstick:b4,lefttrigger:b8,leftx:a0,lefty:a1,rightshoulder:b7,rightstick:b5,righttrigger:b9,rightx:a2,righty:a3,start:b10,x:b2,y:b3,hint:SDL_GAMECONTROLLER_USE_BUTTON_LABELS:=1,",
+    "0000000057696920552050726f204300,Wii U Pro Controller,crc:e45c,a:b1,b:b0,back:b11,dpdown:b15,dpleft:b12,dpright:b14,dpup:b13,leftshoulder:b6,leftstick:b4,lefttrigger:b8,leftx:a0,lefty:a1,rightshoulder:b7,rightstick:b5,righttrigger:b9,rightx:a2,righty:a3,start:b10,x:b3,y:b2,hint:!SDL_GAMECONTROLLER_USE_BUTTON_LABELS:=1,",
+    "0000000057696920436c617373696300,Wii Classic Controller,crc:5ef0,a:b0,b:b1,back:b11,dpdown:b15,dpleft:b12,dpright:b14,dpup:b13,leftshoulder:b6,leftstick:b4,lefttrigger:b8,leftx:a0,lefty:a1,rightshoulder:b7,rightstick:b5,righttrigger:b9,rightx:a2,righty:a3,start:b10,x:b2,y:b3,hint:SDL_GAMECONTROLLER_USE_BUTTON_LABELS:=1,",
+    "0000000057696920436c617373696300,Wii Classic Controller,crc:5ef0,a:b1,b:b0,back:b11,dpdown:b15,dpleft:b12,dpright:b14,dpup:b13,leftshoulder:b6,leftstick:b4,lefttrigger:b8,leftx:a0,lefty:a1,rightshoulder:b7,rightstick:b5,righttrigger:b9,rightx:a2,righty:a3,start:b10,x:b3,y:b2,hint:!SDL_GAMECONTROLLER_USE_BUTTON_LABELS:=1,",
+    "00000000576969204e756e6368756b00,Wii Remote + Nunchuk,crc:bce1,a:b0,b:b1,back:b11,dpdown:b15,dpleft:b12,dpright:b14,dpup:b13,leftshoulder:b6,leftstick:b4,lefttrigger:b8,leftx:a0,lefty:a1,rightshoulder:b7,rightstick:b5,righttrigger:b9,rightx:a2,righty:a3,start:b10,x:b2,y:b3,",
+    "000000005769692052656d6f74650000,Wii Remote,crc:1d69,a:b7,b:b6,back:b11,dpdown:b12,dpleft:b13,dpright:b15,dpup:b14,start:b10,x:b1,y:b0,",
 #endif
     "hidapi,*,a:b0,b:b1,back:b4,dpdown:b12,dpleft:b13,dpright:b14,dpup:b11,guide:b5,leftshoulder:b9,leftstick:b7,lefttrigger:a4,leftx:a0,lefty:a1,rightshoulder:b10,rightstick:b8,righttrigger:a5,rightx:a2,righty:a3,start:b6,x:b2,y:b3,",
     NULL
diff --git a/src/joystick/wiiu/SDL_wiiujoystick.c b/src/joystick/wiiu/SDL_wiiujoystick.c
index bb449c573..19ba6c87e 100644
--- a/src/joystick/wiiu/SDL_wiiujoystick.c
+++ b/src/joystick/wiiu/SDL_wiiujoystick.c
@@ -269,15 +269,13 @@ static void WIIU_JoystickSetDevicePlayerIndex(int device_index, int player_index
 /* Function to return the stable GUID for a plugged in device */
 static SDL_JoystickGUID WIIU_JoystickGetDeviceGUID(int device_index)
 {
-	/* These are random GUIDs that were generated with http://guid.one/ . */
 	SDL_JoystickGUID guid;
-
 	const int wiiu_device = WIIU_GetDeviceForIndex(device_index);
 
 	switch (wiiu_device)
 	{
 		case WIIU_DEVICE_GAMEPAD:
-			guid = (SDL_JoystickGUID){{0x49, 0xdc, 0xab, 0x4b, 0x72, 0xe9, 0x42, 0xa1, 0xad, 0x93, 0x8e, 0x4a, 0xeb, 0x88, 0xd8, 0x68}};
+			guid = SDL_CreateJoystickGUIDForName("Wii U Gamepad");
 			break;
 
 		case WIIU_DEVICE_WPAD(0):
@@ -289,25 +287,21 @@ static SDL_JoystickGUID WIIU_JoystickGetDeviceGUID(int device_index)
 				case WPAD_EXT_CORE:
 				case WPAD_EXT_MPLUS:
 				default:
-					/* Wii Remote */
-					guid = (SDL_JoystickGUID){{0x88, 0xaa, 0x88, 0xb5, 0x4e, 0x27, 0x42, 0xd2, 0xb4, 0xbb, 0xe0, 0x42, 0x84, 0xa5, 0xa7, 0xa1}};
+					guid = SDL_CreateJoystickGUIDForName("Wii Remote");
 					break;
 
 				case WPAD_EXT_NUNCHUK:
 				case WPAD_EXT_MPLUS_NUNCHUK:
-					/* Wii Remote + Nunchuk */
-					guid = (SDL_JoystickGUID){{0xcb, 0x9d, 0x4b, 0xbb, 0x69, 0x36, 0x49, 0x4d, 0x89, 0x17, 0x19, 0xaf, 0x55, 0xb2, 0x7e, 0x4d}};
+					guid = SDL_CreateJoystickGUIDForName("Wii Nunchuk");
 					break;
 
 				case WPAD_EXT_CLASSIC:
 				case WPAD_EXT_MPLUS_CLASSIC:
-					/* Wii Classic Controller */
-					guid = (SDL_JoystickGUID){{0xfc, 0x54, 0x73, 0x96, 0x88, 0x6d, 0x4f, 0x55, 0xad, 0xd9, 0x13, 0x76, 0x7f, 0x0f, 0x51, 0x1c}};
+					guid = SDL_CreateJoystickGUIDForName("Wii Classic Controller");
 					break;
 
 				case WPAD_EXT_PRO_CONTROLLER:
-					/* Wii U Pro Controller */
-					guid = (SDL_JoystickGUID){{0x69, 0x72, 0xc1, 0x58, 0x6f, 0x70, 0x4c, 0x4e, 0x9d, 0x80, 0xcc, 0x89, 0x57, 0xab, 0xb8, 0x14}};
+					guid = SDL_CreateJoystickGUIDForName("Wii U Pro Controller");
 					break;
 			}
 
-- 
2.20.1


From 97bedb9f40d74a2cdcc7a1297cd8cca5f87d1657 Mon Sep 17 00:00:00 2001
From: GaryOderNichts <12049776+GaryOderNichts@users.noreply.github.com>
Date: Sun, 16 Apr 2023 16:04:03 +0200
Subject: [PATCH 24/28] wiiu/render: Fix clip rect state

---
 src/render/wiiu/SDL_render_wiiu.c |  2 --
 src/render/wiiu/SDL_render_wiiu.h |  1 -
 src/render/wiiu/SDL_rqueue_wiiu.c | 24 ++++++++++++------------
 3 files changed, 12 insertions(+), 15 deletions(-)

diff --git a/src/render/wiiu/SDL_render_wiiu.c b/src/render/wiiu/SDL_render_wiiu.c
index 9b92d7411..ad26e9a35 100644
--- a/src/render/wiiu/SDL_render_wiiu.c
+++ b/src/render/wiiu/SDL_render_wiiu.c
@@ -194,8 +194,6 @@ int WIIU_SDL_SetRenderTarget(SDL_Renderer * renderer, SDL_Texture * texture)
     /* Wait for the texture rendering to finish */
     WIIU_TextureCheckWaitRendering(data, tdata);
 
-    data->drawState.viewportDirty = SDL_TRUE;
-
     /* Update context state */
     GX2SetColorBuffer(&tdata->cbuf, GX2_RENDER_TARGET_0);
 
diff --git a/src/render/wiiu/SDL_render_wiiu.h b/src/render/wiiu/SDL_render_wiiu.h
index 648f8a8f7..84347ba56 100644
--- a/src/render/wiiu/SDL_render_wiiu.h
+++ b/src/render/wiiu/SDL_render_wiiu.h
@@ -78,7 +78,6 @@ struct WIIU_DrawState
     int drawableWidth, drawableHeight;
     float projectionMatrix[4][4];
 
-    SDL_bool cliprectEnabledDirty;
     SDL_bool cliprectEnabled;
     SDL_bool cliprectDirty;
     SDL_Rect cliprect;
diff --git a/src/render/wiiu/SDL_rqueue_wiiu.c b/src/render/wiiu/SDL_rqueue_wiiu.c
index 382212f4f..bafdcecd5 100644
--- a/src/render/wiiu/SDL_rqueue_wiiu.c
+++ b/src/render/wiiu/SDL_rqueue_wiiu.c
@@ -286,24 +286,19 @@ static int WIIU_SDL_SetDrawState(WIIU_RenderData * data, const SDL_RenderCommand
         data->drawState.viewportDirty = SDL_FALSE;
     }
 
-    if (data->drawState.cliprectEnabledDirty || data->drawState.cliprectDirty) {
+    if (data->drawState.cliprectDirty) {
         SDL_Rect scissor;
         const SDL_Rect *viewport = &data->drawState.viewport;
         const SDL_Rect *rect = &data->drawState.cliprect;
 
-        if (data->drawState.cliprectEnabled) {
-            // make sure scissor is never larger than the colorbuffer to prevent memory corruption
-            scissor.x = SDL_clamp(rect->x, 0, viewport->w);
-            scissor.y = SDL_clamp(rect->y, 0, viewport->h);
-            scissor.w = SDL_clamp(rect->w, 0, viewport->w);
-            scissor.h = SDL_clamp(rect->h, 0, viewport->h);
-        } else {
-            scissor = *viewport;
-        }
+        // make sure scissor is never larger than the colorbuffer to prevent memory corruption
+        scissor.x = SDL_clamp(rect->x, 0, viewport->w);
+        scissor.y = SDL_clamp(rect->y, 0, viewport->h);
+        scissor.w = SDL_clamp(rect->w, 0, viewport->w);
+        scissor.h = SDL_clamp(rect->h, 0, viewport->h);
 
         GX2SetScissor(scissor.x, scissor.y, scissor.w, scissor.h);
 
-        data->drawState.cliprectEnabledDirty = SDL_FALSE;
         data->drawState.cliprectDirty = SDL_FALSE;
     }
 
@@ -394,7 +389,12 @@ int WIIU_SDL_RunCommandQueue(SDL_Renderer * renderer, SDL_RenderCommand *cmd, vo
                 const SDL_Rect *rect = &cmd->data.cliprect.rect;
                 if (data->drawState.cliprectEnabled != cmd->data.cliprect.enabled) {
                     data->drawState.cliprectEnabled = cmd->data.cliprect.enabled;
-                    data->drawState.cliprectEnabledDirty = SDL_TRUE;
+                    data->drawState.cliprectDirty = SDL_TRUE;
+                }
+
+                if (!data->drawState.cliprectEnabled) {
+                    /* If the clip rect is disabled, then the scissor rect should be the whole viewport */
+                    rect = &data->drawState.viewport;
                 }
 
                 if (SDL_memcmp(&data->drawState.cliprect, rect, sizeof (SDL_Rect)) != 0) {
-- 
2.20.1


From 351bb2afe8dfe491ce8cb98951e25609bb67372d Mon Sep 17 00:00:00 2001
From: GaryOderNichts <12049776+GaryOderNichts@users.noreply.github.com>
Date: Sun, 30 Apr 2023 12:29:51 +0200
Subject: [PATCH 25/28] wiiu/audio: Restore thread affinity on early returns

---
 src/audio/wiiu/SDL_wiiuaudio.c | 18 +++++++++++++-----
 1 file changed, 13 insertions(+), 5 deletions(-)

diff --git a/src/audio/wiiu/SDL_wiiuaudio.c b/src/audio/wiiu/SDL_wiiuaudio.c
index 763653531..706ca9761 100644
--- a/src/audio/wiiu/SDL_wiiuaudio.c
+++ b/src/audio/wiiu/SDL_wiiuaudio.c
@@ -60,6 +60,7 @@ static SDL_AudioDevice* cb_this;
 #define next_id(id) (id + 1) % NUM_BUFFERS
 
 static int WIIUAUDIO_OpenDevice(_THIS, const char* devname) {
+    int ret = 0;
     AXVoiceOffsets offs;
     AXVoiceVeData vol = {
         .volume = 0x8000,
@@ -68,7 +69,10 @@ static int WIIUAUDIO_OpenDevice(_THIS, const char* devname) {
     float srcratio;
 
     this->hidden = (struct SDL_PrivateAudioData*)SDL_malloc(sizeof(*this->hidden));
-    if (this->hidden == NULL) return SDL_OutOfMemory();
+    if (this->hidden == NULL) {
+        return SDL_OutOfMemory();
+    }
+
     SDL_zerop(this->hidden);
 
 /*  We *must not* change cores when setting stuff up */
@@ -117,7 +121,8 @@ static int WIIUAUDIO_OpenDevice(_THIS, const char* devname) {
         if (this->hidden->mixbufs[i] == NULL) {
             AXQuit();
             printf("DEBUG: Couldn't allocate buffer");
-            return SDL_SetError("Couldn't allocate buffer");
+            ret = SDL_SetError("Couldn't allocate buffer");
+            goto end;
         }
 
         memset(this->hidden->mixbufs[i], 0, this->spec.size);
@@ -129,7 +134,8 @@ static int WIIUAUDIO_OpenDevice(_THIS, const char* devname) {
     if (this->hidden->deintvbuf == NULL) {
         AXQuit();
         printf("DEBUG: Couldn't allocate deinterleave buffer");
-        return SDL_SetError("Couldn't allocate deinterleave buffer");
+        ret = SDL_SetError("Couldn't allocate deinterleave buffer");
+        goto end;
     }
 
 
@@ -139,7 +145,8 @@ static int WIIUAUDIO_OpenDevice(_THIS, const char* devname) {
         if (!this->hidden->voice[i]) {
             AXQuit();
             printf("DEBUG: couldn't get voice\n");
-            return SDL_OutOfMemory();
+            ret = SDL_OutOfMemory();
+            goto end;
         }
 
     /*  Start messing with it */
@@ -211,9 +218,10 @@ static int WIIUAUDIO_OpenDevice(_THIS, const char* devname) {
     cb_this = this; //wish there was a better way
     AXRegisterAppFrameCallback(_WIIUAUDIO_framecallback);
 
+end: ;
 /*  Put the thread affinity back to normal - we won't call any more AX funcs */
     OSSetThreadAffinity(OSGetCurrentThread(), old_affinity);
-    return 0;
+    return ret;
 }
 
 /*  Called every 3ms before a frame of audio is rendered. Keep it fast! */
-- 
2.20.1


From a4c061395b9dcaf46e90e07ee128013bfece1cdd Mon Sep 17 00:00:00 2001
From: GaryOderNichts <12049776+GaryOderNichts@users.noreply.github.com>
Date: Sun, 30 Apr 2023 22:22:00 +0200
Subject: [PATCH 26/28] wiiu/audio: Ensure mixbuf is within a 512 MiB memory
 block

---
 src/audio/wiiu/SDL_wiiuaudio.c | 53 +++++++++++++++++++++++++---------
 1 file changed, 40 insertions(+), 13 deletions(-)

diff --git a/src/audio/wiiu/SDL_wiiuaudio.c b/src/audio/wiiu/SDL_wiiuaudio.c
index 706ca9761..e6f128915 100644
--- a/src/audio/wiiu/SDL_wiiuaudio.c
+++ b/src/audio/wiiu/SDL_wiiuaudio.c
@@ -23,6 +23,7 @@
 #if SDL_AUDIO_DRIVER_WIIU
 
 #include <stdio.h>
+#include <malloc.h>
 
 #include "SDL_audio.h"
 #include "SDL_error.h"
@@ -40,6 +41,7 @@
 #include <coreinit/cache.h>
 #include <coreinit/thread.h>
 #include <coreinit/time.h>
+#include <coreinit/memorymap.h>
 
 #define WIIUAUDIO_DRIVER_NAME "wiiu"
 
@@ -67,6 +69,9 @@ static int WIIUAUDIO_OpenDevice(_THIS, const char* devname) {
     };
     uint32_t old_affinity;
     float srcratio;
+    Uint8* mixbuf = NULL;
+    uint32_t mixbuf_allocation_count = 0;
+    Uint8* mixbuf_allocations[32];
 
     this->hidden = (struct SDL_PrivateAudioData*)SDL_malloc(sizeof(*this->hidden));
     if (this->hidden == NULL) {
@@ -115,18 +120,42 @@ static int WIIUAUDIO_OpenDevice(_THIS, const char* devname) {
 /*  We changed channels and samples, so recalculate the spec */
     SDL_CalculateAudioSpec(&this->spec);
 
-/*  Allocate buffers for double-buffering and samples */
-    for (int i = 0; i < NUM_BUFFERS; i++) {
-        this->hidden->mixbufs[i] = SDL_malloc(this->spec.size);
-        if (this->hidden->mixbufs[i] == NULL) {
-            AXQuit();
-            printf("DEBUG: Couldn't allocate buffer");
-            ret = SDL_SetError("Couldn't allocate buffer");
-            goto end;
+/*  Allocate buffers for double-buffering and samples.
+    Make sure the entire mixbuf is in a 512MiB block for the DSP to be accessible. */
+    for (int i = 0; i < 32; i++) {
+        Uint32 physStart, physEnd;
+        mixbuf = memalign(0x40, this->spec.size * NUM_BUFFERS);
+        if (!mixbuf) {
+            break;
         }
 
-        memset(this->hidden->mixbufs[i], 0, this->spec.size);
-        DCStoreRange(this->hidden->mixbufs[i], this->spec.size);
+        physStart = OSEffectiveToPhysical((uint32_t) mixbuf) & 0x1fffffff;
+        physEnd = physStart + this->spec.size * NUM_BUFFERS;
+        if ((physEnd & 0xe0000000) == 0) {
+            break;
+        }
+
+        mixbuf_allocations[mixbuf_allocation_count] = mixbuf;
+        mixbuf_allocation_count++;
+        mixbuf = NULL;
+    }
+
+/*  Free the failed attempts */
+    while (mixbuf_allocation_count--) {
+        free(mixbuf_allocations[mixbuf_allocation_count]);
+    }
+
+    if (!mixbuf) {
+        printf("Couldn't allocate mix buffer\n");
+        ret = SDL_OutOfMemory();
+        goto end;
+    }
+
+    memset(mixbuf, 0, this->spec.size * NUM_BUFFERS);
+    DCStoreRange(mixbuf, this->spec.size * NUM_BUFFERS);
+
+    for (int i = 0; i < NUM_BUFFERS; i++) {
+        this->hidden->mixbufs[i] = mixbuf + this->spec.size * i;
     }
 
 /*  Allocate a scratch buffer for deinterleaving operations */
@@ -363,9 +392,7 @@ static void WIIUAUDIO_CloseDevice(_THIS) {
         }
         AXQuit();
     }
-    for (int i = 0; i < NUM_BUFFERS; i++) {
-        if (this->hidden->mixbufs[i]) SDL_free(this->hidden->mixbufs[i]);
-    }
+    if (this->hidden->mixbufs[0]) free(this->hidden->mixbufs[0]);
     if (this->hidden->deintvbuf) SDL_free(this->hidden->deintvbuf);
     SDL_free(this->hidden);
 }
-- 
2.20.1


From cd53049e5699120c8ccc98ff64a71ed59a3208cb Mon Sep 17 00:00:00 2001
From: GaryOderNichts <12049776+GaryOderNichts@users.noreply.github.com>
Date: Sun, 10 Sep 2023 14:09:50 +0200
Subject: [PATCH 27/28] wiiu/video: Call GX2SetTV/DRCEnable on leaving
 foreground This fixes having a black background while the HBM is active.

---
 src/video/wiiu/SDL_wiiuvideo.c | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/src/video/wiiu/SDL_wiiuvideo.c b/src/video/wiiu/SDL_wiiuvideo.c
index dd89c4e29..f42f206aa 100644
--- a/src/video/wiiu/SDL_wiiuvideo.c
+++ b/src/video/wiiu/SDL_wiiuvideo.c
@@ -160,6 +160,11 @@ static int WIIU_ForegroundReleased(_THIS)
 
 	WIIU_GfxHeap_MEM1Destroy();
 	WIIU_GfxHeap_ForegroundDestroy();
+
+	// This is necessary to avoid a black frame on leaving foreground
+	GX2SetTVEnable(TRUE);
+	GX2SetDRCEnable(TRUE);
+
 	videodata->hasForeground = SDL_FALSE;
 
 	return 0;
-- 
2.20.1


From 7b058bd042a7c624c277aaddbca6fb2f6ae5233d Mon Sep 17 00:00:00 2001
From: GaryOderNichts <12049776+GaryOderNichts@users.noreply.github.com>
Date: Wed, 8 Nov 2023 19:56:46 +0100
Subject: [PATCH 28/28] wiiu/thread: Add missing NULL checks to mutex code

According to  the changes in d59caffe2c8e80aa9d38574fd17974ec5cf05d2b:
> [...] SDL has the concept of a NULL mutex, so the mutex functions have been changed not to report errors if a mutex hasn't been initialized.
> We do have mutexes that might be accessed when they are NULL, notably in the event system, so this is an important change.
---
 src/thread/wiiu/SDL_sysmutex.c | 24 ++++++++++++++++++++----
 1 file changed, 20 insertions(+), 4 deletions(-)

diff --git a/src/thread/wiiu/SDL_sysmutex.c b/src/thread/wiiu/SDL_sysmutex.c
index f0c81699a..4d80b161e 100644
--- a/src/thread/wiiu/SDL_sysmutex.c
+++ b/src/thread/wiiu/SDL_sysmutex.c
@@ -34,22 +34,30 @@ SDL_CreateMutex(void)
 
     /* Allocate the structure */
     mutex = (OSMutex *) SDL_calloc(1, sizeof(OSMutex));
-    OSInitMutex(mutex);
+    if (mutex != NULL) {
+        OSInitMutex(mutex);
+    } else {
+        SDL_OutOfMemory();
+    }
     return (SDL_mutex *)mutex;
 }
 
 void
 SDL_DestroyMutex(SDL_mutex * mutex)
 {
-    if (mutex) {
+    if (mutex != NULL) {
         SDL_free(mutex);
     }
 }
 
 /* Lock the mutex */
 int
-SDL_LockMutex(SDL_mutex * mutex)
+SDL_LockMutex(SDL_mutex * mutex) SDL_NO_THREAD_SAFETY_ANALYSIS /* clang doesn't know about NULL mutexes */
 {
+    if (mutex == NULL) {
+        return 0;
+    }
+
     OSLockMutex((OSMutex *)mutex);
     return 0;
 }
@@ -57,12 +65,20 @@ SDL_LockMutex(SDL_mutex * mutex)
 int
 SDL_TryLockMutex(SDL_mutex * mutex)
 {
+    if (mutex == NULL) {
+        return 0;
+    }
+
     return OSTryLockMutex((OSMutex *)mutex) ? 0 : SDL_MUTEX_TIMEDOUT;
 }
 
 int
-SDL_UnlockMutex(SDL_mutex * mutex)
+SDL_UnlockMutex(SDL_mutex * mutex) SDL_NO_THREAD_SAFETY_ANALYSIS /* clang doesn't know about NULL mutexes */
 {
+    if (mutex == NULL) {
+        return 0;
+    }
+
     OSUnlockMutex((OSMutex *)mutex);
     return 0;
 }
-- 
2.20.1

